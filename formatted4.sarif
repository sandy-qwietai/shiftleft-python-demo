{
    "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/main/sarif-2.1/schema/sarif-schema-2.1.0.json",
    "version": "2.1.0",
    "runs": [
        {
            "automationDetails": {
                "description": {
                    "text": "Static Analysis Security Test results using ng-sast"
                },
                "guid": "f2404207-6fd9-432d-8266-4be49e37e841"
            },
            "conversion": {
                "invocation": {
                    "commandLine": "",
                    "endTimeUtc": "2025-08-13T07:28:17Z",
                    "executionSuccessful": true,
                    "workingDirectory": {
                        "index": 0,
                        "uri": ""
                    }
                },
                "tool": {
                    "driver": {
                        "name": "ng-sast"
                    }
                }
            },
            "invocations": [
                {
                    "endTimeUtc": "2025-08-13T07:28:17Z",
                    "executionSuccessful": true,
                    "workingDirectory": {
                        "index": 0,
                        "uri": ""
                    }
                }
            ],
            "language": "en-US",
            "newlineSequences": [
                "\r\n",
                "\n"
            ],
            "results": [
                {
                    "fingerprints": {
                        "evidenceFingerprint": "c009106a02a5d06a1463ab6c9dfb43f8dcdc122ae00d0664066fc2dc1b6fbcfe"
                    },
                    "baselineState": "new",
                    "kind": "fail",
                    "level": "warning",
                    "locations": [
                        {
                            "id": -1,
                            "physicalLocation": {
                                "artifactLocation": {
                                    "index": -1,
                                    "uri": "flask_webgoat/__init__.py"
                                },
                                "region": {
                                    "byteOffset": -1,
                                    "charOffset": -1,
                                    "snippet": {},
                                    "startLine": 22
                                }
                            }
                        }
                    ],
                    "message": {
                        "markdown": "Secret Keyword",
                        "text": "Secret Keyword"
                    },
                    "properties": {
                        "issue_confidence": "HIGH",
                        "issue_severity": "medium",
                        "score": "5.5"
                    },
                    "rank": -1,
                    "ruleId": "Secret%20Keyword/7b2be704053344919e45a063df09788faa78eca804b0ab4a43721c6bd6f116fd",
                    "ruleIndex": 0
                },
                {
                    "fingerprints": {
                        "evidenceFingerprint": "d4f7f9b6ff9892c0a7c2e4e9a1287900504f124ae01d51a73f603fb0d80e26d3"
                    },
                    "baselineState": "new",
                    "codeFlows": [
                        {
                            "threadFlows": [
                                {
                                    "locations": [
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/actions.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 6
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/actions.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 42
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/actions.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 45
                                                    }
                                                }
                                            }
                                        }
                                    ]
                                }
                            ]
                        }
                    ],
                    "kind": "fail",
                    "level": "error",
                    "locations": [
                        {
                            "id": -1,
                            "physicalLocation": {
                                "artifactLocation": {
                                    "index": -1,
                                    "uri": "flask_webgoat/actions.py"
                                },
                                "region": {
                                    "byteOffset": -1,
                                    "charOffset": -1,
                                    "snippet": {},
                                    "startLine": 45
                                }
                            }
                        }
                    ],
                    "message": {
                        "markdown": "Remote Code Execution: Command Injection Through Attacker-controlled Data in `actions.py`",
                        "text": "Remote Code Execution: Command Injection Through Attacker-controlled Data in actions.py"
                    },
                    "properties": {
                        "issue_confidence": "HIGH",
                        "issue_severity": "critical",
                        "score": "9"
                    },
                    "rank": -1,
                    "ruleId": "command-injection-attacker-controlled/bac5e23fada9210865f45fe67852cf62",
                    "ruleIndex": 1
                },
                {
                    "fingerprints": {
                        "evidenceFingerprint": "695b325710aeee58608db65161e5c25ab146e97b6e82fce7ab5dbe1737514306"
                    },
                    "baselineState": "new",
                    "codeFlows": [
                        {
                            "threadFlows": [
                                {
                                    "locations": [
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "run.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 8
                                                    }
                                                }
                                            }
                                        }
                                    ]
                                }
                            ]
                        }
                    ],
                    "kind": "fail",
                    "level": "warning",
                    "locations": [
                        {
                            "id": -1,
                            "physicalLocation": {
                                "artifactLocation": {
                                    "index": -1,
                                    "uri": "run.py"
                                },
                                "region": {
                                    "byteOffset": -1,
                                    "charOffset": -1,
                                    "snippet": {},
                                    "startLine": 8
                                }
                            }
                        }
                    ],
                    "message": {
                        "markdown": "Cross-Site Request Forgery: Overly Permissive CORS Policy in `add_csp_headers`",
                        "text": "Cross-Site Request Forgery: Overly Permissive CORS Policy in add_csp_headers"
                    },
                    "properties": {
                        "issue_confidence": "HIGH",
                        "issue_severity": "medium",
                        "score": "4"
                    },
                    "rank": -1,
                    "ruleId": "cors-disabled/abf6a56d9c58899d4ed5c9cd3106f0c5",
                    "ruleIndex": 2
                },
                {
                    "fingerprints": {
                        "evidenceFingerprint": "2fa0138eb164fe7c4de8cc9d1e53b62af0c81250b38432a75b2b79009d3e2610"
                    },
                    "baselineState": "new",
                    "codeFlows": [
                        {
                            "threadFlows": [
                                {
                                    "locations": [
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/actions.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 6
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/actions.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 58
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/actions.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 59
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/actions.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 61
                                                    }
                                                }
                                            }
                                        }
                                    ]
                                }
                            ]
                        }
                    ],
                    "kind": "fail",
                    "level": "error",
                    "locations": [
                        {
                            "id": -1,
                            "physicalLocation": {
                                "artifactLocation": {
                                    "index": -1,
                                    "uri": "flask_webgoat/actions.py"
                                },
                                "region": {
                                    "byteOffset": -1,
                                    "charOffset": -1,
                                    "snippet": {},
                                    "startLine": 61
                                }
                            }
                        }
                    ],
                    "message": {
                        "markdown": "Deserialization: Attacker-controlled Data Used in Unsafe Deserialization Function in `actions.py`",
                        "text": "Deserialization: Attacker-controlled Data Used in Unsafe Deserialization Function in actions.py"
                    },
                    "properties": {
                        "issue_confidence": "HIGH",
                        "issue_severity": "high",
                        "score": "8"
                    },
                    "rank": -1,
                    "ruleId": "deserialization-attacker-controlled/5a0f3a67399030e2db46c0ae489e2615",
                    "ruleIndex": 3
                },
                {
                    "fingerprints": {
                        "evidenceFingerprint": "ab8c789fd2d888ca5c19db6c0454ca74b17259c850ea9bff60394f64ece44066"
                    },
                    "baselineState": "new",
                    "codeFlows": [
                        {
                            "threadFlows": [
                                {
                                    "locations": [
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/actions.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 6
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/actions.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 19
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/actions.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 32
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/actions.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 33
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/actions.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 34
                                                    }
                                                }
                                            }
                                        }
                                    ]
                                }
                            ]
                        }
                    ],
                    "kind": "fail",
                    "level": "error",
                    "locations": [
                        {
                            "id": -1,
                            "physicalLocation": {
                                "artifactLocation": {
                                    "index": -1,
                                    "uri": "flask_webgoat/actions.py"
                                },
                                "region": {
                                    "byteOffset": -1,
                                    "charOffset": -1,
                                    "snippet": {},
                                    "startLine": 34
                                }
                            }
                        }
                    ],
                    "message": {
                        "markdown": "Directory Traversal: Attacker-controlled Data Used in File Path in `actions.py`",
                        "text": "Directory Traversal: Attacker-controlled Data Used in File Path in actions.py"
                    },
                    "properties": {
                        "issue_confidence": "HIGH",
                        "issue_severity": "critical",
                        "score": "9"
                    },
                    "rank": -1,
                    "ruleId": "directory-traversal-http/a3195627657f14358fa8c5aba224b439",
                    "ruleIndex": 4
                },
                {
                    "fingerprints": {
                        "evidenceFingerprint": "851656ef1718361404f27c8bf0151c099a6dc5533c291b88d109aa2443fcbb82"
                    },
                    "baselineState": "new",
                    "codeFlows": [
                        {
                            "threadFlows": [
                                {
                                    "locations": [
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/actions.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 29
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/actions.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 30
                                                    }
                                                }
                                            }
                                        }
                                    ]
                                }
                            ]
                        }
                    ],
                    "kind": "fail",
                    "level": "note",
                    "locations": [
                        {
                            "id": -1,
                            "physicalLocation": {
                                "artifactLocation": {
                                    "index": -1,
                                    "uri": "flask_webgoat/actions.py"
                                },
                                "region": {
                                    "byteOffset": -1,
                                    "charOffset": -1,
                                    "snippet": {},
                                    "startLine": 30
                                }
                            }
                        }
                    ],
                    "message": {
                        "markdown": "Race Condition: Check Followed by Read or Write Operation on Same File Path in `log_entry`",
                        "text": "Race Condition: Check Followed by Read or Write Operation on Same File Path in log_entry"
                    },
                    "properties": {
                        "issue_confidence": "HIGH",
                        "issue_severity": "low",
                        "score": "3"
                    },
                    "rank": -1,
                    "ruleId": "file-toctou/e09e0e192b233e78426e0ef3ff3097f9",
                    "ruleIndex": 5
                },
                {
                    "fingerprints": {
                        "evidenceFingerprint": "d860e3453ca20c3db38a0c725b65e9a290e3a626c7066a466627caa8eb5a8ff3"
                    },
                    "baselineState": "new",
                    "codeFlows": [
                        {
                            "threadFlows": [
                                {
                                    "locations": [
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/auth.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 1
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/auth.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 9
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/auth.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 20
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/auth.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 19
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/auth.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 18
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/auth.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 22
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/__init__.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 10
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/__init__.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 14
                                                    }
                                                }
                                            }
                                        }
                                    ]
                                }
                            ]
                        }
                    ],
                    "kind": "fail",
                    "level": "error",
                    "locations": [
                        {
                            "id": -1,
                            "physicalLocation": {
                                "artifactLocation": {
                                    "index": -1,
                                    "uri": "flask_webgoat/__init__.py"
                                },
                                "region": {
                                    "byteOffset": -1,
                                    "charOffset": -1,
                                    "snippet": {},
                                    "startLine": 14
                                }
                            }
                        }
                    ],
                    "message": {
                        "markdown": "SQL Injection: Attacker-controlled Data Used in SQL Query in `auth.py`",
                        "text": "SQL Injection: Attacker-controlled Data Used in SQL Query in auth.py"
                    },
                    "properties": {
                        "issue_confidence": "HIGH",
                        "issue_severity": "critical",
                        "score": "9"
                    },
                    "rank": -1,
                    "ruleId": "sql-injection-attacker-controlled/88118c7440143dbf876a6c4318d703ad",
                    "ruleIndex": 6
                },
                {
                    "fingerprints": {
                        "evidenceFingerprint": "5997b70de62e24899b0cf32aa06290542f49dc9c5e2800184df75123ec646dd6"
                    },
                    "baselineState": "new",
                    "codeFlows": [
                        {
                            "threadFlows": [
                                {
                                    "locations": [
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/users.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 3
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/users.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 19
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/users.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 40
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/users.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 39
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/users.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 38
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/users.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 44
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/__init__.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 10
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/__init__.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 14
                                                    }
                                                }
                                            }
                                        }
                                    ]
                                }
                            ]
                        }
                    ],
                    "kind": "fail",
                    "level": "error",
                    "locations": [
                        {
                            "id": -1,
                            "physicalLocation": {
                                "artifactLocation": {
                                    "index": -1,
                                    "uri": "flask_webgoat/__init__.py"
                                },
                                "region": {
                                    "byteOffset": -1,
                                    "charOffset": -1,
                                    "snippet": {},
                                    "startLine": 14
                                }
                            }
                        }
                    ],
                    "message": {
                        "markdown": "SQL Injection: Attacker-controlled Data Used in SQL Query in `users.py`",
                        "text": "SQL Injection: Attacker-controlled Data Used in SQL Query in users.py"
                    },
                    "properties": {
                        "issue_confidence": "HIGH",
                        "issue_severity": "critical",
                        "score": "9"
                    },
                    "rank": -1,
                    "ruleId": "sql-injection-attacker-controlled/a55eb487bc5de2aad461b8d46ea69d74",
                    "ruleIndex": 7
                },
                {
                    "fingerprints": {
                        "evidenceFingerprint": "865ecfc7007ec5295f4e8e23da043639b715be9ac3756899abf9b9d53d39f761"
                    },
                    "baselineState": "new",
                    "codeFlows": [
                        {
                            "threadFlows": [
                                {
                                    "locations": [
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/actions.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 45
                                                    }
                                                }
                                            }
                                        }
                                    ]
                                }
                            ]
                        }
                    ],
                    "kind": "fail",
                    "level": "error",
                    "locations": [
                        {
                            "id": -1,
                            "physicalLocation": {
                                "artifactLocation": {
                                    "index": -1,
                                    "uri": "flask_webgoat/actions.py"
                                },
                                "region": {
                                    "byteOffset": -1,
                                    "charOffset": -1,
                                    "snippet": {},
                                    "startLine": 45
                                }
                            }
                        }
                    ],
                    "message": {
                        "markdown": "Command Injection: Execution of Non-Constant Shell Commands in `grep_processes`",
                        "text": "Command Injection: Execution of Non-Constant Shell Commands in grep_processes"
                    },
                    "properties": {
                        "issue_confidence": "HIGH",
                        "issue_severity": "high",
                        "score": "8.5"
                    },
                    "rank": -1,
                    "ruleId": "warning-sink-execute/311beedfa8d03cc4123ae1de94a95257",
                    "ruleIndex": 8
                },
                {
                    "fingerprints": {
                        "evidenceFingerprint": "e0b488eec7ded49592561432ac92fecf4b47391d2ccf33f4ef4d4cb598dbef32"
                    },
                    "baselineState": "new",
                    "codeFlows": [
                        {
                            "threadFlows": [
                                {
                                    "locations": [
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/__init__.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 14
                                                    }
                                                }
                                            }
                                        }
                                    ]
                                }
                            ]
                        }
                    ],
                    "kind": "fail",
                    "level": "error",
                    "locations": [
                        {
                            "id": -1,
                            "physicalLocation": {
                                "artifactLocation": {
                                    "index": -1,
                                    "uri": "flask_webgoat/__init__.py"
                                },
                                "region": {
                                    "byteOffset": -1,
                                    "charOffset": -1,
                                    "snippet": {},
                                    "startLine": 14
                                }
                            }
                        }
                    ],
                    "message": {
                        "markdown": "SQL Injection: Non-Constant SQL Statement in `query_db`",
                        "text": "SQL Injection: Non-Constant SQL Statement in query_db"
                    },
                    "properties": {
                        "issue_confidence": "HIGH",
                        "issue_severity": "high",
                        "score": "8"
                    },
                    "rank": -1,
                    "ruleId": "warning-sink-sql/8ffca272ab87817404c8228a4263bfc8",
                    "ruleIndex": 9
                },
                {
                    "fingerprints": {
                        "evidenceFingerprint": "2235182bb9a95a19498bd2c1635654d09e4bf2034dd152cfd359418bd1104bf8"
                    },
                    "baselineState": "new",
                    "codeFlows": [
                        {
                            "threadFlows": [
                                {
                                    "locations": [
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "run.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 10
                                                    }
                                                }
                                            }
                                        }
                                    ]
                                }
                            ]
                        }
                    ],
                    "kind": "fail",
                    "level": "warning",
                    "locations": [
                        {
                            "id": -1,
                            "physicalLocation": {
                                "artifactLocation": {
                                    "index": -1,
                                    "uri": "run.py"
                                },
                                "region": {
                                    "byteOffset": -1,
                                    "charOffset": -1,
                                    "snippet": {},
                                    "startLine": 10
                                }
                            }
                        }
                    ],
                    "message": {
                        "markdown": "Security Misconfiguration: Content-Security-Policy Misconfigured in `add_csp_headers`",
                        "text": "Security Misconfiguration: Content-Security-Policy Misconfigured in add_csp_headers"
                    },
                    "properties": {
                        "issue_confidence": "HIGH",
                        "issue_severity": "medium",
                        "score": "5"
                    },
                    "rank": -1,
                    "ruleId": "security-policy-misconfiguration/b0079c7ab0359820380dd9c1e684dd43",
                    "ruleIndex": 10
                },
                {
                    "fingerprints": {
                        "evidenceFingerprint": "6f47972e1b673b454d79a6793da2c23485d22e25b79192276e992c6fdd088c32"
                    },
                    "baselineState": "new",
                    "codeFlows": [
                        {
                            "threadFlows": [
                                {
                                    "locations": [
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/__init__.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 13
                                                    }
                                                }
                                            }
                                        }
                                    ]
                                }
                            ]
                        }
                    ],
                    "kind": "fail",
                    "level": "note",
                    "locations": [
                        {
                            "id": -1,
                            "physicalLocation": {
                                "artifactLocation": {
                                    "index": -1,
                                    "uri": "flask_webgoat/__init__.py"
                                },
                                "region": {
                                    "byteOffset": -1,
                                    "charOffset": -1,
                                    "snippet": {},
                                    "startLine": 13
                                }
                            }
                        }
                    ],
                    "message": {
                        "markdown": "Sensitive Data Exposure: Library is Configured to Print Potentially Sensitive Data in `query_db`",
                        "text": "Sensitive Data Exposure: Library is Configured to Print Potentially Sensitive Data in query_db"
                    },
                    "properties": {
                        "issue_confidence": "HIGH",
                        "issue_severity": "low",
                        "score": "3"
                    },
                    "rank": -1,
                    "ruleId": "log-sensitive-data-fuzzy/a8f021e8f4026424a70930734f4fd4a3",
                    "ruleIndex": 11
                },
                {
                    "fingerprints": {
                        "evidenceFingerprint": "af7d0e3a8985026913347d191476b3fe7eb2387c44e70bf4b740f0485411505f"
                    },
                    "baselineState": "new",
                    "codeFlows": [
                        {
                            "threadFlows": [
                                {
                                    "locations": [
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/__init__.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 1
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/__init__.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 13
                                                    }
                                                }
                                            }
                                        }
                                    ]
                                }
                            ]
                        }
                    ],
                    "kind": "fail",
                    "level": "note",
                    "locations": [
                        {
                            "id": -1,
                            "physicalLocation": {
                                "artifactLocation": {
                                    "index": -1,
                                    "uri": "flask_webgoat/__init__.py"
                                },
                                "region": {
                                    "byteOffset": -1,
                                    "charOffset": -1,
                                    "snippet": {},
                                    "startLine": 13
                                }
                            }
                        }
                    ],
                    "message": {
                        "markdown": "Sensitive Data Exposure: Library is Configured to Print Potentially Sensitive Data in `__init__.py`",
                        "text": "Sensitive Data Exposure: Library is Configured to Print Potentially Sensitive Data in __init__.py"
                    },
                    "properties": {
                        "issue_confidence": "HIGH",
                        "issue_severity": "low",
                        "score": "3"
                    },
                    "rank": -1,
                    "ruleId": "log-sensitive-data-fuzzy/9e532a249bd7d271ae4f8b75130e8c90",
                    "ruleIndex": 12
                },
                {
                    "fingerprints": {
                        "evidenceFingerprint": "9af2585c57fae90c6d504978859a5002650a3897068e1117bb6f221f34aebb50"
                    },
                    "baselineState": "new",
                    "kind": "fail",
                    "level": "error",
                    "locations": [
                        {
                            "id": -1,
                            "physicalLocation": {
                                "artifactLocation": {
                                    "index": -1,
                                    "uri": "requirements.txt"
                                }
                            }
                        }
                    ],
                    "message": {
                        "markdown": "pkg:pypi/flask@0.12.5",
                        "text": "pkg:pypi/flask@0.12.5"
                    },
                    "properties": {
                        "issue_confidence": "HIGH",
                        "issue_severity": "high",
                        "score": "7.5"
                    },
                    "rank": -1,
                    "ruleId": "oss_vuln/e89ac22d6250e43971413f2c7ca25e6c",
                    "ruleIndex": 13
                },
                {
                    "fingerprints": {
                        "evidenceFingerprint": "ab2513877159b1227f8737061783c9d134a09e2290e5c916ee40db5769764449"
                    },
                    "baselineState": "new",
                    "kind": "fail",
                    "level": "error",
                    "locations": [
                        {
                            "id": -1,
                            "physicalLocation": {
                                "artifactLocation": {
                                    "index": -1,
                                    "uri": "requirements.txt"
                                }
                            }
                        }
                    ],
                    "message": {
                        "markdown": "pkg:pypi/jinja2@2.8",
                        "text": "pkg:pypi/jinja2@2.8"
                    },
                    "properties": {
                        "issue_confidence": "HIGH",
                        "issue_severity": "high",
                        "score": "8.6"
                    },
                    "rank": -1,
                    "ruleId": "oss_vuln/a8d4db1b63d85dc3ec67461d3859a81f",
                    "ruleIndex": 14
                },
                {
                    "fingerprints": {
                        "evidenceFingerprint": "d46975c314355d44ef7de4f4cd5f3202f8a33bbbadb7a1d58eeece130132155c"
                    },
                    "baselineState": "new",
                    "kind": "fail",
                    "level": "error",
                    "locations": [
                        {
                            "id": -1,
                            "physicalLocation": {
                                "artifactLocation": {
                                    "index": -1,
                                    "uri": "requirements.txt"
                                }
                            }
                        }
                    ],
                    "message": {
                        "markdown": "pkg:pypi/jinja2@2.8",
                        "text": "pkg:pypi/jinja2@2.8"
                    },
                    "properties": {
                        "issue_confidence": "HIGH",
                        "issue_severity": "high",
                        "score": "8.6"
                    },
                    "rank": -1,
                    "ruleId": "oss_vuln/7682c1db83edf75886167646434131f3",
                    "ruleIndex": 15
                },
                {
                    "fingerprints": {
                        "evidenceFingerprint": "952cd0e03f0b3ce115a4633a768c1230b12aa16e376b934008c9942668dc643e"
                    },
                    "baselineState": "new",
                    "kind": "fail",
                    "level": "warning",
                    "locations": [
                        {
                            "id": -1,
                            "physicalLocation": {
                                "artifactLocation": {
                                    "index": -1,
                                    "uri": "requirements.txt"
                                }
                            }
                        }
                    ],
                    "message": {
                        "markdown": "pkg:pypi/jinja2@2.8",
                        "text": "pkg:pypi/jinja2@2.8"
                    },
                    "properties": {
                        "issue_confidence": "HIGH",
                        "issue_severity": "medium",
                        "score": "5.3"
                    },
                    "rank": -1,
                    "ruleId": "oss_vuln/01f90019862213dbbe74c6eb911b508f",
                    "ruleIndex": 16
                },
                {
                    "fingerprints": {
                        "evidenceFingerprint": "b4a52f4a85e9732bd2638f191661b3802a590bc221c1ef8f6ada8cb730a69176"
                    },
                    "baselineState": "new",
                    "codeFlows": [
                        {
                            "threadFlows": [
                                {
                                    "locations": [
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/auth.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 1
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/auth.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 33
                                                    }
                                                }
                                            }
                                        },
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/auth.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 46
                                                    }
                                                }
                                            }
                                        }
                                    ]
                                }
                            ]
                        }
                    ],
                    "kind": "fail",
                    "level": "warning",
                    "locations": [
                        {
                            "id": -1,
                            "physicalLocation": {
                                "artifactLocation": {
                                    "index": -1,
                                    "uri": "flask_webgoat/auth.py"
                                },
                                "region": {
                                    "byteOffset": -1,
                                    "charOffset": -1,
                                    "snippet": {},
                                    "startLine": 46
                                }
                            }
                        }
                    ],
                    "message": {
                        "markdown": "Open Redirect: Attacker-Controlled Data is Used in HTTP Redirects in `auth.py`",
                        "text": "Open Redirect: Attacker-Controlled Data is Used in HTTP Redirects in auth.py"
                    },
                    "properties": {
                        "issue_confidence": "HIGH",
                        "issue_severity": "medium",
                        "score": "4"
                    },
                    "rank": -1,
                    "ruleId": "open-redirect/1c93408c9984ae6d7ea9bdc09ae65957",
                    "ruleIndex": 17
                },
                {
                    "fingerprints": {
                        "evidenceFingerprint": "37b12fdf4b70fb9765bdf17c7eb367711858ab5c4914dfdd9851b3facaef1833"
                    },
                    "baselineState": "new",
                    "codeFlows": [
                        {
                            "threadFlows": [
                                {
                                    "locations": [
                                        {
                                            "executionOrder": -1,
                                            "importance": "important",
                                            "index": -1,
                                            "location": {
                                                "id": -1,
                                                "physicalLocation": {
                                                    "artifactLocation": {
                                                        "index": -1,
                                                        "uri": "flask_webgoat/auth.py"
                                                    },
                                                    "region": {
                                                        "byteOffset": -1,
                                                        "charOffset": -1,
                                                        "snippet": {
                                                            "text": ""
                                                        },
                                                        "startLine": 46
                                                    }
                                                }
                                            }
                                        }
                                    ]
                                }
                            ]
                        }
                    ],
                    "kind": "fail",
                    "level": "warning",
                    "locations": [
                        {
                            "id": -1,
                            "physicalLocation": {
                                "artifactLocation": {
                                    "index": -1,
                                    "uri": "flask_webgoat/auth.py"
                                },
                                "region": {
                                    "byteOffset": -1,
                                    "charOffset": -1,
                                    "snippet": {},
                                    "startLine": 46
                                }
                            }
                        }
                    ],
                    "message": {
                        "markdown": "Open Redirect: Non-Constant URL Target of HTTP Redirect in `login_and_redirect`",
                        "text": "Open Redirect: Non-Constant URL Target of HTTP Redirect in login_and_redirect"
                    },
                    "properties": {
                        "issue_confidence": "HIGH",
                        "issue_severity": "medium",
                        "score": "4"
                    },
                    "rank": -1,
                    "ruleId": "warning-sink-redirect/d8f7e3de405c9f1bc101d75cd92db669",
                    "ruleIndex": 18
                }
            ],
            "tool": {
                "driver": {
                    "contents": [
                        "localizedData",
                        "nonLocalizedData"
                    ],
                    "fullName": "Qwiet preZero",
                    "informationUri": "https://qwiet.ai",
                    "language": "en-US",
                    "name": "Qwiet preZero",
                    "rules": [
                        {
                            "defaultConfiguration": {
                                "enabled": true,
                                "level": "error",
                                "rank": -1
                            },
                            "fullDescription": {
                                "text": "Attacker-controlled data is used in a shell command without undergoing escaping or validation. This indicates a command injection vulnerability."
                            },
                            "help": {
                                "markdown": "Attacker-controlled data is used in a shell command without undergoing escaping or validation. This indicates a command injection vulnerability.\n\n# Remote Code Execution\n\nA **remote code execution** (RCE) vulnerability allows an attacker to execute arbitrary code on you server. On a\nweb-server, RCE vulnerabilities are typically cause when untrusted input from the HTTP request is evaluated as code.\n\n::::tabs\n\n:::tab[Java]\n\n## Remote Code Execution in Java\n\nDynamic evaluation of code in Java can be achieved in a number of ways. The Java scripting API (defined in the\n`javax.script` page) package allows you to evaluate code in a number of different scripting languages via the \n`ScriptEngineManager` class. There are, for instance, JVM compatible versions of Python (called Jython) and Ruby (called\nJRuby) that can be loaded as jars and invoked via the script manager.\n\nThe Java compiler can also be invoked programmatically via the `javax.tools.JavaCompiler` interface. This approach is\noften used by build tools, which convert files on disk to runnable code that can be loaded into the JVM.\n\nFinally, there are a number of other tools that allow dynamic evaluation of code. The Apache Bean Scripting Framework\na range of scripting languages, and the scripting languages like Groovy can be added to the Java runtime by simply\nadding a jar in the classpath.\n\nWith all of these approaches, it is of vital importance that you only pass trusted code to the scripting API. Passing \nuntrusted content to the `ScriptingEngine` class, for instance,  will allow an attacker to execute arbitrary code in \nyour Java Virtual Machine - meaning they can steal sensitive information, read files from disk, or install malware.\n\nTo secure your code, you should ensure any strings passed to a scripting engine are taken from a trusted source, or \nvalidated against an allow-list:\n\n```java\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException \n{\n  String code = request.getParameter(\"script\");\n\n  // Since we are taking the code to execute from an untrusted source (the HTTP\n  // request) we *must* validate against an allowed list of scripts.      \n  if (!allowedCommands.contains(code))\n    throw new IOException(\"Not permitted\");\n\n  ScriptEngineManager manager = new ScriptEngineManager();\n  ScriptEngine        engine  = manager.getEngineByName(\"JavaScript\");\n  engine.eval(input);\n  \n  response.setStatus(200);\n}\n```\n\n## Further Considerations\n\nDynamic code evaluation is often used where there is a need to develop a *Domain Specific Language* (DSL) for expert \nusers. In such a scenario, it is preferable to execute DSL statements in a sandbox with limited permissions. (For\ninstance, you probably want to limit disk and network access if you are simply evaluating mathematical statements.) One\nway to achieve this is by formally defining the grammar of the DSL, and using a tool like Java Compiler Compiler (JavaCC)\nor ANTLR to generate a parser that can evaluate scripts at runtime. Since the grammar specification defines which\nfunctions are executable, you have full control over what the DSL can do.\n\n:::\n\n:::tab[C#]\n\n## Remote Code Execution in C#\n\nC# code can be evaluated dynamically using the Code Document Object Model (CodeDOM) module, defined in the \n`System.CodeDom` namespace. CodeDOM allows for templated code generation and dynamic compilation within the .NET \nruntime.\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your C# runtime -\nmeaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to using the CodeDOM module in applications that face\nthe internet.\n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in .NET, consider using one of\nthe following solutions:\n\n* Microsoft's DSL Tools, that come bundled with Visual Studio and allow the visual creation of DSLs.\n* A scripting language like Lua that can be dynamically loaded and executed within the .NET runtime.\n* ANTLR, a parser generator that can be used to generate and execute sand-boxed languages.\n\n:::\n\n:::tab[JavaScript]\n\n## Remote Code Execution in JavaScript Using Eval\n\nJavaScript makes dynamic evaluation of strings as code very easy by making the `eval(...)` function available. For\ninstance, the following JavaScript code will print \"WARNING\" to the console:\n\n```javascript\n  eval(\"console.log('WARNING')\")\n```\n\nIf an attacker is able to control the input to an `eval(...)` call by passing it in an HTTP request, they can run code\non your server. This will allow them to scan your file system, install a remote shell, and take over your server \ncompletely.\n\n## Other Types of Remote Code Execution in JavaScript\n\nInput strings can also be dynamically evaluated as code in the JavaScript runtime using the `Function(...)` or\n`Script(...)` constructors. There are various subtle ways of doing this, as illustrated by the following code:\n\n```javascript\nconst arbitraryObject = {},\n      a = 'constructor',\n      b = 'constructor',\n      s = 'console.log(\"Hacked!\")';\n\n// This will print the phrase 'Hacked!' to the console.\narbitraryObject[a][b](s)()\n```\n\nThese two lines of code illustrate an RCE vulnerability. Properties can be looked up on a JavaScript object by name, \nand this includes functions. The illustrated exploit gets the constructor function for an arbitrary object, looks up \nrhe constructor function for the constructor (which is actually `Function(...)`), passes it a command string, then \nexecutes that string. \n\nAlthough this example is contrived, it illustrates how any code that has the form:\n\n```javascript\narbitraryObject[parameterA][parameterB](parameterC)()\n```\n\n...enables a remote execution attack if all the parameters can be controlled by an attacker.\n\n## Mitigation\n\n* Don't use the `eval(...)` function in your code. Check your codebase with a linter as part of your build process.\n* Consider disabling use of `eval(...)` in the Node.js runtime by passing the `--disallow-code-generation-from-strings`\n  at startup. (You will have to ensure none of your dependencies use the `eval(...)` function to do this.)\n* Validate all untrusted input with allow-lists: check any input take from the HTTP request is safe before processing \n  it.\n* If you make nested lookups on objects, make assertions about object types when pulling them from another object. If\n  your code finds a function where it expects a string, don't invoke it!\n\n:::\n\n:::tab[Python]\n\n## Remote Code Execution in Python\n\nPython code can be evaluated dynamically using the global `eval(...)` and `exec(...)` functions. The former expects\na string representing a (single) valid Python expression, while the later can execute multiple expressions - making it \nable to create new module, class, and function definitions. Both functions have access to the global and local state\nat the point of invocation.\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your Python runtime -\nmeaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to avoid `eval(...)` and `exec(...)` functions of Python \naltogether. \n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Python, consider using the \n`ast` (*Abstract Syntax Tree*) module, which allows you to parse expressions and evaluate each node atomically. This will\nhelp you \"sandbox\" the functions a user can invoke, removing the risks of arbitrary code execution.\n\nHere's a simple example of a DSL that can evaluate mathematical expressions:\n\n```python\nimport ast, operator, math\n\ndef safe_eval(expression):\n  \"\"\"Evaluate a simple mathematical function by parsing an expression into an\n  abstract syntax tree and safely evaluating each node in turn.\"\"\"\n\n  def find_math_function(x, *args):\n    if x not in [x for x in dir(math) if not \"__\" in x]:\n      raise SyntaxError(f\"Unknown function {x}()\")\n\n    return getattr(math, x)\n\n  binary_operations = {\n    ast.Add:   operator.add,\n    ast.Sub:   operator.sub,\n    ast.Mult:  operator.mul,\n    ast.Div:   operator.truediv,\n    ast.Mod:   operator.mod,\n    ast.Pow:   operator.pow,\n    ast.Call:  find_math_function,\n    ast.BinOp: ast.BinOp,\n  }\n\n  unary_operations = {\n    ast.USub:    operator.neg,\n    ast.UAdd:    operator.pos,\n    ast.UnaryOp: ast.UnaryOp,\n  }\n\n  operations = tuple(binary_operations) + tuple(unary_operations)\n\n  syntax_tree = ast.parse(expression, mode='eval')\n\n  def _eval(node):\n    if isinstance(node, ast.Expression):\n      return _eval(node.body)\n    elif isinstance(node, ast.Str):\n      return node.s\n    elif isinstance(node, ast.Num):\n      return node.value\n    elif isinstance(node, ast.Constant):\n      return node.value\n    elif isinstance(node, ast.BinOp):\n      if isinstance(node.left, operations):\n        left = _eval(node.left)\n      else:\n        left = node.left.value\n      if isinstance(node.right, operations):\n        right = _eval(node.right)\n      else:\n        right = node.right.value\n      return binary_operations[type(node.op)](left, right)\n    elif isinstance(node, ast.UnaryOp):\n      if isinstance(node.operand, operations):\n        operand = _eval(node.operand)\n      else:\n        operand = node.operand.value\n      return unary_operations[type(node.op)](operand)\n    elif isinstance(node, ast.Call):\n      args = [_eval(x) for x in node.args]\n      function = find_math_function(node.func.id)\n      return function(*args)\n    else:\n      raise SyntaxError(f\"Bad syntax, {type(node)}\")\n\n  return _eval(syntax_tree)\n\nsafe_eval(\"1 + 1\")       # Will return 2\nsafe_eval(\"(100*10)+6\")  # Will return 1006\nsafe_eval(\"sqrt(16)+1\")  # Will return 5.0\n```\n\n:::\n\n:::tab[Scala]\n\n## Remote Code Execution in Scala\n\nScala code can be evaluated dynamically using the `scala-lang` package, that will generate bytecode objects to be loaded \ninto the underlying Java Virtual Machine. The following web-application takes a scriptlet from an HTTP parameter and\nevaluates the result:\n\n```scala\ncase class Scriptlet(code: String)\n\ndef scriptExecutionForm = Form(\n  mapping(\n    \"code\" -> text\n  )(Scriptlet.apply)(Scriptlet.unapply)\n)\n\ndef evaluateScript = Action(parse.form(scriptExecutionForm)) { request =>\n  val settings = new Settings\n\n  settings.usejavacp.value   = true\n  settings.deprecation.value = true\n\n  val eval      = new IMain(settings)\n  val evaluated = eval.interpret(request.body.code)\n\n  if (evaluated == Success) {\n    val result = eval.valueOfTerm(\"result\").get.asInstanceOf[String]\n    Ok(result)\n  }\n  else {\n    Status(488)(\"Unable to evaluate this code\")\n  }\n}\n```\n\nAnother common method of achieving dynamic execution in Scala is by using reflection:\n\n```scala\nimport scala.reflect.runtime.universe\nimport scala.tools.reflect.ToolBox\n\nval toolbox = universe.runtimeMirror(getClass.getClassLoader).mkToolBox()\ntoolbox.eval(toolbox.parse(\"\"\"println(\"Hello world\")\"\"\"))\n```\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your Java Virtual \nMachine - meaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to avoid using dynamic evaluation of Scala altogether. \n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Scala, consider using a\ntoolkit like the Scala Standard Parser Combinator Library, which allows you to write parsers that will \"sandbox\" the \nfunctions a user can invoke, removing the risks of arbitrary code execution.\n\nThe `math-expression-parser` library is good example of a well-scoped DSL that allows evaluation of simple arithmetic\nexpressions:\n\n```scala\nimport io.github.facaiy.math.expression.MathExp\n\nval expressionString = \"1.0 + sqrt(2 * $a1) + $a2 ** 2\"\nval parsedExpression = MathExp.parse(expressionString)\nval inputVariables   = Map(\"a1\" -> 2, \"a2\" -> 1)\n\n// This will return the value \"4.0\", by evaluating the expression with the supplied input variables.\nval output = parsedExpression.eval(inputVariables)\n```\n\n:::\n\n:::tab[Go]\n\n## Remote Code Execution in Go\n\nDynamic execution of Go is relatively rare. The Go playground (https://go.dev/play/) allows you to run Go code from a\nweb browser, and achieves this by dynamically compiling code using the Go toolchain, and executing the compiled code in\na sandbox on a remote server.\n\nMore common is the use of packages like `net/rpc` or `grpc` to allow remote invocation of individual methods across a \nnetwork. This allows a development team to build efficient, distributed micro-services.\n\nTo mitigate remote code execution attacks in a distributed computing environment, you must ensure any procedure calls \ncome from a trusted source. With `grpc` this can be achieved using Application Layer Transport Security (ALTS), a mutual \nauthentication and transport developed by Google:\n\n```go\nimport (\n  \"google.golang.org/grpc\"\n  \"google.golang.org/grpc/credentials/alts\"\n)\n\naltsTC          := alts.NewClientCreds(alts.DefaultClientOptions())\nconnection, err := grpc.Dial(serverAddr, grpc.WithTransportCredentials(altsTC))\n```\n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Go, consider using an \nembeddable scripting language like Lua:\n\n```go\nimport (\n  \"github.com/yuin/gopher-lua\"\n)\n\nfunc main() {\n  // Instantiate a Lua sandbox.\n  sandbox := lua.NewState()\n  \n  defer sandbox.Close()\n  \n  // Dynamically execute a string as Lua code.\n  if err := sandbox.DoString(`print(\"hello\")`); err != nil {\n    panic(err)\n  }\n}\n```\n\nThis example will execute the simple Lua expression `print(\"hello\")`. Using a Lua sandbox in this fashion will allow you \nto execute dynamic expressions passed by a user safely - simply pass the expression to the `sandbox.DoString(...)` \nfunction to execute it. The executed code will *only* be able to access state you pass to the sandbox via the \n`sandbox.SetField(...)` function, closing any security loopholes associated with remote code execution.\n\n:::\n\n:::tab[PHP]\n\n## Remote Code Execution in PHP\n\nPHP provides several functions that allow for the execution of system commands and the evaluation of code dynamically. Some commonly used functions for this purpose include `eval()`, `system()`, `exec()`, `passthru()`, `shell_exec()`, and others.\n\nThis vulnerability arises when developers use these functions without properly validating or sanitizing user inputs. This can allow an attacker to inject and execute arbitrary code on the server.\n\nConsider the following PHP snippet, which takes a script input from an HTTP request and evaluates it:\n\n```php\n<?php\n$script = $_GET['script'];\n\n// Using the eval function directly on unsanitized input poses a severe security risk.\n// An attacker can provide a malicious PHP code as a value for the \"script\" parameter and execute it.\neval($script);\n\necho \"Script executed successfully!\";\n?>\n```\n\nBy visiting a URL like `http://example.com/vulnerable.php?script=system('ls');` an attacker could execute the `ls` command, and with more malicious intent, they can cause significant harm.\n\n## Mitigation\n\nTo secure your code, ensure that strings passed to evaluation or execution functions are from trusted sources, or are validated against an allow-list:\n\n```php\n<?php\n$allowedScripts = ['print_hello' => 'echo \"Hello, World!\";'];\n\n$scriptKey = $_GET['scriptKey'];\n\n// Validate against an allow-list of scripts.\nif (!array_key_exists($scriptKey, $allowedScripts)) {\n    die(\"Not permitted\");\n}\n\neval($allowedScripts[$scriptKey]);\n\necho \"Script executed successfully!\";\n?>\n```\n\n## Further Considerations\n\nDynamic code evaluation in PHP should be used with extreme caution. Whenever possible, avoid using functions like `eval()` altogether. If dynamic functionality is needed, consider more secure alternatives like creating pre-defined safe functions or adopting a Domain-Specific Language (DSL) with strict parsing and validation. Always use PHP's built-in functions to sanitize and validate all user inputs to prevent code injections.\n\n:::\n\n::::\n\n## CWEs\n\n**[CWE-77](https://cwe.mitre.org/data/definitions/77.html)**\n\n**[CWE-78](https://cwe.mitre.org/data/definitions/78.html)**\n\n**[CWE-94](https://cwe.mitre.org/data/definitions/94.html)**\n\n**[CWE-917](https://cwe.mitre.org/data/definitions/917.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**",
                                "text": "Attacker-controlled data is used in a shell command without undergoing escaping or validation. This indicates a command injection vulnerability.\n\n# Remote Code Execution\n\nA **remote code execution** (RCE) vulnerability allows an attacker to execute arbitrary code on you server. On a\nweb-server, RCE vulnerabilities are typically cause when untrusted input from the HTTP request is evaluated as code.\n\n::::tabs\n\n:::tab[Java]\n\n## Remote Code Execution in Java\n\nDynamic evaluation of code in Java can be achieved in a number of ways. The Java scripting API (defined in the\n`javax.script` page) package allows you to evaluate code in a number of different scripting languages via the \n`ScriptEngineManager` class. There are, for instance, JVM compatible versions of Python (called Jython) and Ruby (called\nJRuby) that can be loaded as jars and invoked via the script manager.\n\nThe Java compiler can also be invoked programmatically via the `javax.tools.JavaCompiler` interface. This approach is\noften used by build tools, which convert files on disk to runnable code that can be loaded into the JVM.\n\nFinally, there are a number of other tools that allow dynamic evaluation of code. The Apache Bean Scripting Framework\na range of scripting languages, and the scripting languages like Groovy can be added to the Java runtime by simply\nadding a jar in the classpath.\n\nWith all of these approaches, it is of vital importance that you only pass trusted code to the scripting API. Passing \nuntrusted content to the `ScriptingEngine` class, for instance,  will allow an attacker to execute arbitrary code in \nyour Java Virtual Machine - meaning they can steal sensitive information, read files from disk, or install malware.\n\nTo secure your code, you should ensure any strings passed to a scripting engine are taken from a trusted source, or \nvalidated against an allow-list:\n\n```java\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException \n{\n  String code = request.getParameter(\"script\");\n\n  // Since we are taking the code to execute from an untrusted source (the HTTP\n  // request) we *must* validate against an allowed list of scripts.      \n  if (!allowedCommands.contains(code))\n    throw new IOException(\"Not permitted\");\n\n  ScriptEngineManager manager = new ScriptEngineManager();\n  ScriptEngine        engine  = manager.getEngineByName(\"JavaScript\");\n  engine.eval(input);\n  \n  response.setStatus(200);\n}\n```\n\n## Further Considerations\n\nDynamic code evaluation is often used where there is a need to develop a *Domain Specific Language* (DSL) for expert \nusers. In such a scenario, it is preferable to execute DSL statements in a sandbox with limited permissions. (For\ninstance, you probably want to limit disk and network access if you are simply evaluating mathematical statements.) One\nway to achieve this is by formally defining the grammar of the DSL, and using a tool like Java Compiler Compiler (JavaCC)\nor ANTLR to generate a parser that can evaluate scripts at runtime. Since the grammar specification defines which\nfunctions are executable, you have full control over what the DSL can do.\n\n:::\n\n:::tab[C#]\n\n## Remote Code Execution in C#\n\nC# code can be evaluated dynamically using the Code Document Object Model (CodeDOM) module, defined in the \n`System.CodeDom` namespace. CodeDOM allows for templated code generation and dynamic compilation within the .NET \nruntime.\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your C# runtime -\nmeaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to using the CodeDOM module in applications that face\nthe internet.\n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in .NET, consider using one of\nthe following solutions:\n\n* Microsoft's DSL Tools, that come bundled with Visual Studio and allow the visual creation of DSLs.\n* A scripting language like Lua that can be dynamically loaded and executed within the .NET runtime.\n* ANTLR, a parser generator that can be used to generate and execute sand-boxed languages.\n\n:::\n\n:::tab[JavaScript]\n\n## Remote Code Execution in JavaScript Using Eval\n\nJavaScript makes dynamic evaluation of strings as code very easy by making the `eval(...)` function available. For\ninstance, the following JavaScript code will print \"WARNING\" to the console:\n\n```javascript\n  eval(\"console.log('WARNING')\")\n```\n\nIf an attacker is able to control the input to an `eval(...)` call by passing it in an HTTP request, they can run code\non your server. This will allow them to scan your file system, install a remote shell, and take over your server \ncompletely.\n\n## Other Types of Remote Code Execution in JavaScript\n\nInput strings can also be dynamically evaluated as code in the JavaScript runtime using the `Function(...)` or\n`Script(...)` constructors. There are various subtle ways of doing this, as illustrated by the following code:\n\n```javascript\nconst arbitraryObject = {},\n      a = 'constructor',\n      b = 'constructor',\n      s = 'console.log(\"Hacked!\")';\n\n// This will print the phrase 'Hacked!' to the console.\narbitraryObject[a][b](s)()\n```\n\nThese two lines of code illustrate an RCE vulnerability. Properties can be looked up on a JavaScript object by name, \nand this includes functions. The illustrated exploit gets the constructor function for an arbitrary object, looks up \nrhe constructor function for the constructor (which is actually `Function(...)`), passes it a command string, then \nexecutes that string. \n\nAlthough this example is contrived, it illustrates how any code that has the form:\n\n```javascript\narbitraryObject[parameterA][parameterB](parameterC)()\n```\n\n...enables a remote execution attack if all the parameters can be controlled by an attacker.\n\n## Mitigation\n\n* Don't use the `eval(...)` function in your code. Check your codebase with a linter as part of your build process.\n* Consider disabling use of `eval(...)` in the Node.js runtime by passing the `--disallow-code-generation-from-strings`\n  at startup. (You will have to ensure none of your dependencies use the `eval(...)` function to do this.)\n* Validate all untrusted input with allow-lists: check any input take from the HTTP request is safe before processing \n  it.\n* If you make nested lookups on objects, make assertions about object types when pulling them from another object. If\n  your code finds a function where it expects a string, don't invoke it!\n\n:::\n\n:::tab[Python]\n\n## Remote Code Execution in Python\n\nPython code can be evaluated dynamically using the global `eval(...)` and `exec(...)` functions. The former expects\na string representing a (single) valid Python expression, while the later can execute multiple expressions - making it \nable to create new module, class, and function definitions. Both functions have access to the global and local state\nat the point of invocation.\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your Python runtime -\nmeaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to avoid `eval(...)` and `exec(...)` functions of Python \naltogether. \n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Python, consider using the \n`ast` (*Abstract Syntax Tree*) module, which allows you to parse expressions and evaluate each node atomically. This will\nhelp you \"sandbox\" the functions a user can invoke, removing the risks of arbitrary code execution.\n\nHere's a simple example of a DSL that can evaluate mathematical expressions:\n\n```python\nimport ast, operator, math\n\ndef safe_eval(expression):\n  \"\"\"Evaluate a simple mathematical function by parsing an expression into an\n  abstract syntax tree and safely evaluating each node in turn.\"\"\"\n\n  def find_math_function(x, *args):\n    if x not in [x for x in dir(math) if not \"__\" in x]:\n      raise SyntaxError(f\"Unknown function {x}()\")\n\n    return getattr(math, x)\n\n  binary_operations = {\n    ast.Add:   operator.add,\n    ast.Sub:   operator.sub,\n    ast.Mult:  operator.mul,\n    ast.Div:   operator.truediv,\n    ast.Mod:   operator.mod,\n    ast.Pow:   operator.pow,\n    ast.Call:  find_math_function,\n    ast.BinOp: ast.BinOp,\n  }\n\n  unary_operations = {\n    ast.USub:    operator.neg,\n    ast.UAdd:    operator.pos,\n    ast.UnaryOp: ast.UnaryOp,\n  }\n\n  operations = tuple(binary_operations) + tuple(unary_operations)\n\n  syntax_tree = ast.parse(expression, mode='eval')\n\n  def _eval(node):\n    if isinstance(node, ast.Expression):\n      return _eval(node.body)\n    elif isinstance(node, ast.Str):\n      return node.s\n    elif isinstance(node, ast.Num):\n      return node.value\n    elif isinstance(node, ast.Constant):\n      return node.value\n    elif isinstance(node, ast.BinOp):\n      if isinstance(node.left, operations):\n        left = _eval(node.left)\n      else:\n        left = node.left.value\n      if isinstance(node.right, operations):\n        right = _eval(node.right)\n      else:\n        right = node.right.value\n      return binary_operations[type(node.op)](left, right)\n    elif isinstance(node, ast.UnaryOp):\n      if isinstance(node.operand, operations):\n        operand = _eval(node.operand)\n      else:\n        operand = node.operand.value\n      return unary_operations[type(node.op)](operand)\n    elif isinstance(node, ast.Call):\n      args = [_eval(x) for x in node.args]\n      function = find_math_function(node.func.id)\n      return function(*args)\n    else:\n      raise SyntaxError(f\"Bad syntax, {type(node)}\")\n\n  return _eval(syntax_tree)\n\nsafe_eval(\"1 + 1\")       # Will return 2\nsafe_eval(\"(100*10)+6\")  # Will return 1006\nsafe_eval(\"sqrt(16)+1\")  # Will return 5.0\n```\n\n:::\n\n:::tab[Scala]\n\n## Remote Code Execution in Scala\n\nScala code can be evaluated dynamically using the `scala-lang` package, that will generate bytecode objects to be loaded \ninto the underlying Java Virtual Machine. The following web-application takes a scriptlet from an HTTP parameter and\nevaluates the result:\n\n```scala\ncase class Scriptlet(code: String)\n\ndef scriptExecutionForm = Form(\n  mapping(\n    \"code\" -> text\n  )(Scriptlet.apply)(Scriptlet.unapply)\n)\n\ndef evaluateScript = Action(parse.form(scriptExecutionForm)) { request =>\n  val settings = new Settings\n\n  settings.usejavacp.value   = true\n  settings.deprecation.value = true\n\n  val eval      = new IMain(settings)\n  val evaluated = eval.interpret(request.body.code)\n\n  if (evaluated == Success) {\n    val result = eval.valueOfTerm(\"result\").get.asInstanceOf[String]\n    Ok(result)\n  }\n  else {\n    Status(488)(\"Unable to evaluate this code\")\n  }\n}\n```\n\nAnother common method of achieving dynamic execution in Scala is by using reflection:\n\n```scala\nimport scala.reflect.runtime.universe\nimport scala.tools.reflect.ToolBox\n\nval toolbox = universe.runtimeMirror(getClass.getClassLoader).mkToolBox()\ntoolbox.eval(toolbox.parse(\"\"\"println(\"Hello world\")\"\"\"))\n```\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your Java Virtual \nMachine - meaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to avoid using dynamic evaluation of Scala altogether. \n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Scala, consider using a\ntoolkit like the Scala Standard Parser Combinator Library, which allows you to write parsers that will \"sandbox\" the \nfunctions a user can invoke, removing the risks of arbitrary code execution.\n\nThe `math-expression-parser` library is good example of a well-scoped DSL that allows evaluation of simple arithmetic\nexpressions:\n\n```scala\nimport io.github.facaiy.math.expression.MathExp\n\nval expressionString = \"1.0 + sqrt(2 * $a1) + $a2 ** 2\"\nval parsedExpression = MathExp.parse(expressionString)\nval inputVariables   = Map(\"a1\" -> 2, \"a2\" -> 1)\n\n// This will return the value \"4.0\", by evaluating the expression with the supplied input variables.\nval output = parsedExpression.eval(inputVariables)\n```\n\n:::\n\n:::tab[Go]\n\n## Remote Code Execution in Go\n\nDynamic execution of Go is relatively rare. The Go playground (https://go.dev/play/) allows you to run Go code from a\nweb browser, and achieves this by dynamically compiling code using the Go toolchain, and executing the compiled code in\na sandbox on a remote server.\n\nMore common is the use of packages like `net/rpc` or `grpc` to allow remote invocation of individual methods across a \nnetwork. This allows a development team to build efficient, distributed micro-services.\n\nTo mitigate remote code execution attacks in a distributed computing environment, you must ensure any procedure calls \ncome from a trusted source. With `grpc` this can be achieved using Application Layer Transport Security (ALTS), a mutual \nauthentication and transport developed by Google:\n\n```go\nimport (\n  \"google.golang.org/grpc\"\n  \"google.golang.org/grpc/credentials/alts\"\n)\n\naltsTC          := alts.NewClientCreds(alts.DefaultClientOptions())\nconnection, err := grpc.Dial(serverAddr, grpc.WithTransportCredentials(altsTC))\n```\n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Go, consider using an \nembeddable scripting language like Lua:\n\n```go\nimport (\n  \"github.com/yuin/gopher-lua\"\n)\n\nfunc main() {\n  // Instantiate a Lua sandbox.\n  sandbox := lua.NewState()\n  \n  defer sandbox.Close()\n  \n  // Dynamically execute a string as Lua code.\n  if err := sandbox.DoString(`print(\"hello\")`); err != nil {\n    panic(err)\n  }\n}\n```\n\nThis example will execute the simple Lua expression `print(\"hello\")`. Using a Lua sandbox in this fashion will allow you \nto execute dynamic expressions passed by a user safely - simply pass the expression to the `sandbox.DoString(...)` \nfunction to execute it. The executed code will *only* be able to access state you pass to the sandbox via the \n`sandbox.SetField(...)` function, closing any security loopholes associated with remote code execution.\n\n:::\n\n:::tab[PHP]\n\n## Remote Code Execution in PHP\n\nPHP provides several functions that allow for the execution of system commands and the evaluation of code dynamically. Some commonly used functions for this purpose include `eval()`, `system()`, `exec()`, `passthru()`, `shell_exec()`, and others.\n\nThis vulnerability arises when developers use these functions without properly validating or sanitizing user inputs. This can allow an attacker to inject and execute arbitrary code on the server.\n\nConsider the following PHP snippet, which takes a script input from an HTTP request and evaluates it:\n\n```php\n<?php\n$script = $_GET['script'];\n\n// Using the eval function directly on unsanitized input poses a severe security risk.\n// An attacker can provide a malicious PHP code as a value for the \"script\" parameter and execute it.\neval($script);\n\necho \"Script executed successfully!\";\n?>\n```\n\nBy visiting a URL like `http://example.com/vulnerable.php?script=system('ls');` an attacker could execute the `ls` command, and with more malicious intent, they can cause significant harm.\n\n## Mitigation\n\nTo secure your code, ensure that strings passed to evaluation or execution functions are from trusted sources, or are validated against an allow-list:\n\n```php\n<?php\n$allowedScripts = ['print_hello' => 'echo \"Hello, World!\";'];\n\n$scriptKey = $_GET['scriptKey'];\n\n// Validate against an allow-list of scripts.\nif (!array_key_exists($scriptKey, $allowedScripts)) {\n    die(\"Not permitted\");\n}\n\neval($allowedScripts[$scriptKey]);\n\necho \"Script executed successfully!\";\n?>\n```\n\n## Further Considerations\n\nDynamic code evaluation in PHP should be used with extreme caution. Whenever possible, avoid using functions like `eval()` altogether. If dynamic functionality is needed, consider more secure alternatives like creating pre-defined safe functions or adopting a Domain-Specific Language (DSL) with strict parsing and validation. Always use PHP's built-in functions to sanitize and validate all user inputs to prevent code injections.\n\n:::\n\n::::\n\n## CWEs\n\n**[CWE-77](https://cwe.mitre.org/data/definitions/77.html)**\n\n**[CWE-78](https://cwe.mitre.org/data/definitions/78.html)**\n\n**[CWE-94](https://cwe.mitre.org/data/definitions/94.html)**\n\n**[CWE-917](https://cwe.mitre.org/data/definitions/917.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**"
                            },
                            "helpUri": "https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection",
                            "id": "command-injection-attacker-controlled/bac5e23fada9210865f45fe67852cf62",
                            "name": "Remote Code Execution: Command Injection Through Attacker-Controlled Data In Actions.py",
                            "properties": {
                                "precision": "very-high",
                                "security-severity": "9",
                                "tags": [
                                    "ng-sast",
                                    "CVSS 9",
                                    "CWE 77",
                                    "CWE 78",
                                    "CWE 917",
                                    "CWE 94",
                                    "OWASP 2021 a03-injection",
                                    "OWASP a03-2021-injection",
                                    "OWASP a1-injection",
                                    "Remote Code Execution"
                                ]
                            },
                            "shortDescription": {
                                "text": "Remote Code Execution: Command Injection Through Attacker-controlled Data in actions.py"
                            }
                        },
                        {
                            "defaultConfiguration": {
                                "enabled": true,
                                "level": "error",
                                "rank": -1
                            },
                            "fullDescription": {
                                "text": "Attacker controlled data is used in a SQL query without undergoing escaping or validation. This indicates a SQL injection vulnerability."
                            },
                            "help": {
                                "markdown": "Attacker controlled data is used in a SQL query without undergoing escaping or validation. This indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**",
                                "text": "Attacker controlled data is used in a SQL query without undergoing escaping or validation. This indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**"
                            },
                            "helpUri": "https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection",
                            "id": "sql-injection-attacker-controlled/88118c7440143dbf876a6c4318d703ad",
                            "name": "Sql Injection: Attacker-Controlled Data Used In Sql Query In Auth.py",
                            "properties": {
                                "precision": "very-high",
                                "security-severity": "9",
                                "tags": [
                                    "ng-sast",
                                    "CVSS 9",
                                    "CWE 89",
                                    "OWASP 2021 a03-injection",
                                    "OWASP a03-2021-injection",
                                    "OWASP a1-injection",
                                    "SQL Injection"
                                ]
                            },
                            "shortDescription": {
                                "text": "SQL Injection: Attacker-controlled Data Used in SQL Query in auth.py"
                            }
                        },
                        {
                            "defaultConfiguration": {
                                "enabled": true,
                                "level": "error",
                                "rank": -1
                            },
                            "fullDescription": {
                                "text": "The shell command executed here is not a string literal. When unescaped attacker-controlled inputs are used as part of the command this indicates a command injection vulnerability."
                            },
                            "help": {
                                "markdown": "The shell command executed here is not a string literal. When unescaped attacker-controlled inputs are used as part of the command this indicates a command injection vulnerability.\n\n# Remote Code Execution\n\nA **remote code execution** (RCE) vulnerability allows an attacker to execute arbitrary code on you server. On a\nweb-server, RCE vulnerabilities are typically cause when untrusted input from the HTTP request is evaluated as code.\n\n::::tabs\n\n:::tab[Java]\n\n## Remote Code Execution in Java\n\nDynamic evaluation of code in Java can be achieved in a number of ways. The Java scripting API (defined in the\n`javax.script` page) package allows you to evaluate code in a number of different scripting languages via the \n`ScriptEngineManager` class. There are, for instance, JVM compatible versions of Python (called Jython) and Ruby (called\nJRuby) that can be loaded as jars and invoked via the script manager.\n\nThe Java compiler can also be invoked programmatically via the `javax.tools.JavaCompiler` interface. This approach is\noften used by build tools, which convert files on disk to runnable code that can be loaded into the JVM.\n\nFinally, there are a number of other tools that allow dynamic evaluation of code. The Apache Bean Scripting Framework\na range of scripting languages, and the scripting languages like Groovy can be added to the Java runtime by simply\nadding a jar in the classpath.\n\nWith all of these approaches, it is of vital importance that you only pass trusted code to the scripting API. Passing \nuntrusted content to the `ScriptingEngine` class, for instance,  will allow an attacker to execute arbitrary code in \nyour Java Virtual Machine - meaning they can steal sensitive information, read files from disk, or install malware.\n\nTo secure your code, you should ensure any strings passed to a scripting engine are taken from a trusted source, or \nvalidated against an allow-list:\n\n```java\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException \n{\n  String code = request.getParameter(\"script\");\n\n  // Since we are taking the code to execute from an untrusted source (the HTTP\n  // request) we *must* validate against an allowed list of scripts.      \n  if (!allowedCommands.contains(code))\n    throw new IOException(\"Not permitted\");\n\n  ScriptEngineManager manager = new ScriptEngineManager();\n  ScriptEngine        engine  = manager.getEngineByName(\"JavaScript\");\n  engine.eval(input);\n  \n  response.setStatus(200);\n}\n```\n\n## Further Considerations\n\nDynamic code evaluation is often used where there is a need to develop a *Domain Specific Language* (DSL) for expert \nusers. In such a scenario, it is preferable to execute DSL statements in a sandbox with limited permissions. (For\ninstance, you probably want to limit disk and network access if you are simply evaluating mathematical statements.) One\nway to achieve this is by formally defining the grammar of the DSL, and using a tool like Java Compiler Compiler (JavaCC)\nor ANTLR to generate a parser that can evaluate scripts at runtime. Since the grammar specification defines which\nfunctions are executable, you have full control over what the DSL can do.\n\n:::\n\n:::tab[C#]\n\n## Remote Code Execution in C#\n\nC# code can be evaluated dynamically using the Code Document Object Model (CodeDOM) module, defined in the \n`System.CodeDom` namespace. CodeDOM allows for templated code generation and dynamic compilation within the .NET \nruntime.\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your C# runtime -\nmeaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to using the CodeDOM module in applications that face\nthe internet.\n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in .NET, consider using one of\nthe following solutions:\n\n* Microsoft's DSL Tools, that come bundled with Visual Studio and allow the visual creation of DSLs.\n* A scripting language like Lua that can be dynamically loaded and executed within the .NET runtime.\n* ANTLR, a parser generator that can be used to generate and execute sand-boxed languages.\n\n:::\n\n:::tab[JavaScript]\n\n## Remote Code Execution in JavaScript Using Eval\n\nJavaScript makes dynamic evaluation of strings as code very easy by making the `eval(...)` function available. For\ninstance, the following JavaScript code will print \"WARNING\" to the console:\n\n```javascript\n  eval(\"console.log('WARNING')\")\n```\n\nIf an attacker is able to control the input to an `eval(...)` call by passing it in an HTTP request, they can run code\non your server. This will allow them to scan your file system, install a remote shell, and take over your server \ncompletely.\n\n## Other Types of Remote Code Execution in JavaScript\n\nInput strings can also be dynamically evaluated as code in the JavaScript runtime using the `Function(...)` or\n`Script(...)` constructors. There are various subtle ways of doing this, as illustrated by the following code:\n\n```javascript\nconst arbitraryObject = {},\n      a = 'constructor',\n      b = 'constructor',\n      s = 'console.log(\"Hacked!\")';\n\n// This will print the phrase 'Hacked!' to the console.\narbitraryObject[a][b](s)()\n```\n\nThese two lines of code illustrate an RCE vulnerability. Properties can be looked up on a JavaScript object by name, \nand this includes functions. The illustrated exploit gets the constructor function for an arbitrary object, looks up \nrhe constructor function for the constructor (which is actually `Function(...)`), passes it a command string, then \nexecutes that string. \n\nAlthough this example is contrived, it illustrates how any code that has the form:\n\n```javascript\narbitraryObject[parameterA][parameterB](parameterC)()\n```\n\n...enables a remote execution attack if all the parameters can be controlled by an attacker.\n\n## Mitigation\n\n* Don't use the `eval(...)` function in your code. Check your codebase with a linter as part of your build process.\n* Consider disabling use of `eval(...)` in the Node.js runtime by passing the `--disallow-code-generation-from-strings`\n  at startup. (You will have to ensure none of your dependencies use the `eval(...)` function to do this.)\n* Validate all untrusted input with allow-lists: check any input take from the HTTP request is safe before processing \n  it.\n* If you make nested lookups on objects, make assertions about object types when pulling them from another object. If\n  your code finds a function where it expects a string, don't invoke it!\n\n:::\n\n:::tab[Python]\n\n## Remote Code Execution in Python\n\nPython code can be evaluated dynamically using the global `eval(...)` and `exec(...)` functions. The former expects\na string representing a (single) valid Python expression, while the later can execute multiple expressions - making it \nable to create new module, class, and function definitions. Both functions have access to the global and local state\nat the point of invocation.\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your Python runtime -\nmeaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to avoid `eval(...)` and `exec(...)` functions of Python \naltogether. \n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Python, consider using the \n`ast` (*Abstract Syntax Tree*) module, which allows you to parse expressions and evaluate each node atomically. This will\nhelp you \"sandbox\" the functions a user can invoke, removing the risks of arbitrary code execution.\n\nHere's a simple example of a DSL that can evaluate mathematical expressions:\n\n```python\nimport ast, operator, math\n\ndef safe_eval(expression):\n  \"\"\"Evaluate a simple mathematical function by parsing an expression into an\n  abstract syntax tree and safely evaluating each node in turn.\"\"\"\n\n  def find_math_function(x, *args):\n    if x not in [x for x in dir(math) if not \"__\" in x]:\n      raise SyntaxError(f\"Unknown function {x}()\")\n\n    return getattr(math, x)\n\n  binary_operations = {\n    ast.Add:   operator.add,\n    ast.Sub:   operator.sub,\n    ast.Mult:  operator.mul,\n    ast.Div:   operator.truediv,\n    ast.Mod:   operator.mod,\n    ast.Pow:   operator.pow,\n    ast.Call:  find_math_function,\n    ast.BinOp: ast.BinOp,\n  }\n\n  unary_operations = {\n    ast.USub:    operator.neg,\n    ast.UAdd:    operator.pos,\n    ast.UnaryOp: ast.UnaryOp,\n  }\n\n  operations = tuple(binary_operations) + tuple(unary_operations)\n\n  syntax_tree = ast.parse(expression, mode='eval')\n\n  def _eval(node):\n    if isinstance(node, ast.Expression):\n      return _eval(node.body)\n    elif isinstance(node, ast.Str):\n      return node.s\n    elif isinstance(node, ast.Num):\n      return node.value\n    elif isinstance(node, ast.Constant):\n      return node.value\n    elif isinstance(node, ast.BinOp):\n      if isinstance(node.left, operations):\n        left = _eval(node.left)\n      else:\n        left = node.left.value\n      if isinstance(node.right, operations):\n        right = _eval(node.right)\n      else:\n        right = node.right.value\n      return binary_operations[type(node.op)](left, right)\n    elif isinstance(node, ast.UnaryOp):\n      if isinstance(node.operand, operations):\n        operand = _eval(node.operand)\n      else:\n        operand = node.operand.value\n      return unary_operations[type(node.op)](operand)\n    elif isinstance(node, ast.Call):\n      args = [_eval(x) for x in node.args]\n      function = find_math_function(node.func.id)\n      return function(*args)\n    else:\n      raise SyntaxError(f\"Bad syntax, {type(node)}\")\n\n  return _eval(syntax_tree)\n\nsafe_eval(\"1 + 1\")       # Will return 2\nsafe_eval(\"(100*10)+6\")  # Will return 1006\nsafe_eval(\"sqrt(16)+1\")  # Will return 5.0\n```\n\n:::\n\n:::tab[Scala]\n\n## Remote Code Execution in Scala\n\nScala code can be evaluated dynamically using the `scala-lang` package, that will generate bytecode objects to be loaded \ninto the underlying Java Virtual Machine. The following web-application takes a scriptlet from an HTTP parameter and\nevaluates the result:\n\n```scala\ncase class Scriptlet(code: String)\n\ndef scriptExecutionForm = Form(\n  mapping(\n    \"code\" -> text\n  )(Scriptlet.apply)(Scriptlet.unapply)\n)\n\ndef evaluateScript = Action(parse.form(scriptExecutionForm)) { request =>\n  val settings = new Settings\n\n  settings.usejavacp.value   = true\n  settings.deprecation.value = true\n\n  val eval      = new IMain(settings)\n  val evaluated = eval.interpret(request.body.code)\n\n  if (evaluated == Success) {\n    val result = eval.valueOfTerm(\"result\").get.asInstanceOf[String]\n    Ok(result)\n  }\n  else {\n    Status(488)(\"Unable to evaluate this code\")\n  }\n}\n```\n\nAnother common method of achieving dynamic execution in Scala is by using reflection:\n\n```scala\nimport scala.reflect.runtime.universe\nimport scala.tools.reflect.ToolBox\n\nval toolbox = universe.runtimeMirror(getClass.getClassLoader).mkToolBox()\ntoolbox.eval(toolbox.parse(\"\"\"println(\"Hello world\")\"\"\"))\n```\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your Java Virtual \nMachine - meaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to avoid using dynamic evaluation of Scala altogether. \n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Scala, consider using a\ntoolkit like the Scala Standard Parser Combinator Library, which allows you to write parsers that will \"sandbox\" the \nfunctions a user can invoke, removing the risks of arbitrary code execution.\n\nThe `math-expression-parser` library is good example of a well-scoped DSL that allows evaluation of simple arithmetic\nexpressions:\n\n```scala\nimport io.github.facaiy.math.expression.MathExp\n\nval expressionString = \"1.0 + sqrt(2 * $a1) + $a2 ** 2\"\nval parsedExpression = MathExp.parse(expressionString)\nval inputVariables   = Map(\"a1\" -> 2, \"a2\" -> 1)\n\n// This will return the value \"4.0\", by evaluating the expression with the supplied input variables.\nval output = parsedExpression.eval(inputVariables)\n```\n\n:::\n\n:::tab[Go]\n\n## Remote Code Execution in Go\n\nDynamic execution of Go is relatively rare. The Go playground (https://go.dev/play/) allows you to run Go code from a\nweb browser, and achieves this by dynamically compiling code using the Go toolchain, and executing the compiled code in\na sandbox on a remote server.\n\nMore common is the use of packages like `net/rpc` or `grpc` to allow remote invocation of individual methods across a \nnetwork. This allows a development team to build efficient, distributed micro-services.\n\nTo mitigate remote code execution attacks in a distributed computing environment, you must ensure any procedure calls \ncome from a trusted source. With `grpc` this can be achieved using Application Layer Transport Security (ALTS), a mutual \nauthentication and transport developed by Google:\n\n```go\nimport (\n  \"google.golang.org/grpc\"\n  \"google.golang.org/grpc/credentials/alts\"\n)\n\naltsTC          := alts.NewClientCreds(alts.DefaultClientOptions())\nconnection, err := grpc.Dial(serverAddr, grpc.WithTransportCredentials(altsTC))\n```\n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Go, consider using an \nembeddable scripting language like Lua:\n\n```go\nimport (\n  \"github.com/yuin/gopher-lua\"\n)\n\nfunc main() {\n  // Instantiate a Lua sandbox.\n  sandbox := lua.NewState()\n  \n  defer sandbox.Close()\n  \n  // Dynamically execute a string as Lua code.\n  if err := sandbox.DoString(`print(\"hello\")`); err != nil {\n    panic(err)\n  }\n}\n```\n\nThis example will execute the simple Lua expression `print(\"hello\")`. Using a Lua sandbox in this fashion will allow you \nto execute dynamic expressions passed by a user safely - simply pass the expression to the `sandbox.DoString(...)` \nfunction to execute it. The executed code will *only* be able to access state you pass to the sandbox via the \n`sandbox.SetField(...)` function, closing any security loopholes associated with remote code execution.\n\n:::\n\n:::tab[PHP]\n\n## Remote Code Execution in PHP\n\nPHP provides several functions that allow for the execution of system commands and the evaluation of code dynamically. Some commonly used functions for this purpose include `eval()`, `system()`, `exec()`, `passthru()`, `shell_exec()`, and others.\n\nThis vulnerability arises when developers use these functions without properly validating or sanitizing user inputs. This can allow an attacker to inject and execute arbitrary code on the server.\n\nConsider the following PHP snippet, which takes a script input from an HTTP request and evaluates it:\n\n```php\n<?php\n$script = $_GET['script'];\n\n// Using the eval function directly on unsanitized input poses a severe security risk.\n// An attacker can provide a malicious PHP code as a value for the \"script\" parameter and execute it.\neval($script);\n\necho \"Script executed successfully!\";\n?>\n```\n\nBy visiting a URL like `http://example.com/vulnerable.php?script=system('ls');` an attacker could execute the `ls` command, and with more malicious intent, they can cause significant harm.\n\n## Mitigation\n\nTo secure your code, ensure that strings passed to evaluation or execution functions are from trusted sources, or are validated against an allow-list:\n\n```php\n<?php\n$allowedScripts = ['print_hello' => 'echo \"Hello, World!\";'];\n\n$scriptKey = $_GET['scriptKey'];\n\n// Validate against an allow-list of scripts.\nif (!array_key_exists($scriptKey, $allowedScripts)) {\n    die(\"Not permitted\");\n}\n\neval($allowedScripts[$scriptKey]);\n\necho \"Script executed successfully!\";\n?>\n```\n\n## Further Considerations\n\nDynamic code evaluation in PHP should be used with extreme caution. Whenever possible, avoid using functions like `eval()` altogether. If dynamic functionality is needed, consider more secure alternatives like creating pre-defined safe functions or adopting a Domain-Specific Language (DSL) with strict parsing and validation. Always use PHP's built-in functions to sanitize and validate all user inputs to prevent code injections.\n\n:::\n\n::::\n\n## CWEs\n\n**[CWE-77](https://cwe.mitre.org/data/definitions/77.html)**\n\n**[CWE-78](https://cwe.mitre.org/data/definitions/78.html)**\n\n**[CWE-94](https://cwe.mitre.org/data/definitions/94.html)**\n\n**[CWE-917](https://cwe.mitre.org/data/definitions/917.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**",
                                "text": "The shell command executed here is not a string literal. When unescaped attacker-controlled inputs are used as part of the command this indicates a command injection vulnerability.\n\n# Remote Code Execution\n\nA **remote code execution** (RCE) vulnerability allows an attacker to execute arbitrary code on you server. On a\nweb-server, RCE vulnerabilities are typically cause when untrusted input from the HTTP request is evaluated as code.\n\n::::tabs\n\n:::tab[Java]\n\n## Remote Code Execution in Java\n\nDynamic evaluation of code in Java can be achieved in a number of ways. The Java scripting API (defined in the\n`javax.script` page) package allows you to evaluate code in a number of different scripting languages via the \n`ScriptEngineManager` class. There are, for instance, JVM compatible versions of Python (called Jython) and Ruby (called\nJRuby) that can be loaded as jars and invoked via the script manager.\n\nThe Java compiler can also be invoked programmatically via the `javax.tools.JavaCompiler` interface. This approach is\noften used by build tools, which convert files on disk to runnable code that can be loaded into the JVM.\n\nFinally, there are a number of other tools that allow dynamic evaluation of code. The Apache Bean Scripting Framework\na range of scripting languages, and the scripting languages like Groovy can be added to the Java runtime by simply\nadding a jar in the classpath.\n\nWith all of these approaches, it is of vital importance that you only pass trusted code to the scripting API. Passing \nuntrusted content to the `ScriptingEngine` class, for instance,  will allow an attacker to execute arbitrary code in \nyour Java Virtual Machine - meaning they can steal sensitive information, read files from disk, or install malware.\n\nTo secure your code, you should ensure any strings passed to a scripting engine are taken from a trusted source, or \nvalidated against an allow-list:\n\n```java\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException \n{\n  String code = request.getParameter(\"script\");\n\n  // Since we are taking the code to execute from an untrusted source (the HTTP\n  // request) we *must* validate against an allowed list of scripts.      \n  if (!allowedCommands.contains(code))\n    throw new IOException(\"Not permitted\");\n\n  ScriptEngineManager manager = new ScriptEngineManager();\n  ScriptEngine        engine  = manager.getEngineByName(\"JavaScript\");\n  engine.eval(input);\n  \n  response.setStatus(200);\n}\n```\n\n## Further Considerations\n\nDynamic code evaluation is often used where there is a need to develop a *Domain Specific Language* (DSL) for expert \nusers. In such a scenario, it is preferable to execute DSL statements in a sandbox with limited permissions. (For\ninstance, you probably want to limit disk and network access if you are simply evaluating mathematical statements.) One\nway to achieve this is by formally defining the grammar of the DSL, and using a tool like Java Compiler Compiler (JavaCC)\nor ANTLR to generate a parser that can evaluate scripts at runtime. Since the grammar specification defines which\nfunctions are executable, you have full control over what the DSL can do.\n\n:::\n\n:::tab[C#]\n\n## Remote Code Execution in C#\n\nC# code can be evaluated dynamically using the Code Document Object Model (CodeDOM) module, defined in the \n`System.CodeDom` namespace. CodeDOM allows for templated code generation and dynamic compilation within the .NET \nruntime.\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your C# runtime -\nmeaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to using the CodeDOM module in applications that face\nthe internet.\n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in .NET, consider using one of\nthe following solutions:\n\n* Microsoft's DSL Tools, that come bundled with Visual Studio and allow the visual creation of DSLs.\n* A scripting language like Lua that can be dynamically loaded and executed within the .NET runtime.\n* ANTLR, a parser generator that can be used to generate and execute sand-boxed languages.\n\n:::\n\n:::tab[JavaScript]\n\n## Remote Code Execution in JavaScript Using Eval\n\nJavaScript makes dynamic evaluation of strings as code very easy by making the `eval(...)` function available. For\ninstance, the following JavaScript code will print \"WARNING\" to the console:\n\n```javascript\n  eval(\"console.log('WARNING')\")\n```\n\nIf an attacker is able to control the input to an `eval(...)` call by passing it in an HTTP request, they can run code\non your server. This will allow them to scan your file system, install a remote shell, and take over your server \ncompletely.\n\n## Other Types of Remote Code Execution in JavaScript\n\nInput strings can also be dynamically evaluated as code in the JavaScript runtime using the `Function(...)` or\n`Script(...)` constructors. There are various subtle ways of doing this, as illustrated by the following code:\n\n```javascript\nconst arbitraryObject = {},\n      a = 'constructor',\n      b = 'constructor',\n      s = 'console.log(\"Hacked!\")';\n\n// This will print the phrase 'Hacked!' to the console.\narbitraryObject[a][b](s)()\n```\n\nThese two lines of code illustrate an RCE vulnerability. Properties can be looked up on a JavaScript object by name, \nand this includes functions. The illustrated exploit gets the constructor function for an arbitrary object, looks up \nrhe constructor function for the constructor (which is actually `Function(...)`), passes it a command string, then \nexecutes that string. \n\nAlthough this example is contrived, it illustrates how any code that has the form:\n\n```javascript\narbitraryObject[parameterA][parameterB](parameterC)()\n```\n\n...enables a remote execution attack if all the parameters can be controlled by an attacker.\n\n## Mitigation\n\n* Don't use the `eval(...)` function in your code. Check your codebase with a linter as part of your build process.\n* Consider disabling use of `eval(...)` in the Node.js runtime by passing the `--disallow-code-generation-from-strings`\n  at startup. (You will have to ensure none of your dependencies use the `eval(...)` function to do this.)\n* Validate all untrusted input with allow-lists: check any input take from the HTTP request is safe before processing \n  it.\n* If you make nested lookups on objects, make assertions about object types when pulling them from another object. If\n  your code finds a function where it expects a string, don't invoke it!\n\n:::\n\n:::tab[Python]\n\n## Remote Code Execution in Python\n\nPython code can be evaluated dynamically using the global `eval(...)` and `exec(...)` functions. The former expects\na string representing a (single) valid Python expression, while the later can execute multiple expressions - making it \nable to create new module, class, and function definitions. Both functions have access to the global and local state\nat the point of invocation.\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your Python runtime -\nmeaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to avoid `eval(...)` and `exec(...)` functions of Python \naltogether. \n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Python, consider using the \n`ast` (*Abstract Syntax Tree*) module, which allows you to parse expressions and evaluate each node atomically. This will\nhelp you \"sandbox\" the functions a user can invoke, removing the risks of arbitrary code execution.\n\nHere's a simple example of a DSL that can evaluate mathematical expressions:\n\n```python\nimport ast, operator, math\n\ndef safe_eval(expression):\n  \"\"\"Evaluate a simple mathematical function by parsing an expression into an\n  abstract syntax tree and safely evaluating each node in turn.\"\"\"\n\n  def find_math_function(x, *args):\n    if x not in [x for x in dir(math) if not \"__\" in x]:\n      raise SyntaxError(f\"Unknown function {x}()\")\n\n    return getattr(math, x)\n\n  binary_operations = {\n    ast.Add:   operator.add,\n    ast.Sub:   operator.sub,\n    ast.Mult:  operator.mul,\n    ast.Div:   operator.truediv,\n    ast.Mod:   operator.mod,\n    ast.Pow:   operator.pow,\n    ast.Call:  find_math_function,\n    ast.BinOp: ast.BinOp,\n  }\n\n  unary_operations = {\n    ast.USub:    operator.neg,\n    ast.UAdd:    operator.pos,\n    ast.UnaryOp: ast.UnaryOp,\n  }\n\n  operations = tuple(binary_operations) + tuple(unary_operations)\n\n  syntax_tree = ast.parse(expression, mode='eval')\n\n  def _eval(node):\n    if isinstance(node, ast.Expression):\n      return _eval(node.body)\n    elif isinstance(node, ast.Str):\n      return node.s\n    elif isinstance(node, ast.Num):\n      return node.value\n    elif isinstance(node, ast.Constant):\n      return node.value\n    elif isinstance(node, ast.BinOp):\n      if isinstance(node.left, operations):\n        left = _eval(node.left)\n      else:\n        left = node.left.value\n      if isinstance(node.right, operations):\n        right = _eval(node.right)\n      else:\n        right = node.right.value\n      return binary_operations[type(node.op)](left, right)\n    elif isinstance(node, ast.UnaryOp):\n      if isinstance(node.operand, operations):\n        operand = _eval(node.operand)\n      else:\n        operand = node.operand.value\n      return unary_operations[type(node.op)](operand)\n    elif isinstance(node, ast.Call):\n      args = [_eval(x) for x in node.args]\n      function = find_math_function(node.func.id)\n      return function(*args)\n    else:\n      raise SyntaxError(f\"Bad syntax, {type(node)}\")\n\n  return _eval(syntax_tree)\n\nsafe_eval(\"1 + 1\")       # Will return 2\nsafe_eval(\"(100*10)+6\")  # Will return 1006\nsafe_eval(\"sqrt(16)+1\")  # Will return 5.0\n```\n\n:::\n\n:::tab[Scala]\n\n## Remote Code Execution in Scala\n\nScala code can be evaluated dynamically using the `scala-lang` package, that will generate bytecode objects to be loaded \ninto the underlying Java Virtual Machine. The following web-application takes a scriptlet from an HTTP parameter and\nevaluates the result:\n\n```scala\ncase class Scriptlet(code: String)\n\ndef scriptExecutionForm = Form(\n  mapping(\n    \"code\" -> text\n  )(Scriptlet.apply)(Scriptlet.unapply)\n)\n\ndef evaluateScript = Action(parse.form(scriptExecutionForm)) { request =>\n  val settings = new Settings\n\n  settings.usejavacp.value   = true\n  settings.deprecation.value = true\n\n  val eval      = new IMain(settings)\n  val evaluated = eval.interpret(request.body.code)\n\n  if (evaluated == Success) {\n    val result = eval.valueOfTerm(\"result\").get.asInstanceOf[String]\n    Ok(result)\n  }\n  else {\n    Status(488)(\"Unable to evaluate this code\")\n  }\n}\n```\n\nAnother common method of achieving dynamic execution in Scala is by using reflection:\n\n```scala\nimport scala.reflect.runtime.universe\nimport scala.tools.reflect.ToolBox\n\nval toolbox = universe.runtimeMirror(getClass.getClassLoader).mkToolBox()\ntoolbox.eval(toolbox.parse(\"\"\"println(\"Hello world\")\"\"\"))\n```\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your Java Virtual \nMachine - meaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to avoid using dynamic evaluation of Scala altogether. \n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Scala, consider using a\ntoolkit like the Scala Standard Parser Combinator Library, which allows you to write parsers that will \"sandbox\" the \nfunctions a user can invoke, removing the risks of arbitrary code execution.\n\nThe `math-expression-parser` library is good example of a well-scoped DSL that allows evaluation of simple arithmetic\nexpressions:\n\n```scala\nimport io.github.facaiy.math.expression.MathExp\n\nval expressionString = \"1.0 + sqrt(2 * $a1) + $a2 ** 2\"\nval parsedExpression = MathExp.parse(expressionString)\nval inputVariables   = Map(\"a1\" -> 2, \"a2\" -> 1)\n\n// This will return the value \"4.0\", by evaluating the expression with the supplied input variables.\nval output = parsedExpression.eval(inputVariables)\n```\n\n:::\n\n:::tab[Go]\n\n## Remote Code Execution in Go\n\nDynamic execution of Go is relatively rare. The Go playground (https://go.dev/play/) allows you to run Go code from a\nweb browser, and achieves this by dynamically compiling code using the Go toolchain, and executing the compiled code in\na sandbox on a remote server.\n\nMore common is the use of packages like `net/rpc` or `grpc` to allow remote invocation of individual methods across a \nnetwork. This allows a development team to build efficient, distributed micro-services.\n\nTo mitigate remote code execution attacks in a distributed computing environment, you must ensure any procedure calls \ncome from a trusted source. With `grpc` this can be achieved using Application Layer Transport Security (ALTS), a mutual \nauthentication and transport developed by Google:\n\n```go\nimport (\n  \"google.golang.org/grpc\"\n  \"google.golang.org/grpc/credentials/alts\"\n)\n\naltsTC          := alts.NewClientCreds(alts.DefaultClientOptions())\nconnection, err := grpc.Dial(serverAddr, grpc.WithTransportCredentials(altsTC))\n```\n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Go, consider using an \nembeddable scripting language like Lua:\n\n```go\nimport (\n  \"github.com/yuin/gopher-lua\"\n)\n\nfunc main() {\n  // Instantiate a Lua sandbox.\n  sandbox := lua.NewState()\n  \n  defer sandbox.Close()\n  \n  // Dynamically execute a string as Lua code.\n  if err := sandbox.DoString(`print(\"hello\")`); err != nil {\n    panic(err)\n  }\n}\n```\n\nThis example will execute the simple Lua expression `print(\"hello\")`. Using a Lua sandbox in this fashion will allow you \nto execute dynamic expressions passed by a user safely - simply pass the expression to the `sandbox.DoString(...)` \nfunction to execute it. The executed code will *only* be able to access state you pass to the sandbox via the \n`sandbox.SetField(...)` function, closing any security loopholes associated with remote code execution.\n\n:::\n\n:::tab[PHP]\n\n## Remote Code Execution in PHP\n\nPHP provides several functions that allow for the execution of system commands and the evaluation of code dynamically. Some commonly used functions for this purpose include `eval()`, `system()`, `exec()`, `passthru()`, `shell_exec()`, and others.\n\nThis vulnerability arises when developers use these functions without properly validating or sanitizing user inputs. This can allow an attacker to inject and execute arbitrary code on the server.\n\nConsider the following PHP snippet, which takes a script input from an HTTP request and evaluates it:\n\n```php\n<?php\n$script = $_GET['script'];\n\n// Using the eval function directly on unsanitized input poses a severe security risk.\n// An attacker can provide a malicious PHP code as a value for the \"script\" parameter and execute it.\neval($script);\n\necho \"Script executed successfully!\";\n?>\n```\n\nBy visiting a URL like `http://example.com/vulnerable.php?script=system('ls');` an attacker could execute the `ls` command, and with more malicious intent, they can cause significant harm.\n\n## Mitigation\n\nTo secure your code, ensure that strings passed to evaluation or execution functions are from trusted sources, or are validated against an allow-list:\n\n```php\n<?php\n$allowedScripts = ['print_hello' => 'echo \"Hello, World!\";'];\n\n$scriptKey = $_GET['scriptKey'];\n\n// Validate against an allow-list of scripts.\nif (!array_key_exists($scriptKey, $allowedScripts)) {\n    die(\"Not permitted\");\n}\n\neval($allowedScripts[$scriptKey]);\n\necho \"Script executed successfully!\";\n?>\n```\n\n## Further Considerations\n\nDynamic code evaluation in PHP should be used with extreme caution. Whenever possible, avoid using functions like `eval()` altogether. If dynamic functionality is needed, consider more secure alternatives like creating pre-defined safe functions or adopting a Domain-Specific Language (DSL) with strict parsing and validation. Always use PHP's built-in functions to sanitize and validate all user inputs to prevent code injections.\n\n:::\n\n::::\n\n## CWEs\n\n**[CWE-77](https://cwe.mitre.org/data/definitions/77.html)**\n\n**[CWE-78](https://cwe.mitre.org/data/definitions/78.html)**\n\n**[CWE-94](https://cwe.mitre.org/data/definitions/94.html)**\n\n**[CWE-917](https://cwe.mitre.org/data/definitions/917.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**"
                            },
                            "helpUri": "https://cwe.mitre.org/data/definitions/78.html",
                            "id": "warning-sink-execute/311beedfa8d03cc4123ae1de94a95257",
                            "name": "Command Injection: Execution Of Non-Constant Shell Commands In Grep_processes",
                            "properties": {
                                "precision": "very-high",
                                "security-severity": "8.5",
                                "tags": [
                                    "ng-sast",
                                    "CVSS 8.5",
                                    "CWE 77",
                                    "CWE 78",
                                    "Command Injection",
                                    "OWASP 2021 a03-injection",
                                    "OWASP a03-2021-injection",
                                    "OWASP a1-injection"
                                ]
                            },
                            "shortDescription": {
                                "text": "Command Injection: Execution of Non-Constant Shell Commands in grep_processes"
                            }
                        },
                        {
                            "defaultConfiguration": {
                                "enabled": true,
                                "level": "note",
                                "rank": -1
                            },
                            "fullDescription": {
                                "text": "A library used in the application is configured to print executed queries to stdout."
                            },
                            "help": {
                                "markdown": "A library used in the application is configured to print executed queries to stdout.\n\n# Sensitive Data Leaks\n\nDisclosing system information helps an adversary learn about your web application and form a plan of attack. You should\ntry to reveal as little about your technology stack and architecture as possible, beyond what is essential for your\nusers to know. Revealing system information makes life easier for an attacker, and gives them a playbook of\nvulnerabilities they can probe for.\n\nHere are some common ways websites leak sensitive data:\n\n* Error conditions that display stack traces or database error messages to the user.\n* Open directory listings that allow exploration of the server's file system.\n* Unsanitized comments in HTML and template files the reveal system details.\n\n::::tabs\n\n:::tab[Java]\n\n## How to Prevent Data Leaks in Java\n\n### Keep Error Reporting on the Server\n\nDisable client-side error reporting in your production environment, by specifying an error page in your `web.xml` file:\n\n```xml\n<error-page>\n  <location>/error.html</location>\n</error-page>\n```\n  \nThis error page should only contain a generic error message (e.g. \"An error occurred\"). Stack traces should be written\nto server-side logs.\n\n### Sanitize Error Messages\n\nMake sure error messages returned from the database or containing system information are logged, but not shown to the\nuser. Here a generic error message is shown to the user, while the detailed error is written to the logs for investigation:\n\n```java\ntry \n{\n    user = getDatabase().findUser(email);\n}\ncatch (SQLException ex) \n{\n    log.error(\"An error occurred looking up the user profiles\", ex):\n    throw new ClientFacingException(\"An unexpected error occurred, please try again later.\");\n}\n```\n\n### Separate Dynamic and Static Resources\n\nEnsure static resources and dynamic content are stored in separate directories, so a malicious user cannot snoop \nthrough your code and configuration files. For example, this is how to tell Java to server static Javascript files\nfrom the `/js` directory:\n  \n```xml\n<servlet-mapping>\n    <servlet-name>default</servlet-name>\n    <url-pattern>/js/*.js</url-pattern>\n</servlet-mapping>\n```\n\n### Disable the \"Server\" Header \n\nConsider disabling the `Server` header and the (non-standard but common) `X-Powered-By` header, and making the session \ncookie name generic. This will give your keep an attacker guessing about what your technology stack is, which makes \nattacking it harder. Here's how to do that in the Jetty web-server:\n  \n```java\nHttpConfiguration.setSendServerVersion(false);\n```\n\n:::\n\n:::tab[C#]\n\n## How to Prevent Data Leaks in C#\n\n### Keep Error Reporting on the Server\n\nDisable client-side error reporting in your production environment. When you create a new ASP.NET application, the \ntemplate will generate a startup class with some configuration logic:\n\n```csharp\n    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n    {\n        if (env.IsDevelopment())\n        {\n            app.UseDeveloperExceptionPage();\n        }\n        else\n        {\n            app.UseExceptionHandler(\"/Home/Error\");\n        }\n    }\n```\n\nThe default error page only contain a generic error message (e.g. \"An error occurred\"), whereas the development-mode\nerror page will log full stack traces.\n\n### Sanitize Error Messages\n\nMake sure error messages returned from the database or containing system information are logged, but not shown to the \nuser. When running in non-development mode the ASP.NET web-server will show a generic error message to the user, while \nthe detailed error is written to the logs for investigation. You can configure the error page that is generated at\n`/Views/Shared/Errors.cs.html`.\n\n### Separate Dynamic and Static Resources\n\nEnsure static resources and dynamic content are stored in separate directories, so a malicious user cannot snoop \nthrough your code and configuration files. An ASP.NET web application can be configured to serve static content under\nthe `wwwroot` directory by adding the following line in the startup configuration:\n\n```csharp\napp.UseStaticFiles();\n```\n\nYou can also add additional static content directories with the following logic:\n\n```csharp\napp.UseStaticFiles(new StaticFileOptions\n{\n    FileProvider = new PhysicalFileProvider(Path.Combine(env.ContentRootPath, \"MyStaticFiles\")),\n    RequestPath = \"/StaticFiles\"\n});\n```\n\n### Disable the \"Server\" Header \n\nConsider disabling the `Server` header and the (non-standard but common) `X-Powered-By` header, and making the session \ncookie name generic. This will give your keep an attacker guessing about what your technology stack is, which makes \nattacking it harder. In ASP.NET, you can programmatically remove it in the following manner:\n\n```csharp\nHttpContext.Current.Response.Headers.Remove(\"Server\");\n```\n\nIf you are deploying to IIS, you can remove the header in your configuration settings:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration>\n    <system.webServer>\n        <security>\n            <requestFiltering removeServerHeader=\"true\" />\n        </security>\n    </system.webServer>\n</configuration>\n```\n\n:::\n\n:::tab[JavaScript]\n\n## How to Prevent Data Leaks in JavaScript\n\n### Keep Error Reporting on the Server\n\nDisable client-side error reporting in your production environment. This Express server will dump stack trace \ninformation only in the `development` environment, and disable it in `production`:\n  \n```javascript\nconst errorhandler = require('errorhandler')\nconst express      = require('express')\n\nconst app = express()\n\napp.use(errorhandler({\n  dumpExceptions : app.get('env') === 'development',\n  showStack      : app.get('env') === 'development'\n}))\n```\n\n### Sanitize Error Messages\n\nMake sure error messages returned from the database are logged, but not shown to the user. Here a generic error \nmessage is shown to the user, while the detailed error is written to the logs for investigation:\n\n```javascript\napp.get('/profile', (request, response) => {\n  db.run('SELECT * FROM USERS WHERE email = ?', [ request.session.user ], (error, user) => {\n    if (error) {\n      log.error(error)\n      response.send('An unexpected error occurred')\n      return\n    }\n\n    response.send(`<p>Your email is ${user.email}</p>`)\n  })\n})\n```\n\n### Separate Dynamic and Static Resources\n\nEnsure static resources and dynamic content are stored in separate directories, so a malicious user cannot snoop \nthrough your code and configuration files. For example, this is how to tell Expression to server static content (like \nclient-side JavaScript and CSS files) from the `/static` directory:\n  \n```javascript\napp.use(express.static(__dirname + '/static'))\n```\n\n### Disable the \"Server\" Header \n\nConsider disabling the `Server` header and the (non-standard but common) `X-Powered-By` header, and making the session \ncookie name generic. This will give your keep an attacker guessing about what your technology stack is, which makes \nattacking it harder. Here's how to do that in Express:\n  \n```javascript\n// Disable the 'X-Powered-By' header.\napp.disable('x-powered-by')\n\nconst cookieParser = require('cookie-parser')\nconst session      = require('express-session')\n\napp.use(cookieParser('secret'))\napp.use(session({\n  cookie : {\n    maxAge   : 60000,\n    httpOnly : true,\n    sameSite : 'strict',\n    secure   : app.get('env') !== 'development'\n  },\n\n  // Make the session cookie name generic.\n  name   : 'session',\n  secret : process.env.SESSION_SECRET || uid.sync(18)\n}))\n```\n\n:::\n\n:::tab[Python]\n\n## How to Prevent Data Leaks in Python\n\n### Keep Error Reporting on the Server\n\nDisable client-side error reporting in your production environment. Observe how the Flask framework uses different error\npages in development and production modes, distinguished by whether the environment variable `FLASK_ENV` is set to\n`development`:\n\n```python\n  @property\n  def debug(self) -> bool:\n     \"\"\"Whether debug mode is enabled. When using ``flask run`` to start\n     the development server, an interactive debugger will be shown for\n     unhandled exceptions, and the server will be reloaded when code\n     changes. This maps to the :data:`DEBUG` config key. This is\n     enabled when :attr:`env` is ``'development'`` and is overridden\n     by the ``FLASK_DEBUG`` environment variable. It may not behave as\n     expected if set in code.\n\n     **Do not enable debug mode when deploying in production.**\"\"\"\n     return self.config[\"DEBUG\"]\n```\n\nThe default error page only contain a generic error message (e.g. \"An error occurred\"), whereas the development-mode\nerror page will log full stack traces, and even allow interactive execution of Python code.\n\n### Sanitize Error Messages\n\nMake sure error messages returned from the database or containing system information are logged, but not shown to the \nuser. When running in non-development mode the Flask web-server will show a generic error message to the user, while \nthe detailed error is written to the logs for investigation:\n\n```python\n  def log_exception(self, exc_info) -> None:\n    \"\"\"Logs an exception.  This is called by :meth:`handle_exception`\n    if debugging is disabled and right before the handler is called.\n    The default implementation logs the exception as error on the\n    :attr:`logger`.\n    \"\"\"\n    self.logger.error(\n        f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n    )\n```\n\n### Separate Dynamic and Static Resources\n\nEnsure static resources and dynamic content are stored in separate directories, so a malicious user cannot snoop \nthrough your code and configuration files. Here's how to specify the directory containing static files (like JavaScript \ncode and images) in the Flask web-server:\n\n```python\nfrom flask import Flask\n\napp = Flask(__name__, static_folder='static')\n```\n\n### Disable the \"Server\" Header \n\nConsider disabling the `Server` header and the (non-standard but common) `X-Powered-By` header, and making the session \ncookie name generic. This will give your keep an attacker guessing about what your technology stack is, which makes \nattacking it harder. In the Gunicorn WSGI container, you can configure this header in your `gunicorn.conf.py` config \nfile:\n\n```python\nimport gunicorn\n\n# Make the server name completely generic.\ngunicorn.SERVER_SOFTWARE = 'Server'\n```\n\n:::\n\n:::tab[Scala]\n\n## How to Prevent Data Leaks in Scala\n\n### Keep Error Reporting on the Server\n\nDisable client-side error reporting in your production environment. Notice how the Play framework uses different error\npages in development and production modes:\n\n```scala\n  /**\n   * Invoked in dev mode when a server error occurs.\n   */\n  protected def onDevServerError(request: RequestHeader, exception: UsefulException): Future[Result] = {\n    Future.successful {\n      implicit val ir: RequestHeader = request\n      InternalServerError(views.html.defaultpages.devError(playEditor, exception))\n    }\n  }\n\n  /**\n   * Invoked in prod mode when a server error occurs.\n   */\n  protected def onProdServerError(request: RequestHeader, exception: UsefulException): Future[Result] =\n    Future.successful {\n      implicit val ir: RequestHeader = request\n      InternalServerError(views.html.defaultpages.error(exception))\n    }\n```\n\nThe default error page only contain a generic error message (e.g. \"An error occurred\"), whereas the development-mode\nerror page will log full stack traces.\n\n### Sanitize Error Messages\n\nMake sure error messages returned from the database or containing system information are logged, but not shown to the \nuser. Here a generic error message is shown to the user, while the detailed error is written to the logs for investigation:\n\n```scala\n  override def onServerError(request: RequestHeader, exception: Throwable): Future[Result] = {\n    try {\n      val usefulException = HttpErrorHandlerExceptions.throwableToUsefulException(sourceMapper, !config.showDevErrors, exception)\n\n      // Write the full error context and stack trace to the log file.\n      logServerError(request, usefulException)\n\n      // Sanitize the error to be displayed to the user, when in production-mode.\n      if (config.showDevErrors) onDevServerError(request, usefulException)\n      else onProdServerError(request, usefulException)\n    } catch {\n      case NonFatal(e) =>\n        logger.error(\"Error while handling error\", e)\n        Future.successful(InternalServerError(fatalErrorMessage(request, e)))\n    }\n  }\n```\n\n### Separate Dynamic and Static Resources\n\nEnsure static resources and dynamic content are stored in separate directories, so a malicious user cannot snoop \nthrough your code and configuration files. In the Play framework, static assets like JavaScript and CSS files are \ntypically kept in a separate `/public` and mapped in the routes file as follows:\n\n```scala\nGET  /assets/*file        controllers.Assets.at(path=\"/public\", file)\n```\n\n### Disable the \"Server\" Header \n\nConsider disabling the `Server` header and the (non-standard but common) `X-Powered-By` header, and making the session \ncookie name generic. This will give your keep an attacker guessing about what your technology stack is, which makes \nattacking it harder. For example, the Akka web-server allows you to disable these headers through configuration options:\n\n```\nakka.http {\n  server {\n    # The default value of the `Server` header to produce if no\n    # explicit `Server`-header was included in a response.\n    # If this value is the empty string and no header was included in\n    # the request, no `Server` header will be rendered at all.\n    server-header = \"\" # akka-http/${akka.http.version}\n  }  \n}\n```\n\n:::\n\n:::tab[Go]\n\n## How to Prevent Data Leaks in Go\n\n### Keep Error Reporting on the Server\n\nDisable client-side error reporting in your production environment. In Go web applications, you typically end up writing\nyour own error pages. Ensure that any pages that handle errors pay use flags to distinguish the environment they are \nexecuting in:\n\n```go\nimport \"flag\"\n\nvar debug = flag.Bool(\"debug\", false, \"Whether to show full error messages on the client\")\n```\n\nA default error page only contain a generic error message (e.g. \"An error occurred\"), whereas the development-mode\nerror page can show more information, like full stack traces.\n\n### Sanitize Error Messages\n\nMake sure error messages returned from the database or containing system information are logged, but not shown to the \nuser. Go functions typically return error codes when then fail, and web handlers will return early when error conditions \noccur. Ensure such code does not leak sensitive system data.\n\n```go\nsession, err := session.Get(request, \"session\")\n\nif err != nil {\n  // The second argument here is returned directly to the client, which leaks information!\n  http.Error(response, err.Error(), http.StatusInternalServerError)\n  return\n}\n```\n\n### Separate Dynamic and Static Resources\n\nEnsure static resources and dynamic content are stored in separate directories, so a malicious user cannot snoop \nthrough your code and configuration files. Here's how to specify the directory containing static files (like JavaScript \ncode and images) in the Gorilla web framework:\n\n```go\nfunc main() {\n  var dir string\n\n  flag.StringVar(&dir, \"dir\", \".\", \"the directory to serve files from. Defaults to the current dir\")\n  flag.Parse()\n  router := mux.NewRouter()\n\n  // This will serve files under http://localhost:8000/static/<filename>\n  router.PathPrefix(\"/static/\").Handler(http.StripPrefix(\"/static/\", http.FileServer(http.Dir(dir))))\n\n  server := &http.Server{\n    Handler: router,\n    Addr:    \"127.0.0.1:8000\"\n  }\n\n  log.Fatal(server.ListenAndServe())\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## How to Prevent Data Leaks in PHP\n\n### Keep Error Reporting on the Server\n\nDisable error reporting to the client in your production environment by setting the `display_errors` directive to `Off` in your `php.ini`:\n\n```ini\ndisplay_errors = Off\n```\n\nYou should instead log the errors for review. Ensure that `log_errors` directive is set to `On`:\n\n```ini\nlog_errors = On\nerror_log = /path/to/php-error.log\n```\n\n### Sanitize Error Messages\n\nAvoid directly echoing out database or system error messages to the user. Instead, present a generic message while logging the exact error for debugging:\n\n```php\ntry \n{\n    $result = $db->query(\"SELECT * FROM users WHERE email = '$email'\");\n}\ncatch (PDOException $e) \n{\n    error_log(\"Database error: \" . $e->getMessage());\n    echo \"An unexpected error occurred, please try again later.\";\n}\n```\n\n### Separate Dynamic and Static Resources\n\nFor websites or web applications using PHP, it's common to store PHP files in one directory and static resources (e.g., images, stylesheets, and JavaScript files) in separate directories. This way, you can use server configurations to ensure direct access to PHP files is restricted.\n\n### Hide PHP Version Information\n\nThe `X-Powered-By` header can give away the PHP version you're running. To hide this:\n\n1. Edit `php.ini` and update:\n\n```ini\nexpose_php = Off\n```\n\nOr, if you're using an `.htaccess` file on an Apache server:\n\n```apache\nHeader unset X-Powered-By\n```\n\n### Be Careful With Comments\n\nAvoid leaving sensitive or internal-only comments in your PHP files. Even if you think they are in a part of the code that doesn't output to the user, mistakes or changes in the codebase could expose them. Always assume that anything in a code file could potentially be exposed.\n\n:::\n\n::::\n\n## Further Considerations\n\n* Ensure any comments in template files don't contain sensitive data! It's easy to leave in notes about server names\n  and addresses that will get passed to the client-side. Attackers know this, and will scan comments in HTML for IP\n  addresses and URLs.\n  \n* Ensure server-side log messages do not contain sensitive information like passwords or credit card numbers - this \n  should mitigate the harm an attacker can do if they manage to steal your server's log files.\n  \n\n## Additional information\n\n**[CWE-200](https://cwe.mitre.org/data/definitions/200.html)**\n\n**[OWASP-A3](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A3-Sensitive_Data_Exposure)**",
                                "text": "A library used in the application is configured to print executed queries to stdout.\n\n# Sensitive Data Leaks\n\nDisclosing system information helps an adversary learn about your web application and form a plan of attack. You should\ntry to reveal as little about your technology stack and architecture as possible, beyond what is essential for your\nusers to know. Revealing system information makes life easier for an attacker, and gives them a playbook of\nvulnerabilities they can probe for.\n\nHere are some common ways websites leak sensitive data:\n\n* Error conditions that display stack traces or database error messages to the user.\n* Open directory listings that allow exploration of the server's file system.\n* Unsanitized comments in HTML and template files the reveal system details.\n\n::::tabs\n\n:::tab[Java]\n\n## How to Prevent Data Leaks in Java\n\n### Keep Error Reporting on the Server\n\nDisable client-side error reporting in your production environment, by specifying an error page in your `web.xml` file:\n\n```xml\n<error-page>\n  <location>/error.html</location>\n</error-page>\n```\n  \nThis error page should only contain a generic error message (e.g. \"An error occurred\"). Stack traces should be written\nto server-side logs.\n\n### Sanitize Error Messages\n\nMake sure error messages returned from the database or containing system information are logged, but not shown to the\nuser. Here a generic error message is shown to the user, while the detailed error is written to the logs for investigation:\n\n```java\ntry \n{\n    user = getDatabase().findUser(email);\n}\ncatch (SQLException ex) \n{\n    log.error(\"An error occurred looking up the user profiles\", ex):\n    throw new ClientFacingException(\"An unexpected error occurred, please try again later.\");\n}\n```\n\n### Separate Dynamic and Static Resources\n\nEnsure static resources and dynamic content are stored in separate directories, so a malicious user cannot snoop \nthrough your code and configuration files. For example, this is how to tell Java to server static Javascript files\nfrom the `/js` directory:\n  \n```xml\n<servlet-mapping>\n    <servlet-name>default</servlet-name>\n    <url-pattern>/js/*.js</url-pattern>\n</servlet-mapping>\n```\n\n### Disable the \"Server\" Header \n\nConsider disabling the `Server` header and the (non-standard but common) `X-Powered-By` header, and making the session \ncookie name generic. This will give your keep an attacker guessing about what your technology stack is, which makes \nattacking it harder. Here's how to do that in the Jetty web-server:\n  \n```java\nHttpConfiguration.setSendServerVersion(false);\n```\n\n:::\n\n:::tab[C#]\n\n## How to Prevent Data Leaks in C#\n\n### Keep Error Reporting on the Server\n\nDisable client-side error reporting in your production environment. When you create a new ASP.NET application, the \ntemplate will generate a startup class with some configuration logic:\n\n```csharp\n    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n    {\n        if (env.IsDevelopment())\n        {\n            app.UseDeveloperExceptionPage();\n        }\n        else\n        {\n            app.UseExceptionHandler(\"/Home/Error\");\n        }\n    }\n```\n\nThe default error page only contain a generic error message (e.g. \"An error occurred\"), whereas the development-mode\nerror page will log full stack traces.\n\n### Sanitize Error Messages\n\nMake sure error messages returned from the database or containing system information are logged, but not shown to the \nuser. When running in non-development mode the ASP.NET web-server will show a generic error message to the user, while \nthe detailed error is written to the logs for investigation. You can configure the error page that is generated at\n`/Views/Shared/Errors.cs.html`.\n\n### Separate Dynamic and Static Resources\n\nEnsure static resources and dynamic content are stored in separate directories, so a malicious user cannot snoop \nthrough your code and configuration files. An ASP.NET web application can be configured to serve static content under\nthe `wwwroot` directory by adding the following line in the startup configuration:\n\n```csharp\napp.UseStaticFiles();\n```\n\nYou can also add additional static content directories with the following logic:\n\n```csharp\napp.UseStaticFiles(new StaticFileOptions\n{\n    FileProvider = new PhysicalFileProvider(Path.Combine(env.ContentRootPath, \"MyStaticFiles\")),\n    RequestPath = \"/StaticFiles\"\n});\n```\n\n### Disable the \"Server\" Header \n\nConsider disabling the `Server` header and the (non-standard but common) `X-Powered-By` header, and making the session \ncookie name generic. This will give your keep an attacker guessing about what your technology stack is, which makes \nattacking it harder. In ASP.NET, you can programmatically remove it in the following manner:\n\n```csharp\nHttpContext.Current.Response.Headers.Remove(\"Server\");\n```\n\nIf you are deploying to IIS, you can remove the header in your configuration settings:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration>\n    <system.webServer>\n        <security>\n            <requestFiltering removeServerHeader=\"true\" />\n        </security>\n    </system.webServer>\n</configuration>\n```\n\n:::\n\n:::tab[JavaScript]\n\n## How to Prevent Data Leaks in JavaScript\n\n### Keep Error Reporting on the Server\n\nDisable client-side error reporting in your production environment. This Express server will dump stack trace \ninformation only in the `development` environment, and disable it in `production`:\n  \n```javascript\nconst errorhandler = require('errorhandler')\nconst express      = require('express')\n\nconst app = express()\n\napp.use(errorhandler({\n  dumpExceptions : app.get('env') === 'development',\n  showStack      : app.get('env') === 'development'\n}))\n```\n\n### Sanitize Error Messages\n\nMake sure error messages returned from the database are logged, but not shown to the user. Here a generic error \nmessage is shown to the user, while the detailed error is written to the logs for investigation:\n\n```javascript\napp.get('/profile', (request, response) => {\n  db.run('SELECT * FROM USERS WHERE email = ?', [ request.session.user ], (error, user) => {\n    if (error) {\n      log.error(error)\n      response.send('An unexpected error occurred')\n      return\n    }\n\n    response.send(`<p>Your email is ${user.email}</p>`)\n  })\n})\n```\n\n### Separate Dynamic and Static Resources\n\nEnsure static resources and dynamic content are stored in separate directories, so a malicious user cannot snoop \nthrough your code and configuration files. For example, this is how to tell Expression to server static content (like \nclient-side JavaScript and CSS files) from the `/static` directory:\n  \n```javascript\napp.use(express.static(__dirname + '/static'))\n```\n\n### Disable the \"Server\" Header \n\nConsider disabling the `Server` header and the (non-standard but common) `X-Powered-By` header, and making the session \ncookie name generic. This will give your keep an attacker guessing about what your technology stack is, which makes \nattacking it harder. Here's how to do that in Express:\n  \n```javascript\n// Disable the 'X-Powered-By' header.\napp.disable('x-powered-by')\n\nconst cookieParser = require('cookie-parser')\nconst session      = require('express-session')\n\napp.use(cookieParser('secret'))\napp.use(session({\n  cookie : {\n    maxAge   : 60000,\n    httpOnly : true,\n    sameSite : 'strict',\n    secure   : app.get('env') !== 'development'\n  },\n\n  // Make the session cookie name generic.\n  name   : 'session',\n  secret : process.env.SESSION_SECRET || uid.sync(18)\n}))\n```\n\n:::\n\n:::tab[Python]\n\n## How to Prevent Data Leaks in Python\n\n### Keep Error Reporting on the Server\n\nDisable client-side error reporting in your production environment. Observe how the Flask framework uses different error\npages in development and production modes, distinguished by whether the environment variable `FLASK_ENV` is set to\n`development`:\n\n```python\n  @property\n  def debug(self) -> bool:\n     \"\"\"Whether debug mode is enabled. When using ``flask run`` to start\n     the development server, an interactive debugger will be shown for\n     unhandled exceptions, and the server will be reloaded when code\n     changes. This maps to the :data:`DEBUG` config key. This is\n     enabled when :attr:`env` is ``'development'`` and is overridden\n     by the ``FLASK_DEBUG`` environment variable. It may not behave as\n     expected if set in code.\n\n     **Do not enable debug mode when deploying in production.**\"\"\"\n     return self.config[\"DEBUG\"]\n```\n\nThe default error page only contain a generic error message (e.g. \"An error occurred\"), whereas the development-mode\nerror page will log full stack traces, and even allow interactive execution of Python code.\n\n### Sanitize Error Messages\n\nMake sure error messages returned from the database or containing system information are logged, but not shown to the \nuser. When running in non-development mode the Flask web-server will show a generic error message to the user, while \nthe detailed error is written to the logs for investigation:\n\n```python\n  def log_exception(self, exc_info) -> None:\n    \"\"\"Logs an exception.  This is called by :meth:`handle_exception`\n    if debugging is disabled and right before the handler is called.\n    The default implementation logs the exception as error on the\n    :attr:`logger`.\n    \"\"\"\n    self.logger.error(\n        f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n    )\n```\n\n### Separate Dynamic and Static Resources\n\nEnsure static resources and dynamic content are stored in separate directories, so a malicious user cannot snoop \nthrough your code and configuration files. Here's how to specify the directory containing static files (like JavaScript \ncode and images) in the Flask web-server:\n\n```python\nfrom flask import Flask\n\napp = Flask(__name__, static_folder='static')\n```\n\n### Disable the \"Server\" Header \n\nConsider disabling the `Server` header and the (non-standard but common) `X-Powered-By` header, and making the session \ncookie name generic. This will give your keep an attacker guessing about what your technology stack is, which makes \nattacking it harder. In the Gunicorn WSGI container, you can configure this header in your `gunicorn.conf.py` config \nfile:\n\n```python\nimport gunicorn\n\n# Make the server name completely generic.\ngunicorn.SERVER_SOFTWARE = 'Server'\n```\n\n:::\n\n:::tab[Scala]\n\n## How to Prevent Data Leaks in Scala\n\n### Keep Error Reporting on the Server\n\nDisable client-side error reporting in your production environment. Notice how the Play framework uses different error\npages in development and production modes:\n\n```scala\n  /**\n   * Invoked in dev mode when a server error occurs.\n   */\n  protected def onDevServerError(request: RequestHeader, exception: UsefulException): Future[Result] = {\n    Future.successful {\n      implicit val ir: RequestHeader = request\n      InternalServerError(views.html.defaultpages.devError(playEditor, exception))\n    }\n  }\n\n  /**\n   * Invoked in prod mode when a server error occurs.\n   */\n  protected def onProdServerError(request: RequestHeader, exception: UsefulException): Future[Result] =\n    Future.successful {\n      implicit val ir: RequestHeader = request\n      InternalServerError(views.html.defaultpages.error(exception))\n    }\n```\n\nThe default error page only contain a generic error message (e.g. \"An error occurred\"), whereas the development-mode\nerror page will log full stack traces.\n\n### Sanitize Error Messages\n\nMake sure error messages returned from the database or containing system information are logged, but not shown to the \nuser. Here a generic error message is shown to the user, while the detailed error is written to the logs for investigation:\n\n```scala\n  override def onServerError(request: RequestHeader, exception: Throwable): Future[Result] = {\n    try {\n      val usefulException = HttpErrorHandlerExceptions.throwableToUsefulException(sourceMapper, !config.showDevErrors, exception)\n\n      // Write the full error context and stack trace to the log file.\n      logServerError(request, usefulException)\n\n      // Sanitize the error to be displayed to the user, when in production-mode.\n      if (config.showDevErrors) onDevServerError(request, usefulException)\n      else onProdServerError(request, usefulException)\n    } catch {\n      case NonFatal(e) =>\n        logger.error(\"Error while handling error\", e)\n        Future.successful(InternalServerError(fatalErrorMessage(request, e)))\n    }\n  }\n```\n\n### Separate Dynamic and Static Resources\n\nEnsure static resources and dynamic content are stored in separate directories, so a malicious user cannot snoop \nthrough your code and configuration files. In the Play framework, static assets like JavaScript and CSS files are \ntypically kept in a separate `/public` and mapped in the routes file as follows:\n\n```scala\nGET  /assets/*file        controllers.Assets.at(path=\"/public\", file)\n```\n\n### Disable the \"Server\" Header \n\nConsider disabling the `Server` header and the (non-standard but common) `X-Powered-By` header, and making the session \ncookie name generic. This will give your keep an attacker guessing about what your technology stack is, which makes \nattacking it harder. For example, the Akka web-server allows you to disable these headers through configuration options:\n\n```\nakka.http {\n  server {\n    # The default value of the `Server` header to produce if no\n    # explicit `Server`-header was included in a response.\n    # If this value is the empty string and no header was included in\n    # the request, no `Server` header will be rendered at all.\n    server-header = \"\" # akka-http/${akka.http.version}\n  }  \n}\n```\n\n:::\n\n:::tab[Go]\n\n## How to Prevent Data Leaks in Go\n\n### Keep Error Reporting on the Server\n\nDisable client-side error reporting in your production environment. In Go web applications, you typically end up writing\nyour own error pages. Ensure that any pages that handle errors pay use flags to distinguish the environment they are \nexecuting in:\n\n```go\nimport \"flag\"\n\nvar debug = flag.Bool(\"debug\", false, \"Whether to show full error messages on the client\")\n```\n\nA default error page only contain a generic error message (e.g. \"An error occurred\"), whereas the development-mode\nerror page can show more information, like full stack traces.\n\n### Sanitize Error Messages\n\nMake sure error messages returned from the database or containing system information are logged, but not shown to the \nuser. Go functions typically return error codes when then fail, and web handlers will return early when error conditions \noccur. Ensure such code does not leak sensitive system data.\n\n```go\nsession, err := session.Get(request, \"session\")\n\nif err != nil {\n  // The second argument here is returned directly to the client, which leaks information!\n  http.Error(response, err.Error(), http.StatusInternalServerError)\n  return\n}\n```\n\n### Separate Dynamic and Static Resources\n\nEnsure static resources and dynamic content are stored in separate directories, so a malicious user cannot snoop \nthrough your code and configuration files. Here's how to specify the directory containing static files (like JavaScript \ncode and images) in the Gorilla web framework:\n\n```go\nfunc main() {\n  var dir string\n\n  flag.StringVar(&dir, \"dir\", \".\", \"the directory to serve files from. Defaults to the current dir\")\n  flag.Parse()\n  router := mux.NewRouter()\n\n  // This will serve files under http://localhost:8000/static/<filename>\n  router.PathPrefix(\"/static/\").Handler(http.StripPrefix(\"/static/\", http.FileServer(http.Dir(dir))))\n\n  server := &http.Server{\n    Handler: router,\n    Addr:    \"127.0.0.1:8000\"\n  }\n\n  log.Fatal(server.ListenAndServe())\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## How to Prevent Data Leaks in PHP\n\n### Keep Error Reporting on the Server\n\nDisable error reporting to the client in your production environment by setting the `display_errors` directive to `Off` in your `php.ini`:\n\n```ini\ndisplay_errors = Off\n```\n\nYou should instead log the errors for review. Ensure that `log_errors` directive is set to `On`:\n\n```ini\nlog_errors = On\nerror_log = /path/to/php-error.log\n```\n\n### Sanitize Error Messages\n\nAvoid directly echoing out database or system error messages to the user. Instead, present a generic message while logging the exact error for debugging:\n\n```php\ntry \n{\n    $result = $db->query(\"SELECT * FROM users WHERE email = '$email'\");\n}\ncatch (PDOException $e) \n{\n    error_log(\"Database error: \" . $e->getMessage());\n    echo \"An unexpected error occurred, please try again later.\";\n}\n```\n\n### Separate Dynamic and Static Resources\n\nFor websites or web applications using PHP, it's common to store PHP files in one directory and static resources (e.g., images, stylesheets, and JavaScript files) in separate directories. This way, you can use server configurations to ensure direct access to PHP files is restricted.\n\n### Hide PHP Version Information\n\nThe `X-Powered-By` header can give away the PHP version you're running. To hide this:\n\n1. Edit `php.ini` and update:\n\n```ini\nexpose_php = Off\n```\n\nOr, if you're using an `.htaccess` file on an Apache server:\n\n```apache\nHeader unset X-Powered-By\n```\n\n### Be Careful With Comments\n\nAvoid leaving sensitive or internal-only comments in your PHP files. Even if you think they are in a part of the code that doesn't output to the user, mistakes or changes in the codebase could expose them. Always assume that anything in a code file could potentially be exposed.\n\n:::\n\n::::\n\n## Further Considerations\n\n* Ensure any comments in template files don't contain sensitive data! It's easy to leave in notes about server names\n  and addresses that will get passed to the client-side. Attackers know this, and will scan comments in HTML for IP\n  addresses and URLs.\n  \n* Ensure server-side log messages do not contain sensitive information like passwords or credit card numbers - this \n  should mitigate the harm an attacker can do if they manage to steal your server's log files.\n  \n\n## Additional information\n\n**[CWE-200](https://cwe.mitre.org/data/definitions/200.html)**\n\n**[OWASP-A3](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A3-Sensitive_Data_Exposure)**"
                            },
                            "helpUri": "https://cwe.mitre.org/data/definitions/200.html",
                            "id": "log-sensitive-data-fuzzy/9e532a249bd7d271ae4f8b75130e8c90",
                            "name": "Sensitive Data Exposure: Library Is Configured To Print Potentially Sensitive Data In __Init__.py",
                            "properties": {
                                "precision": "very-high",
                                "security-severity": "3",
                                "tags": [
                                    "ng-sast",
                                    "CVSS 3",
                                    "CWE 200",
                                    "CWE 550",
                                    "OWASP 2021 a01-broken-access-control",
                                    "OWASP a01-2021-broken-access-control",
                                    "OWASP a3-sensitive-data-exposure",
                                    "Sensitive Data Exposure"
                                ]
                            },
                            "shortDescription": {
                                "text": "Sensitive Data Exposure: Library is Configured to Print Potentially Sensitive Data in __init__.py"
                            }
                        },
                        {
                            "defaultConfiguration": {
                                "enabled": true,
                                "level": "error",
                                "rank": -1
                            },
                            "fullDescription": {
                                "text": "Attacker-Controlled input data is used as part of a file path to write a file without escaping or validation. This indicates a directory traversal vulnerability."
                            },
                            "help": {
                                "markdown": "Attacker-Controlled input data is used as part of a file path to write a file without escaping or validation. This indicates a directory traversal vulnerability.\n\n# Directory Traversal\n\n**Directory traversal** vulnerabilities allow attackers to access arbitrary files on your server by manipulating HTTP\nparameters to include relative path syntax. It is important that you treat any parameters used to refer to files\nsecurely, or an attacker will be able to read sensitive data from your file system. Even better, avoid direct references\nto filenames altogether and use opaque identifiers and indirection instead.\n\n::::tabs\n\n:::tab[Java]\n\nPassing file paths in URLs is dangerous. Consider the following Java application that hosts menus for a restaurant:\n\n```java\npublic class UnsafeFileDownloadServlet\n{\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        /**\n         * Taking the unfiltered filename from the HTTP request is dangerous -\n         * an attacker can use the \"../\" syntax in a filename to climb out of\n         * the intended directory.\n         */\n        final String fileName      = request.getParameter(\"menu\");\n        final String menuDirectory = \"/var/etc/menus\";\n\n        response.setContentType(\"application/pdf\");\n        response.setHeader(\"Content-disposition\", \"attachment; filename=\" + fileName);\n\n        try (OutputStream out = response.getOutputStream()) {\n            File file = new File(menuDirectory + File.separator + fileName);\n            Files.copy(file.toPath(), out);\n        }\n    }\n}\n```\n\nHere the name of the menu corresponds to a file on disk, which is being passed in the query string parameter. An \nattacker can set this `menu` parameter to anything they choose, and use the `../` syntax to access other directories. In \nfact, the URL `/menus?menu=../certs/key.pem` will let them download the server's private key kept in a directory next \nto the menus.\n\nIf you take file paths from the HTTP request, make sure to strip any characters that can be used in files paths, such as \n`/`, `..`, `\\`. These characters vary by operating system and can be encoded in subtle ways, so it's generally \nbest to use a method like `FilenameUtils.getBaseName` that strips any potential directory\ncomponents from a path. That only leaves `.`, `..` and the empty string as\nspecial cases that could lead to unexpected behavior:\n\n```java\nimport org.apache.commons.io.FilenameUtils;\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        /**\n         * Removing anything except alphanumeric characters (and periods) will\n         * stop access to arbitrary directories.\n         */\n        final String fileName      = request.getParameter(\"menu\");\n        final String safeFileName  = FilenameUtils.getBaseName(fileName);\n        final String menuDirectory = \"/var/etc/menus\";\n\n\tif (\"\".equals(safeFileName) || \".\".equals(safeFileName) || \"..\".equals(safeFileName)) {\n\t    throw new SystemException(\"refusing to read a special directory name\");\n\t}\n\n        response.setContentType(\"application/pdf\");\n        response.setHeader(\"Content-disposition\", \"attachment; filename=\" + safeFileName);\n\n        try (OutputStream out = response.getOutputStream()) {\n            File file = new File(menuDirectory + File.separator + safeFileName);\n            Files.copy(file.toPath(), out);\n        }\n    }\n}\n```\n\nIn Java web applications you can have the server take care of this for you. The following configuration safely mounts \nthe `/var/etc/menus` directory as static content in a Jetty web-server:\n\n```xml\n<Configure class=\"org.eclipse.jetty.server.handler.ContextHandler\">\n  <Set name=\"contextPath\">/menus</Set>\n  <Set name=\"handler\">\n    <New class=\"org.eclipse.jetty.server.handler.ResourceHandler\">\n      <Set name=\"resourceBase\">/var/etc/menus</Set>\n      <Set name=\"directoriesListed\">false</Set>\n    </New>\n  </Set>\n</Configure>\n\n```\n\n:::\n\n:::tab[C#]\n\n## Directory Traversal in C#\n\nPassing file paths in URLs is dangerous. Consider the following ASP.NET Core controller method that hosts menus for a \nrestaurant:\n\n```csharp\n    [HttpGet(\"menus\")]\n    public IActionResult UnsafeFileDownload([FromQuery] string menu)\n    {\n        byte[] fileBytes = System.IO.File.ReadAllBytes(\"Static/menus/\" + menu);\n        return File(fileBytes, \"application/pdf\", menu);\n    }\n```\n\nHere the name of the menu corresponds to a file on disk, which is being passed in the query string parameter. An \nattacker can set this `menu` parameter to anything they choose, and use the `../` syntax to access other directories. In \nfact, the URL `/menus?menu=../certs/key.pem` will let them download the server's private key kept in a directory next \nto the menus.\n\nIf you take file paths from the HTTP request, make sure to strip any characters that can be used in files paths, such as \n`/`, `..`, `\\` and`~`. These characters vary by operating system and can be encoded in subtle ways, so it's generally \nbest to use a method like `Path.GetFileName` that strips any potential directory\ncomponents from a path. That only leaves `.`, `..` and the empty string as\nspecial cases that could lead to unexpected behavior:\n\n```csharp\n    [HttpGet(\"menus\")]\n    public IActionResult SaferFileDownload([FromQuery] string menu)\n    {\n        string baseName = System.IO.Path.GetFileName(menu);\n        if (baseName != \"\" && baseName != \".\" && baseName != \"..\") {\n            byte[] fileBytes    = System.IO.File.ReadAllBytes(\"Static/menus/\" + baseName);\n\n            return File(fileBytes, \"application/pdf\", menu);\n        } else {\n            return Forbid();\n        }\n    }\n```\n\nIn most web-servers you can have the server take care of this for you. The following snipped shows how to use the \nASP.NET Core Static File Middleware to safely mount the `/Static/Menus` directory as static content:\n\n```csharp\n  // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n  public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n  {\n      if (env.IsDevelopment())\n      {\n          app.UseDeveloperExceptionPage();\n          app.UseMigrationsEndPoint();\n      }\n      else\n      {\n          app.UseExceptionHandler(\"/Home/Error\");\n          app.UseHsts();\n      }\n      \n      app.UseHttpsRedirection();\n      \n      // Mount the standard 'wwwroot' directory so files are accessible over HTTP.\n      app.UseStaticFiles();\n      \n      // Mount the local 'static/menus' directory so files are accessible over HTTP under the '/menus' path.\n      app.UseStaticFiles(new StaticFileOptions\n      {\n          FileProvider = new PhysicalFileProvider(Path.Combine(env.ContentRootPath, \"Static/Menus\")),\n          RequestPath = \"/menus\"\n      });\n      \n      app.UseRouting();\n\n      app.UseEndpoints(endpoints =>\n      {\n          endpoints.MapControllerRoute(\n              name: \"default\",\n              pattern: \"{controller=Home}/{action=Index}/{id?}\");\n          endpoints.MapRazorPages();\n      });\n   } \n```\n\n:::\n\n:::tab[JavaScript]\n\n## Directory Traversal in JavaScript\n\nPassing file paths in URLs is dangerous. Consider the following Express application that hosts menus for a restaurant:\n\n```javascript\nconst express = require('express')\nconst app     = express()\n\napp.get('/', (request, response) => {\n  response.send(\n    `<div>\n       <h1>Click on a menu to download it</h1>\n       <p><a href=\"/menu?menu=breakfast.pdf\"> Breakfast </a></p>\n       <p><a href=\"/menu?menu=lunch.pdf\">     Lunch     </a></p>\n       <p><a href=\"/menu?menu=dinner.pdf\">    Dinner    </a></p>\n     </div>`)\n})\n\nconst path = require('path')\n\napp.get('/menu', (request, response) => {\n\n  /**\n   * Taking the unfiltered filename from the HTTP request is dangerous -\n   * an attacker can use the \"../\" syntax in a filename to climb out of\n   * the intended directory.\n   */\n  const menuPath = path.resolve('menus/', request.query.menu)\n\n  response.download(menuPath)\n})\n```\n\nHere the name of the menu corresponds to a file on disk, which is being passed in the query string parameter. An \nattacker can set this `menu` parameter to anything they choose, and use the `../` syntax to access other directories. In \nfact, the URL `/menus?menu=../certs/key.pem` will let them download the server's private key kept in a directory next \nto the menus.\n\nIf you take file paths from the HTTP request, make sure to strip any characters that can be used in files paths, such as \n`/`, `..`, `\\` and`~`. These characters vary by operating system and can be encoded in subtle ways, so it's generally \nbest to disallow *all* non-alphanumeric characters:\n\n```javascript\napp.get('/menu', (request, response) => {\n\n  /**\n   * Removing anything except alphanumeric characters (excluding the extension) will\n   * stop access to arbitrary directories.\n   */\n  const suppliedFilename = request.query.menu\n  const match            = suppliedFilename.match(/([a-z0-9]+)\\.([a-z]+)/i)\n  const scrubbedFileName = match[1] + '.' + match[2]\n\n  const menuPath = 'menus/' + scrubbedFileName\n\n  response.download(menuPath)\n})\n```\n\nIn Express, you can have the server take care of this for you. The following code mounts the `/menus` directory as\nstatic content safely:\n\n```javascript\nconst express = require('express')\nconst app     = express()\n\napp.get('/', (request, response) => {\n  response.send(\n    `<div>\n       <h1>Click on a menu to download it</h1>\n       <p><a href=\"/menu/breakfast.pdf\"> Breakfast </a></p>\n       <p><a href=\"/menu/lunch.pdf\">     Lunch     </a></p>\n       <p><a href=\"/menu/dinner.pdf\">    Dinner    </a></p>\n     </div>`)\n})\n\n// Tell Express that the /menu directory contains static files that should be made\n// available to the browser.\napp.use('/menu', express.static('menus'))\n```\n\n:::\n\n:::tab[Python]\n\n## Directory Traversal in Python\n\nPassing file paths in URLs is dangerous. Consider the following Flask application that hosts menus for a restaurant:\n\n```python\n@app.route('/menus')\ndef download_menu():\n  \"\"\"An insecure static file handler that allows directory traversal attacks.\"\"\"\n\n  filename         = request.args.get('menu')\n  static_directory = os.fspath(app.menu_folder)\n\n  # The construction of the path here is incredibly insecure!\n  # If a path contains the \"..%2F\" pattern, it will be treated as\n  # ../ and a hacker can climb out of the static directory.\n  filename = posixpath.join(static_directory, filename)\n\n  return send_file(filename)\n```\n\nHere the name of the menu corresponds to a file on disk, which is being passed in the query string parameter. An \nattacker can set this `menu` parameter to anything they choose, and use the `../` syntax to access other directories. In \nfact, the URL `/menus?menu=../certs/key.pem` will let them download the server's private key kept in a directory next \nto the menus.\n\nIf you can avoid it, it's preferable to not rely on user input for file names: just\nuse a unique name generated on the server-side instead. This could e.g. be a\ndatabase primary key, or a unique token generated with `secrets.token_urlsafe(32)`.\n\nIf you take file paths from the HTTP request, make sure to strip any characters that can be used in files paths.\nThe easiest way to achieve that is with functions such as `os.path.basename`.\nHowever, that would still let through special file names `.` and `..`, for which\nwe add special treatment:\n\n```python\nimport os.path\n\n@app.route('/menus')\ndef download_menu():\n  \"\"\"An more secure file handler does not allow directory traversal attacks.\"\"\"\n\n  filename         = request.args.get('menu')\n  safe_filename    = os.path.basename(filename)\n  if safe_filename == '..' or safe_filename == '.':\n    raise Exception(\"path traversal\")\n\n  static_directory = os.fspath(app.menu_folder)\n  filename         = os.path.join(static_directory, safe_filename)\n\n  return send_file(filename)\n```\n\nIn most web-servers you can have the server take care of this for you. The following function safely mounts \nthe `/var/etc/menus` directory as static content using the Flask web-server:\n\n```python\n@app.route('/menus/<path:path>')\ndef download_menu(path):\n    return send_from_directory('/var/etc/menus', path)\n```\n\n:::\n\n:::tab[Scala]\n\n## Directory Traversal in Scala\n\nPassing file paths in URLs is dangerous. Consider the following Scala application that hosts menus for a restaurant:\n\n```scala\ndef getMenu = Action { request =>\n  val menu = request.getQueryString(\"menu\")\n\n  if (menu.isEmpty) {\n    Redirect(\"/menus\")\n  }\n  else {\n    Ok.sendFile(new java.io.File(s\"/var/etc/menus/${menu.get}\"))\n  }\n}\n```\n\nHere the name of the menu corresponds to a file on disk, which is being passed in the query string parameter. An \nattacker can set this `menu` parameter to anything they choose, and use the `../` syntax to access other directories. In \nfact, the URL `/menus?menu=../certs/key.pem` will let them download the server's private key kept in a directory next \nto the menus.\n\nIf you take file paths from the HTTP request, make sure to strip any characters that can be used in files paths, such as \n`/`, `..`, `\\` and`~`. These characters vary by operating system and can be encoded in subtle ways, so it's generally \nbest to disallow *all* non-alphanumeric characters:\n\n```scala\ndef getMenu = Action { request =>\n  val menu = request.getQueryString(\"menu\")\n\n  if (menu.isEmpty) {\n    Redirect(\"/menus\")\n  }\n  else {\n    val safeFilename = menu.get.replaceAll(\"[^a-zA-Z0-9\\\\.]\",\"\")\n    Ok.sendFile(new java.io.File(s\"/var/etc/menus/${safeFilename}\"))\n  }\n}\n```\n\nIn most web-servers you can have the server take care of this for you. The following configuration safely mounts \nthe `/var/etc/menus` directory as static content using the `Assets` controller of the Play framework:\n\n```\nGET /menus/*menu controllers.Assets.at(path=\"/var/etc/menus\", menu)\n```\n\n:::\n\n:::tab[Go]\n\n## Directory Traversal in Go\n\nPassing file paths in URLs is dangerous. Consider the following Go application that hosts menus for a restaurant:\n\n```go\n// An insecure static file handler that allows directory traversal attacks.\nfunc MenuFileHandler(response http.ResponseWriter, request *http.Request) {\n  fileName := request.URL.Query().Get(\"menu\")\n\n  file, err := os.Open(staticFolder + fileName)\n\n  if err != nil {\n    http.Error(response, \"Error opening file\", http.StatusInternalServerError)\n    return\n  }\n\n  defer file.Close()\n\n  response.Header().Set(\"Content-Type\", \"application/pdf\")\n\n  io.Copy(response, file)\n}\n```\n\nHere the name of the menu corresponds to a file on disk, which is being passed in the query string parameter. An \nattacker can set this `menu` parameter to anything they choose, and use the `../` syntax to access other directories. In \nfact, the URL `/menus?menu=../certs/key.pem` will let them download the server's private key kept in a directory next \nto the menus.\n\nIf you take file paths from the HTTP request, make sure to strip any characters that can be used in files paths, such as \n`/`, `..`, `\\` and`~`. These characters vary by operating system and can be encoded in subtle ways, so it's generally \nbest to use a method like `filepath.Base` that strips any potential directory\ncomponents from a path. That only leaves `.`, `/` and `..` as special cases that could lead to unexpected behavior:\n\n```go\n// A more secure file handler does not allow directory traversal attacks.\nfunc MenuFileHandler0(response http.ResponseWriter, request *http.Request) {\n  fileName := filepath.Base(request.URL.Query().Get(\"menu\"))\n  if fileName == \".\" || fileName == \"/\" || fileName == \"..\" {\n    http.Error(response, \"Forbidden\", http.StatusForbidden)\n    return\n  }\n\n  file, err := os.Open(staticFolder + fileName)\n\n  if err != nil {\n    http.Error(response, \"Error opening file\", http.StatusInternalServerError)\n    return\n  }\n\n  defer file.Close()\n\n  response.Header().Set(\"Content-Type\", \"application/pdf\")\n\n  io.Copy(response,\n```\n\nIn most web-servers you can have the server take care of this for you. The following function safely mounts \na configurable directory as static content using the Gorilla web framework:\n\n```go\nfunc main() {\n  var dir string\n\n  flag.StringVar(&dir, \"dir\", \".\", \"the directory to serve files from. Defaults to the current dir\")\n  flag.Parse()\n  router := mux.NewRouter()\n\n  // This will serve files under http://localhost:8000/static/<filename>\n  router.PathPrefix(\"/static/\").Handler(http.StripPrefix(\"/static/\", http.FileServer(http.Dir(dir))))\n\n  server := &http.Server{\n    Handler: router,\n    Addr:    \"127.0.0.1:8000\"\n  }\n\n  server.ListenAndServe()\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Directory Traversal in PHP\n\nAllowing direct file references through user inputs can expose your application to Directory Traversal attacks. Consider this PHP script that fetches restaurant menus:\n\n```php\n$menuDirectory = \"/var/etc/menus\";\n$fileName = $_GET['menu'];\n\nheader(\"Content-Type: application/pdf\");\nheader(\"Content-Disposition: attachment; filename={$fileName}\");\n\n$file = $menuDirectory . DIRECTORY_SEPARATOR . $fileName;\nreadfile($file);\n```\n\nHere, the menu's filename is directly taken from the query string parameter. An attacker can manipulate this parameter, using patterns like `../`, to navigate out of the intended directory and access unintended files.\n\n## Mitigation\n\n1. **Input Sanitization**: Drop any directory references within filenames\n   received from the outside:\n\n```php\n$fileName = basename($_GET['menu']);\n```\n\n2. **Opaque File References**: Instead of direct file references, consider using an array or database of approved filenames, or encode actual file references, ensuring users can't directly specify paths. \n\n:::\n\n::::\n\n## Other Considerations\n\nIf your website is handling a lot of static documents, consider using or integrating a third-party *Content Management\nSystem* (CMS). These will generate secure paths for documents as they are uploaded and allow fine-grained permissions\nto be set.\n\n## Additional information\n\n**[CWE-22](https://cwe.mitre.org/data/definitions/22.html)**\n\n**[OWASP-A5](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control)**",
                                "text": "Attacker-Controlled input data is used as part of a file path to write a file without escaping or validation. This indicates a directory traversal vulnerability.\n\n# Directory Traversal\n\n**Directory traversal** vulnerabilities allow attackers to access arbitrary files on your server by manipulating HTTP\nparameters to include relative path syntax. It is important that you treat any parameters used to refer to files\nsecurely, or an attacker will be able to read sensitive data from your file system. Even better, avoid direct references\nto filenames altogether and use opaque identifiers and indirection instead.\n\n::::tabs\n\n:::tab[Java]\n\nPassing file paths in URLs is dangerous. Consider the following Java application that hosts menus for a restaurant:\n\n```java\npublic class UnsafeFileDownloadServlet\n{\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        /**\n         * Taking the unfiltered filename from the HTTP request is dangerous -\n         * an attacker can use the \"../\" syntax in a filename to climb out of\n         * the intended directory.\n         */\n        final String fileName      = request.getParameter(\"menu\");\n        final String menuDirectory = \"/var/etc/menus\";\n\n        response.setContentType(\"application/pdf\");\n        response.setHeader(\"Content-disposition\", \"attachment; filename=\" + fileName);\n\n        try (OutputStream out = response.getOutputStream()) {\n            File file = new File(menuDirectory + File.separator + fileName);\n            Files.copy(file.toPath(), out);\n        }\n    }\n}\n```\n\nHere the name of the menu corresponds to a file on disk, which is being passed in the query string parameter. An \nattacker can set this `menu` parameter to anything they choose, and use the `../` syntax to access other directories. In \nfact, the URL `/menus?menu=../certs/key.pem` will let them download the server's private key kept in a directory next \nto the menus.\n\nIf you take file paths from the HTTP request, make sure to strip any characters that can be used in files paths, such as \n`/`, `..`, `\\`. These characters vary by operating system and can be encoded in subtle ways, so it's generally \nbest to use a method like `FilenameUtils.getBaseName` that strips any potential directory\ncomponents from a path. That only leaves `.`, `..` and the empty string as\nspecial cases that could lead to unexpected behavior:\n\n```java\nimport org.apache.commons.io.FilenameUtils;\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        /**\n         * Removing anything except alphanumeric characters (and periods) will\n         * stop access to arbitrary directories.\n         */\n        final String fileName      = request.getParameter(\"menu\");\n        final String safeFileName  = FilenameUtils.getBaseName(fileName);\n        final String menuDirectory = \"/var/etc/menus\";\n\n\tif (\"\".equals(safeFileName) || \".\".equals(safeFileName) || \"..\".equals(safeFileName)) {\n\t    throw new SystemException(\"refusing to read a special directory name\");\n\t}\n\n        response.setContentType(\"application/pdf\");\n        response.setHeader(\"Content-disposition\", \"attachment; filename=\" + safeFileName);\n\n        try (OutputStream out = response.getOutputStream()) {\n            File file = new File(menuDirectory + File.separator + safeFileName);\n            Files.copy(file.toPath(), out);\n        }\n    }\n}\n```\n\nIn Java web applications you can have the server take care of this for you. The following configuration safely mounts \nthe `/var/etc/menus` directory as static content in a Jetty web-server:\n\n```xml\n<Configure class=\"org.eclipse.jetty.server.handler.ContextHandler\">\n  <Set name=\"contextPath\">/menus</Set>\n  <Set name=\"handler\">\n    <New class=\"org.eclipse.jetty.server.handler.ResourceHandler\">\n      <Set name=\"resourceBase\">/var/etc/menus</Set>\n      <Set name=\"directoriesListed\">false</Set>\n    </New>\n  </Set>\n</Configure>\n\n```\n\n:::\n\n:::tab[C#]\n\n## Directory Traversal in C#\n\nPassing file paths in URLs is dangerous. Consider the following ASP.NET Core controller method that hosts menus for a \nrestaurant:\n\n```csharp\n    [HttpGet(\"menus\")]\n    public IActionResult UnsafeFileDownload([FromQuery] string menu)\n    {\n        byte[] fileBytes = System.IO.File.ReadAllBytes(\"Static/menus/\" + menu);\n        return File(fileBytes, \"application/pdf\", menu);\n    }\n```\n\nHere the name of the menu corresponds to a file on disk, which is being passed in the query string parameter. An \nattacker can set this `menu` parameter to anything they choose, and use the `../` syntax to access other directories. In \nfact, the URL `/menus?menu=../certs/key.pem` will let them download the server's private key kept in a directory next \nto the menus.\n\nIf you take file paths from the HTTP request, make sure to strip any characters that can be used in files paths, such as \n`/`, `..`, `\\` and`~`. These characters vary by operating system and can be encoded in subtle ways, so it's generally \nbest to use a method like `Path.GetFileName` that strips any potential directory\ncomponents from a path. That only leaves `.`, `..` and the empty string as\nspecial cases that could lead to unexpected behavior:\n\n```csharp\n    [HttpGet(\"menus\")]\n    public IActionResult SaferFileDownload([FromQuery] string menu)\n    {\n        string baseName = System.IO.Path.GetFileName(menu);\n        if (baseName != \"\" && baseName != \".\" && baseName != \"..\") {\n            byte[] fileBytes    = System.IO.File.ReadAllBytes(\"Static/menus/\" + baseName);\n\n            return File(fileBytes, \"application/pdf\", menu);\n        } else {\n            return Forbid();\n        }\n    }\n```\n\nIn most web-servers you can have the server take care of this for you. The following snipped shows how to use the \nASP.NET Core Static File Middleware to safely mount the `/Static/Menus` directory as static content:\n\n```csharp\n  // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n  public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n  {\n      if (env.IsDevelopment())\n      {\n          app.UseDeveloperExceptionPage();\n          app.UseMigrationsEndPoint();\n      }\n      else\n      {\n          app.UseExceptionHandler(\"/Home/Error\");\n          app.UseHsts();\n      }\n      \n      app.UseHttpsRedirection();\n      \n      // Mount the standard 'wwwroot' directory so files are accessible over HTTP.\n      app.UseStaticFiles();\n      \n      // Mount the local 'static/menus' directory so files are accessible over HTTP under the '/menus' path.\n      app.UseStaticFiles(new StaticFileOptions\n      {\n          FileProvider = new PhysicalFileProvider(Path.Combine(env.ContentRootPath, \"Static/Menus\")),\n          RequestPath = \"/menus\"\n      });\n      \n      app.UseRouting();\n\n      app.UseEndpoints(endpoints =>\n      {\n          endpoints.MapControllerRoute(\n              name: \"default\",\n              pattern: \"{controller=Home}/{action=Index}/{id?}\");\n          endpoints.MapRazorPages();\n      });\n   } \n```\n\n:::\n\n:::tab[JavaScript]\n\n## Directory Traversal in JavaScript\n\nPassing file paths in URLs is dangerous. Consider the following Express application that hosts menus for a restaurant:\n\n```javascript\nconst express = require('express')\nconst app     = express()\n\napp.get('/', (request, response) => {\n  response.send(\n    `<div>\n       <h1>Click on a menu to download it</h1>\n       <p><a href=\"/menu?menu=breakfast.pdf\"> Breakfast </a></p>\n       <p><a href=\"/menu?menu=lunch.pdf\">     Lunch     </a></p>\n       <p><a href=\"/menu?menu=dinner.pdf\">    Dinner    </a></p>\n     </div>`)\n})\n\nconst path = require('path')\n\napp.get('/menu', (request, response) => {\n\n  /**\n   * Taking the unfiltered filename from the HTTP request is dangerous -\n   * an attacker can use the \"../\" syntax in a filename to climb out of\n   * the intended directory.\n   */\n  const menuPath = path.resolve('menus/', request.query.menu)\n\n  response.download(menuPath)\n})\n```\n\nHere the name of the menu corresponds to a file on disk, which is being passed in the query string parameter. An \nattacker can set this `menu` parameter to anything they choose, and use the `../` syntax to access other directories. In \nfact, the URL `/menus?menu=../certs/key.pem` will let them download the server's private key kept in a directory next \nto the menus.\n\nIf you take file paths from the HTTP request, make sure to strip any characters that can be used in files paths, such as \n`/`, `..`, `\\` and`~`. These characters vary by operating system and can be encoded in subtle ways, so it's generally \nbest to disallow *all* non-alphanumeric characters:\n\n```javascript\napp.get('/menu', (request, response) => {\n\n  /**\n   * Removing anything except alphanumeric characters (excluding the extension) will\n   * stop access to arbitrary directories.\n   */\n  const suppliedFilename = request.query.menu\n  const match            = suppliedFilename.match(/([a-z0-9]+)\\.([a-z]+)/i)\n  const scrubbedFileName = match[1] + '.' + match[2]\n\n  const menuPath = 'menus/' + scrubbedFileName\n\n  response.download(menuPath)\n})\n```\n\nIn Express, you can have the server take care of this for you. The following code mounts the `/menus` directory as\nstatic content safely:\n\n```javascript\nconst express = require('express')\nconst app     = express()\n\napp.get('/', (request, response) => {\n  response.send(\n    `<div>\n       <h1>Click on a menu to download it</h1>\n       <p><a href=\"/menu/breakfast.pdf\"> Breakfast </a></p>\n       <p><a href=\"/menu/lunch.pdf\">     Lunch     </a></p>\n       <p><a href=\"/menu/dinner.pdf\">    Dinner    </a></p>\n     </div>`)\n})\n\n// Tell Express that the /menu directory contains static files that should be made\n// available to the browser.\napp.use('/menu', express.static('menus'))\n```\n\n:::\n\n:::tab[Python]\n\n## Directory Traversal in Python\n\nPassing file paths in URLs is dangerous. Consider the following Flask application that hosts menus for a restaurant:\n\n```python\n@app.route('/menus')\ndef download_menu():\n  \"\"\"An insecure static file handler that allows directory traversal attacks.\"\"\"\n\n  filename         = request.args.get('menu')\n  static_directory = os.fspath(app.menu_folder)\n\n  # The construction of the path here is incredibly insecure!\n  # If a path contains the \"..%2F\" pattern, it will be treated as\n  # ../ and a hacker can climb out of the static directory.\n  filename = posixpath.join(static_directory, filename)\n\n  return send_file(filename)\n```\n\nHere the name of the menu corresponds to a file on disk, which is being passed in the query string parameter. An \nattacker can set this `menu` parameter to anything they choose, and use the `../` syntax to access other directories. In \nfact, the URL `/menus?menu=../certs/key.pem` will let them download the server's private key kept in a directory next \nto the menus.\n\nIf you can avoid it, it's preferable to not rely on user input for file names: just\nuse a unique name generated on the server-side instead. This could e.g. be a\ndatabase primary key, or a unique token generated with `secrets.token_urlsafe(32)`.\n\nIf you take file paths from the HTTP request, make sure to strip any characters that can be used in files paths.\nThe easiest way to achieve that is with functions such as `os.path.basename`.\nHowever, that would still let through special file names `.` and `..`, for which\nwe add special treatment:\n\n```python\nimport os.path\n\n@app.route('/menus')\ndef download_menu():\n  \"\"\"An more secure file handler does not allow directory traversal attacks.\"\"\"\n\n  filename         = request.args.get('menu')\n  safe_filename    = os.path.basename(filename)\n  if safe_filename == '..' or safe_filename == '.':\n    raise Exception(\"path traversal\")\n\n  static_directory = os.fspath(app.menu_folder)\n  filename         = os.path.join(static_directory, safe_filename)\n\n  return send_file(filename)\n```\n\nIn most web-servers you can have the server take care of this for you. The following function safely mounts \nthe `/var/etc/menus` directory as static content using the Flask web-server:\n\n```python\n@app.route('/menus/<path:path>')\ndef download_menu(path):\n    return send_from_directory('/var/etc/menus', path)\n```\n\n:::\n\n:::tab[Scala]\n\n## Directory Traversal in Scala\n\nPassing file paths in URLs is dangerous. Consider the following Scala application that hosts menus for a restaurant:\n\n```scala\ndef getMenu = Action { request =>\n  val menu = request.getQueryString(\"menu\")\n\n  if (menu.isEmpty) {\n    Redirect(\"/menus\")\n  }\n  else {\n    Ok.sendFile(new java.io.File(s\"/var/etc/menus/${menu.get}\"))\n  }\n}\n```\n\nHere the name of the menu corresponds to a file on disk, which is being passed in the query string parameter. An \nattacker can set this `menu` parameter to anything they choose, and use the `../` syntax to access other directories. In \nfact, the URL `/menus?menu=../certs/key.pem` will let them download the server's private key kept in a directory next \nto the menus.\n\nIf you take file paths from the HTTP request, make sure to strip any characters that can be used in files paths, such as \n`/`, `..`, `\\` and`~`. These characters vary by operating system and can be encoded in subtle ways, so it's generally \nbest to disallow *all* non-alphanumeric characters:\n\n```scala\ndef getMenu = Action { request =>\n  val menu = request.getQueryString(\"menu\")\n\n  if (menu.isEmpty) {\n    Redirect(\"/menus\")\n  }\n  else {\n    val safeFilename = menu.get.replaceAll(\"[^a-zA-Z0-9\\\\.]\",\"\")\n    Ok.sendFile(new java.io.File(s\"/var/etc/menus/${safeFilename}\"))\n  }\n}\n```\n\nIn most web-servers you can have the server take care of this for you. The following configuration safely mounts \nthe `/var/etc/menus` directory as static content using the `Assets` controller of the Play framework:\n\n```\nGET /menus/*menu controllers.Assets.at(path=\"/var/etc/menus\", menu)\n```\n\n:::\n\n:::tab[Go]\n\n## Directory Traversal in Go\n\nPassing file paths in URLs is dangerous. Consider the following Go application that hosts menus for a restaurant:\n\n```go\n// An insecure static file handler that allows directory traversal attacks.\nfunc MenuFileHandler(response http.ResponseWriter, request *http.Request) {\n  fileName := request.URL.Query().Get(\"menu\")\n\n  file, err := os.Open(staticFolder + fileName)\n\n  if err != nil {\n    http.Error(response, \"Error opening file\", http.StatusInternalServerError)\n    return\n  }\n\n  defer file.Close()\n\n  response.Header().Set(\"Content-Type\", \"application/pdf\")\n\n  io.Copy(response, file)\n}\n```\n\nHere the name of the menu corresponds to a file on disk, which is being passed in the query string parameter. An \nattacker can set this `menu` parameter to anything they choose, and use the `../` syntax to access other directories. In \nfact, the URL `/menus?menu=../certs/key.pem` will let them download the server's private key kept in a directory next \nto the menus.\n\nIf you take file paths from the HTTP request, make sure to strip any characters that can be used in files paths, such as \n`/`, `..`, `\\` and`~`. These characters vary by operating system and can be encoded in subtle ways, so it's generally \nbest to use a method like `filepath.Base` that strips any potential directory\ncomponents from a path. That only leaves `.`, `/` and `..` as special cases that could lead to unexpected behavior:\n\n```go\n// A more secure file handler does not allow directory traversal attacks.\nfunc MenuFileHandler0(response http.ResponseWriter, request *http.Request) {\n  fileName := filepath.Base(request.URL.Query().Get(\"menu\"))\n  if fileName == \".\" || fileName == \"/\" || fileName == \"..\" {\n    http.Error(response, \"Forbidden\", http.StatusForbidden)\n    return\n  }\n\n  file, err := os.Open(staticFolder + fileName)\n\n  if err != nil {\n    http.Error(response, \"Error opening file\", http.StatusInternalServerError)\n    return\n  }\n\n  defer file.Close()\n\n  response.Header().Set(\"Content-Type\", \"application/pdf\")\n\n  io.Copy(response,\n```\n\nIn most web-servers you can have the server take care of this for you. The following function safely mounts \na configurable directory as static content using the Gorilla web framework:\n\n```go\nfunc main() {\n  var dir string\n\n  flag.StringVar(&dir, \"dir\", \".\", \"the directory to serve files from. Defaults to the current dir\")\n  flag.Parse()\n  router := mux.NewRouter()\n\n  // This will serve files under http://localhost:8000/static/<filename>\n  router.PathPrefix(\"/static/\").Handler(http.StripPrefix(\"/static/\", http.FileServer(http.Dir(dir))))\n\n  server := &http.Server{\n    Handler: router,\n    Addr:    \"127.0.0.1:8000\"\n  }\n\n  server.ListenAndServe()\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Directory Traversal in PHP\n\nAllowing direct file references through user inputs can expose your application to Directory Traversal attacks. Consider this PHP script that fetches restaurant menus:\n\n```php\n$menuDirectory = \"/var/etc/menus\";\n$fileName = $_GET['menu'];\n\nheader(\"Content-Type: application/pdf\");\nheader(\"Content-Disposition: attachment; filename={$fileName}\");\n\n$file = $menuDirectory . DIRECTORY_SEPARATOR . $fileName;\nreadfile($file);\n```\n\nHere, the menu's filename is directly taken from the query string parameter. An attacker can manipulate this parameter, using patterns like `../`, to navigate out of the intended directory and access unintended files.\n\n## Mitigation\n\n1. **Input Sanitization**: Drop any directory references within filenames\n   received from the outside:\n\n```php\n$fileName = basename($_GET['menu']);\n```\n\n2. **Opaque File References**: Instead of direct file references, consider using an array or database of approved filenames, or encode actual file references, ensuring users can't directly specify paths. \n\n:::\n\n::::\n\n## Other Considerations\n\nIf your website is handling a lot of static documents, consider using or integrating a third-party *Content Management\nSystem* (CMS). These will generate secure paths for documents as they are uploaded and allow fine-grained permissions\nto be set.\n\n## Additional information\n\n**[CWE-22](https://cwe.mitre.org/data/definitions/22.html)**\n\n**[OWASP-A5](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control)**"
                            },
                            "helpUri": "https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a5-Broken_Access_Control",
                            "id": "directory-traversal-http/a3195627657f14358fa8c5aba224b439",
                            "name": "Directory Traversal: Attacker-Controlled Data Used In File Path In Actions.py",
                            "properties": {
                                "precision": "very-high",
                                "security-severity": "9",
                                "tags": [
                                    "ng-sast",
                                    "CVSS 9",
                                    "CWE 22",
                                    "Directory Traversal",
                                    "OWASP 2021 a01-broken-access-control",
                                    "OWASP a01-2021-broken-access-control",
                                    "OWASP a5-broken-access-control"
                                ]
                            },
                            "shortDescription": {
                                "text": "Directory Traversal: Attacker-controlled Data Used in File Path in actions.py"
                            }
                        },
                        {
                            "defaultConfiguration": {
                                "enabled": true,
                                "level": "error",
                                "rank": -1
                            },
                            "fullDescription": {
                                "text": "In Pallets Jinja before 2.8.1, str.format allows a sandbox escape."
                            },
                            "help": {
                                "markdown": "In Pallets Jinja before 2.8.1, str.format allows a sandbox escape.",
                                "text": "In Pallets Jinja before 2.8.1, str.format allows a sandbox escape."
                            },
                            "helpUri": "https://cwe.mitre.org/data/definitions/134.html",
                            "id": "oss_vuln/a8d4db1b63d85dc3ec67461d3859a81f",
                            "name": "Pkg:pypi/Jinja2@2.8",
                            "properties": {
                                "precision": "very-high",
                                "security-severity": "8.6",
                                "tags": [
                                    "ng-sast",
                                    "CVE-2016-10745",
                                    "CVSS 8.6",
                                    "CWE 134",
                                    "No exploits",
                                    "Unreachable"
                                ]
                            },
                            "shortDescription": {
                                "text": "pkg:pypi/jinja2@2.8"
                            }
                        },
                        {
                            "defaultConfiguration": {
                                "enabled": true,
                                "level": "error",
                                "rank": -1
                            },
                            "fullDescription": {
                                "text": "In Pallets Jinja before 2.10.1, str.format_map allows a sandbox escape."
                            },
                            "help": {
                                "markdown": "In Pallets Jinja before 2.10.1, str.format_map allows a sandbox escape.",
                                "text": "In Pallets Jinja before 2.10.1, str.format_map allows a sandbox escape."
                            },
                            "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
                            "id": "oss_vuln/7682c1db83edf75886167646434131f3",
                            "name": "Pkg:pypi/Jinja2@2.8",
                            "properties": {
                                "precision": "very-high",
                                "security-severity": "8.6",
                                "tags": [
                                    "ng-sast",
                                    "CVE-2019-10906",
                                    "CVSS 8.6",
                                    "No exploits",
                                    "Unreachable"
                                ]
                            },
                            "shortDescription": {
                                "text": "pkg:pypi/jinja2@2.8"
                            }
                        },
                        {
                            "defaultConfiguration": {
                                "enabled": true,
                                "level": "warning",
                                "rank": -1
                            },
                            "fullDescription": {
                                "text": "Attacker-controlled data is not escaped and used in a HTTP redirect. This indicates an open redirect vulnerability. It may also allow for response splitting, session fixation or cross-site scripting attacks."
                            },
                            "help": {
                                "markdown": "Attacker-controlled data is not escaped and used in a HTTP redirect. This indicates an open redirect vulnerability. It may also allow for response splitting, session fixation or cross-site scripting attacks.\n\n# Open Redirects\n\nAn *HTTP redirect* is when a web-server returns an HTTP status code like 302 to tell the browser to make a request to a\ndifferent URL. Redirects can also be performed in client-side JavaScript code by updating the browser URL directly.\n\nRedirects are commonly used to push a user to an authentication page before viewing some protected content. In this \nscenario, the user will often be redirected again back to the original resource once they have successfully logged in. \n\nIf a redirect URL is pulled from a preceding HTTP request, you need to check the URL is safe before redirecting the\nuser. Typically, this means checking the URL is a **relative URL** to a resource hosted under your web domain. **Open \nredirects** - which allow a maliciously crafted link to redirect the user to arbitrary third-party domains - are often \nused by spammers to disguise harmful links in emails.\n\n::::tabs\n\n:::tab[Java]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Java application verifies the \nredirect URL:\n\n```java\n@Override\npublic void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String username = request.getParameter(\"username\");\n    String password = request.getParameter(\"password\");\n\n    if (!this.credentialsAreValid(username, password)) {\n        request.setAttribute(\"message\", \"Incorrect credentials\");\n        response.sendRedirect(\"/login\");\n        return;\n    }\n\n    HttpSession session = request.getSession(true);\n    session.setAttribute(\"username\", username);\n\n    String destination = request.getParameter(\"destination\");\n\n    if (destination == null || !this.isRelative(destination)) {\n        destination = \"/home\";\n    }\n\n    response.sendRedirect(destination);\n}\n\n/**\n * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\\\".\n */\nprivate boolean isRelative(String url) {\n    return url.matches(\"/[^/\\\\]?.*\");\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Angular]\n\n## Disallowing Offsite Redirects\n\nClient-side frameworks like Angular often mimic server-side redirects by using typescript logic. There are a number of \nways of doing redirects in Angular code - updating the `window.location` directly, using the browser's history API, or \nusing the `Router` module:\n\n```typescript\n/**\n * An example of how to push the user to the login page if they attempt to access a sensitive\n * route before authenticating thmeselves.\n */\nexport class AuthGuard implements CanActivate {\n  constructor(private authService: AuthService, private router: Router) {}\n\n  canActivate(next: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<true | UrlTree> {\n    \n    // Check whether the user is logged in.  \n    return this.authService.isLoggedIn().pipe(\n      map(isLoggedIn => {\n        if (!isLoggedIn) {\n            \n          // Redirect the user to the login page if they are not logged in.  \n          return this.router.parseUrl(`/login?destination=${state.url}`);\n        }\n\n        return true\n      })\n    )\n  }\n}\n```\n\nWhen performing a redirect, it is important to check that the URL you are redirecting to is a relative URL - that is, it \nstarts with a single `/` character:\n\n```typescript\nexport class LoginComponent {\n\n  // The username and password entered by the user in the login form.\n  username = '';\n  password = '';\n\n  // The destination URL to redirect the user to once they log in successfully.\n  destinationURL = '/feed'\n\n  constructor(private authService : AuthService,\n              private route       : ActivatedRoute,\n              private router      : Router) { }\n\n  ngOnInit() {\n    this.destinationURL = this.route.snapshot.queryParams['destination'] || '/feed';\n  }\n\n  onSubmit() {\n    this.authService.login(this.username, this.password)\n      .subscribe(\n        () => {\n          // After the user has lgged in, redirect them to their desired destination.\n          let url = this.destinationURL\n\n          // Confirm that the URL is a relative path - i.e. starting with a single '/' characters.\n          if (!url.match(/^\/[^\/\\\\]/)) {\n            url = '/feed'\n          }\n\n          this.router.navigate([ url ])\n        })\n  }\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[C#]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this ASP.NET login action verifies the \nredirect URL:\n\n```csharp\n[HttpPost]\n[AllowAnonymous]\n[ValidateAntiForgeryToken]\npublic async Task<ActionResult> Login(string username, string password, [FromQuery] string returnUrl)\n{\n    var result = await SignInManager.PasswordSignInAsync(username, password, true, false);\n\n    if (result.Succeeded)\n    {\n        // Make sure this a URL within our website.\n        if (Url.IsLocalUrl(returnUrl))\n        {\n            return Redirect(returnUrl);\n        }\n        \n        return RedirectToAction(\"Home\");\n    }\n    \n    return View();\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they will be \nrejected too.) \n\n:::\n\n:::tab[JavaScript]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Express application verifies the \nredirect URL:\n\n```javascript\nconst app = express()\n\napp.use(express.urlencoded())\napp.use(cookieParser('secret'))\napp.use(session({ cookie: { maxAge: 60000 }}))\napp.use(flash())\n\napp.post('/login', (request, response) => {\n  const username = request.body.username\n  const password = request.body.password\n\n  if (!usernameAndPasswordAreValid(username, password)) {\n    request.flash('message', 'Incorrect credentials')\n    response.redirect('/login')\n\n    return\n  }\n\n  // Log the user in.\n  request.session.user = username\n\n  // Check redirect URL is a relative path - otherwise just send the user to /home page.\n  const redirectURL = request.query.redirect\n\n  // Check the URL starts with a single / character.\n  if (redirectURL && redirectURL.match(/^\/[^\/\\\\]/)) {\n    response.redirect(redirectURL)\n  }\n  else {\n    response.redirect('/home')\n  }\n})\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Python]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Python application verifies the \nredirect URL:\n\n```python\n@app.route('/login', methods=['POST'])\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  user = find_user_with_password(username, password)\n\n  if not user:\n    flash('Invalid credentials', 'error')\n    return redirect('/login')\n\n  session['username'] = username\n\n  destination = request.args.get('destination')\n\n  if destination is None or not is_relative(destination):\n    destination = '/timeline'\n\n  return redirect(destination)\n\ndef is_relative(url):\n  return re.match(r\"^\/[^\/\\\\]\", url)\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[React]\n\n## Disallowing Offsite Redirects\n\nThere are a number of ways of doing redirects in React code - updating the `window.location` directly, using the \nbrowser's history API, or using the `<Redirect>` component from the `react-router` module. Whichever method you use, it \nis important to check that the URL you are redirecting to is a relative URL - that is, it starts with a single `/` \ncharacter:\n\n```jsx\n/**\n * A wrapper for <Route> that redirects to /feed if the user is authenticated.\n */\nfunction UnauthenticatedRoute(props) {\n  if (!props.loggedIn) {\n    return <Route {...props} />\n  }\n\n  // If the user has just authenticated, check the query string for their intended destination.\n  const parsed = queryString.parse(props.location.search)\n\n  let url = '/feed'\n\n  // Ensure this is a relative URL within the site (i.e. it starts with a single / character.)\n  if (parsed.destination && parsed.destination.match(/^\/[^\/\\\\]/)) {\n    url = parsed.destination\n  }\n\n  return <Redirect to={{ pathname: url }} />\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Scala]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Scala application verifies the \nredirect URL:\n\n```scala\nclass LoginController @Inject()(cc: ControllerComponents, users: UserRepository) extends AbstractController(cc) {\n\n  /**\n   * Process the response from the login page, safely checking for a redirect parameter.\n   */\n  def login = Action(parse.form(loginForm)) { request =>\n    val credentials = request.body\n\n    if (!users.credentialsAreValid(credentials.username, credentials.password)) {\n      Redirect(\"/login\").flashing(\"error\" -> \"Incorrect username or password.\")\n    }\n    else {\n      var next = request.getQueryString(\"destination\").getOrElse(\"/home\")\n\n      if (!isRelative(next)) {\n        next = \"/home\"\n      }\n\n      Redirect(next).withSession(request.session + (\"username\" -> credentials.username))\n    }\n  }\n\n  /**\n   * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\".\n   */\n  def isRelative(url : String) =  {\n    url.matches(\"/[^/\\\\]?.*\");\n  }\n\n  case class Credentials(username: String, password: String)\n\n  def loginForm = Form(\n    mapping(\n      \"username\" -> text,\n      \"password\" -> text\n    )(Credentials.apply)(Credentials.unapply)\n  )\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Go]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Go application verifies the \nredirect URL:\n\n```go\nfunc LoginHandler(response http.ResponseWriter, request *http.Request) {\n  request.ParseForm()\n\n  session, _ := session.Get(request, \"session\")\n\n  username := request.Form.Get(\"username\")\n  password := request.Form.Get(\"password\")\n\n  user := findUserWithPassword(username, password)\n\n  if user == nil {\n    http.Redirect(response, request, \"/login\", http.StatusUnauthorized)\n    return\n  }\n\n  session.Values[\"username\"] = username\n  session.Save(request, response)\n\n  destination := request.URL.Query().Get(\"destination\")\n\n  // Protect against redirect attacks by checking the destination URL starts with a single / character.\n  if destination == \"\" {\n    destination = \"/home\"\n  } else {\n    isRelative, _ := regexp.MatchString(\"^/[^/]\", destination)\n\n    if !isRelative {\n      destination = \"/home\"\n    }\n  }\n\n  http.Redirect(response, request, destination, http.StatusOK)\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[PHP]\n\n## Disallowing Offsite Redirects in PHP\n\nOpen redirects in PHP are commonly introduced when user input is improperly used in the `header` function for redirection. To securely implement redirects, always validate the user-provided URLs before using them. Here's a secure way to handle redirects:\n\n```php\n<?php\nsession_start();\n\n// Assuming some form of user authentication\n$username = $_POST['username'];\n$password = $_POST['password'];\n\nif (!credentialsAreValid($username, $password)) {\n    $_SESSION['message'] = \"Incorrect credentials\";\n    header(\"Location: /login.php\");\n    exit;\n}\n\n$_SESSION['username'] = $username;\n\n$destination = $_GET['destination'];\n\n// Check if the destination URL is a relative path\nif (!isRelativeURL($destination)) {\n    $destination = \"/home.php\";\n}\n\nheader(\"Location: \" . $destination);\nexit;\n\n/**\n * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\\\".\n */\nfunction isRelativeURL($url) {\n    return preg_match('/^\/[^\/\\\\\\\\].*/', $url);\n}\n?>\n```\n\nThe above PHP code checks if a given redirect URL is a relative path, starting with a single `/` character. URLs starting with `//` (interpreted by browsers as protocol agnostic) are also rejected to ensure safety.\n\n:::\n\n::::\n\n## Other Considerations\n\n* Redirects can happen in client-side JavaScript, too. Validate any code that updates `window.location`, to ensure the\n  URL is not taken from untrusted input.\n\n* Some sites insert *interstitial pages* when the user is leaving the site. This is a good defense against \"doppelganger\"\n  domains - websites that have a very similar domain name, that attempt to trick the user into sharing private \n  information. However, interstitial pages are a common place for open redirect vulnerabilities to occur. If you implement \n  an interstitial page that passes the URL in the query parameter, be sure to show the full URL to the user and require user\n  interaction before performing the redirect.\n\n* Social media and link-sharing sites often make use of redirects to do *click-counting*. URLs are chosen by the \n  community, then when a user clicks on the link, the click-through count is incremented, and the user is redirected to \n  their destination. In this situation, you are obligated to redirect the user to an external domains. Consider using a\n  different domain name for such a redirector that does not confer the same trust to users as your regular domain. Alternatively,\n  show a interstitial page (see previous point).\n\n* Some resources recommend checking the `Referer` or `Origin` headers in the HTTP\n  request. This is **not enough** - these may not be available for a variety of reasons:\n\n  + Links from external applications (e.g. email, messengers, PDF readers, Word\n    documents, ...) never have such headers\n\n  + External web sites can redirect through e.g. `data:` or `blob:` URLs or use\n    the `sandbox` attribute on iframes to prevent the browser from sending the\n    `Referer` or `Origin` headers.\n\n  + Various browser settings, firewalls and other privacy software can suppress\n    the submission of these headers.\n\n## Additional information\n\n**[CWE-601](https://cwe.mitre.org/data/definitions/601.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**",
                                "text": "Attacker-controlled data is not escaped and used in a HTTP redirect. This indicates an open redirect vulnerability. It may also allow for response splitting, session fixation or cross-site scripting attacks.\n\n# Open Redirects\n\nAn *HTTP redirect* is when a web-server returns an HTTP status code like 302 to tell the browser to make a request to a\ndifferent URL. Redirects can also be performed in client-side JavaScript code by updating the browser URL directly.\n\nRedirects are commonly used to push a user to an authentication page before viewing some protected content. In this \nscenario, the user will often be redirected again back to the original resource once they have successfully logged in. \n\nIf a redirect URL is pulled from a preceding HTTP request, you need to check the URL is safe before redirecting the\nuser. Typically, this means checking the URL is a **relative URL** to a resource hosted under your web domain. **Open \nredirects** - which allow a maliciously crafted link to redirect the user to arbitrary third-party domains - are often \nused by spammers to disguise harmful links in emails.\n\n::::tabs\n\n:::tab[Java]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Java application verifies the \nredirect URL:\n\n```java\n@Override\npublic void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String username = request.getParameter(\"username\");\n    String password = request.getParameter(\"password\");\n\n    if (!this.credentialsAreValid(username, password)) {\n        request.setAttribute(\"message\", \"Incorrect credentials\");\n        response.sendRedirect(\"/login\");\n        return;\n    }\n\n    HttpSession session = request.getSession(true);\n    session.setAttribute(\"username\", username);\n\n    String destination = request.getParameter(\"destination\");\n\n    if (destination == null || !this.isRelative(destination)) {\n        destination = \"/home\";\n    }\n\n    response.sendRedirect(destination);\n}\n\n/**\n * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\\\".\n */\nprivate boolean isRelative(String url) {\n    return url.matches(\"/[^/\\\\]?.*\");\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Angular]\n\n## Disallowing Offsite Redirects\n\nClient-side frameworks like Angular often mimic server-side redirects by using typescript logic. There are a number of \nways of doing redirects in Angular code - updating the `window.location` directly, using the browser's history API, or \nusing the `Router` module:\n\n```typescript\n/**\n * An example of how to push the user to the login page if they attempt to access a sensitive\n * route before authenticating thmeselves.\n */\nexport class AuthGuard implements CanActivate {\n  constructor(private authService: AuthService, private router: Router) {}\n\n  canActivate(next: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<true | UrlTree> {\n    \n    // Check whether the user is logged in.  \n    return this.authService.isLoggedIn().pipe(\n      map(isLoggedIn => {\n        if (!isLoggedIn) {\n            \n          // Redirect the user to the login page if they are not logged in.  \n          return this.router.parseUrl(`/login?destination=${state.url}`);\n        }\n\n        return true\n      })\n    )\n  }\n}\n```\n\nWhen performing a redirect, it is important to check that the URL you are redirecting to is a relative URL - that is, it \nstarts with a single `/` character:\n\n```typescript\nexport class LoginComponent {\n\n  // The username and password entered by the user in the login form.\n  username = '';\n  password = '';\n\n  // The destination URL to redirect the user to once they log in successfully.\n  destinationURL = '/feed'\n\n  constructor(private authService : AuthService,\n              private route       : ActivatedRoute,\n              private router      : Router) { }\n\n  ngOnInit() {\n    this.destinationURL = this.route.snapshot.queryParams['destination'] || '/feed';\n  }\n\n  onSubmit() {\n    this.authService.login(this.username, this.password)\n      .subscribe(\n        () => {\n          // After the user has lgged in, redirect them to their desired destination.\n          let url = this.destinationURL\n\n          // Confirm that the URL is a relative path - i.e. starting with a single '/' characters.\n          if (!url.match(/^\/[^\/\\\\]/)) {\n            url = '/feed'\n          }\n\n          this.router.navigate([ url ])\n        })\n  }\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[C#]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this ASP.NET login action verifies the \nredirect URL:\n\n```csharp\n[HttpPost]\n[AllowAnonymous]\n[ValidateAntiForgeryToken]\npublic async Task<ActionResult> Login(string username, string password, [FromQuery] string returnUrl)\n{\n    var result = await SignInManager.PasswordSignInAsync(username, password, true, false);\n\n    if (result.Succeeded)\n    {\n        // Make sure this a URL within our website.\n        if (Url.IsLocalUrl(returnUrl))\n        {\n            return Redirect(returnUrl);\n        }\n        \n        return RedirectToAction(\"Home\");\n    }\n    \n    return View();\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they will be \nrejected too.) \n\n:::\n\n:::tab[JavaScript]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Express application verifies the \nredirect URL:\n\n```javascript\nconst app = express()\n\napp.use(express.urlencoded())\napp.use(cookieParser('secret'))\napp.use(session({ cookie: { maxAge: 60000 }}))\napp.use(flash())\n\napp.post('/login', (request, response) => {\n  const username = request.body.username\n  const password = request.body.password\n\n  if (!usernameAndPasswordAreValid(username, password)) {\n    request.flash('message', 'Incorrect credentials')\n    response.redirect('/login')\n\n    return\n  }\n\n  // Log the user in.\n  request.session.user = username\n\n  // Check redirect URL is a relative path - otherwise just send the user to /home page.\n  const redirectURL = request.query.redirect\n\n  // Check the URL starts with a single / character.\n  if (redirectURL && redirectURL.match(/^\/[^\/\\\\]/)) {\n    response.redirect(redirectURL)\n  }\n  else {\n    response.redirect('/home')\n  }\n})\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Python]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Python application verifies the \nredirect URL:\n\n```python\n@app.route('/login', methods=['POST'])\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  user = find_user_with_password(username, password)\n\n  if not user:\n    flash('Invalid credentials', 'error')\n    return redirect('/login')\n\n  session['username'] = username\n\n  destination = request.args.get('destination')\n\n  if destination is None or not is_relative(destination):\n    destination = '/timeline'\n\n  return redirect(destination)\n\ndef is_relative(url):\n  return re.match(r\"^\/[^\/\\\\]\", url)\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[React]\n\n## Disallowing Offsite Redirects\n\nThere are a number of ways of doing redirects in React code - updating the `window.location` directly, using the \nbrowser's history API, or using the `<Redirect>` component from the `react-router` module. Whichever method you use, it \nis important to check that the URL you are redirecting to is a relative URL - that is, it starts with a single `/` \ncharacter:\n\n```jsx\n/**\n * A wrapper for <Route> that redirects to /feed if the user is authenticated.\n */\nfunction UnauthenticatedRoute(props) {\n  if (!props.loggedIn) {\n    return <Route {...props} />\n  }\n\n  // If the user has just authenticated, check the query string for their intended destination.\n  const parsed = queryString.parse(props.location.search)\n\n  let url = '/feed'\n\n  // Ensure this is a relative URL within the site (i.e. it starts with a single / character.)\n  if (parsed.destination && parsed.destination.match(/^\/[^\/\\\\]/)) {\n    url = parsed.destination\n  }\n\n  return <Redirect to={{ pathname: url }} />\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Scala]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Scala application verifies the \nredirect URL:\n\n```scala\nclass LoginController @Inject()(cc: ControllerComponents, users: UserRepository) extends AbstractController(cc) {\n\n  /**\n   * Process the response from the login page, safely checking for a redirect parameter.\n   */\n  def login = Action(parse.form(loginForm)) { request =>\n    val credentials = request.body\n\n    if (!users.credentialsAreValid(credentials.username, credentials.password)) {\n      Redirect(\"/login\").flashing(\"error\" -> \"Incorrect username or password.\")\n    }\n    else {\n      var next = request.getQueryString(\"destination\").getOrElse(\"/home\")\n\n      if (!isRelative(next)) {\n        next = \"/home\"\n      }\n\n      Redirect(next).withSession(request.session + (\"username\" -> credentials.username))\n    }\n  }\n\n  /**\n   * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\".\n   */\n  def isRelative(url : String) =  {\n    url.matches(\"/[^/\\\\]?.*\");\n  }\n\n  case class Credentials(username: String, password: String)\n\n  def loginForm = Form(\n    mapping(\n      \"username\" -> text,\n      \"password\" -> text\n    )(Credentials.apply)(Credentials.unapply)\n  )\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Go]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Go application verifies the \nredirect URL:\n\n```go\nfunc LoginHandler(response http.ResponseWriter, request *http.Request) {\n  request.ParseForm()\n\n  session, _ := session.Get(request, \"session\")\n\n  username := request.Form.Get(\"username\")\n  password := request.Form.Get(\"password\")\n\n  user := findUserWithPassword(username, password)\n\n  if user == nil {\n    http.Redirect(response, request, \"/login\", http.StatusUnauthorized)\n    return\n  }\n\n  session.Values[\"username\"] = username\n  session.Save(request, response)\n\n  destination := request.URL.Query().Get(\"destination\")\n\n  // Protect against redirect attacks by checking the destination URL starts with a single / character.\n  if destination == \"\" {\n    destination = \"/home\"\n  } else {\n    isRelative, _ := regexp.MatchString(\"^/[^/]\", destination)\n\n    if !isRelative {\n      destination = \"/home\"\n    }\n  }\n\n  http.Redirect(response, request, destination, http.StatusOK)\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[PHP]\n\n## Disallowing Offsite Redirects in PHP\n\nOpen redirects in PHP are commonly introduced when user input is improperly used in the `header` function for redirection. To securely implement redirects, always validate the user-provided URLs before using them. Here's a secure way to handle redirects:\n\n```php\n<?php\nsession_start();\n\n// Assuming some form of user authentication\n$username = $_POST['username'];\n$password = $_POST['password'];\n\nif (!credentialsAreValid($username, $password)) {\n    $_SESSION['message'] = \"Incorrect credentials\";\n    header(\"Location: /login.php\");\n    exit;\n}\n\n$_SESSION['username'] = $username;\n\n$destination = $_GET['destination'];\n\n// Check if the destination URL is a relative path\nif (!isRelativeURL($destination)) {\n    $destination = \"/home.php\";\n}\n\nheader(\"Location: \" . $destination);\nexit;\n\n/**\n * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\\\".\n */\nfunction isRelativeURL($url) {\n    return preg_match('/^\/[^\/\\\\\\\\].*/', $url);\n}\n?>\n```\n\nThe above PHP code checks if a given redirect URL is a relative path, starting with a single `/` character. URLs starting with `//` (interpreted by browsers as protocol agnostic) are also rejected to ensure safety.\n\n:::\n\n::::\n\n## Other Considerations\n\n* Redirects can happen in client-side JavaScript, too. Validate any code that updates `window.location`, to ensure the\n  URL is not taken from untrusted input.\n\n* Some sites insert *interstitial pages* when the user is leaving the site. This is a good defense against \"doppelganger\"\n  domains - websites that have a very similar domain name, that attempt to trick the user into sharing private \n  information. However, interstitial pages are a common place for open redirect vulnerabilities to occur. If you implement \n  an interstitial page that passes the URL in the query parameter, be sure to show the full URL to the user and require user\n  interaction before performing the redirect.\n\n* Social media and link-sharing sites often make use of redirects to do *click-counting*. URLs are chosen by the \n  community, then when a user clicks on the link, the click-through count is incremented, and the user is redirected to \n  their destination. In this situation, you are obligated to redirect the user to an external domains. Consider using a\n  different domain name for such a redirector that does not confer the same trust to users as your regular domain. Alternatively,\n  show a interstitial page (see previous point).\n\n* Some resources recommend checking the `Referer` or `Origin` headers in the HTTP\n  request. This is **not enough** - these may not be available for a variety of reasons:\n\n  + Links from external applications (e.g. email, messengers, PDF readers, Word\n    documents, ...) never have such headers\n\n  + External web sites can redirect through e.g. `data:` or `blob:` URLs or use\n    the `sandbox` attribute on iframes to prevent the browser from sending the\n    `Referer` or `Origin` headers.\n\n  + Various browser settings, firewalls and other privacy software can suppress\n    the submission of these headers.\n\n## Additional information\n\n**[CWE-601](https://cwe.mitre.org/data/definitions/601.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**"
                            },
                            "helpUri": "https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a1-Injection",
                            "id": "open-redirect/1c93408c9984ae6d7ea9bdc09ae65957",
                            "name": "Open Redirect: Attacker-Controlled Data Is Used In Http Redirects In Auth.py",
                            "properties": {
                                "precision": "very-high",
                                "security-severity": "4",
                                "tags": [
                                    "ng-sast",
                                    "CVSS 4",
                                    "CWE 601",
                                    "OWASP 2021 a01-broken-access-control",
                                    "OWASP a01-2021-broken-access-control",
                                    "OWASP a1-injection",
                                    "Open Redirect"
                                ]
                            },
                            "shortDescription": {
                                "text": "Open Redirect: Attacker-Controlled Data is Used in HTTP Redirects in auth.py"
                            }
                        },
                        {
                            "defaultConfiguration": {
                                "enabled": true,
                                "level": "warning",
                                "rank": -1
                            },
                            "fullDescription": {
                                "text": "Attacker-controlled data is used in a shell command without undergoing escaping or validation. This indicates a command injection vulnerability."
                            },
                            "help": {
                                "markdown": "Attacker-controlled data is used in a shell command without undergoing escaping or validation. This indicates a command injection vulnerability.\n\n# Remote Code Execution\n\nA **remote code execution** (RCE) vulnerability allows an attacker to execute arbitrary code on you server. On a\nweb-server, RCE vulnerabilities are typically cause when untrusted input from the HTTP request is evaluated as code.\n\n::::tabs\n\n:::tab[Java]\n\n## Remote Code Execution in Java\n\nDynamic evaluation of code in Java can be achieved in a number of ways. The Java scripting API (defined in the\n`javax.script` page) package allows you to evaluate code in a number of different scripting languages via the \n`ScriptEngineManager` class. There are, for instance, JVM compatible versions of Python (called Jython) and Ruby (called\nJRuby) that can be loaded as jars and invoked via the script manager.\n\nThe Java compiler can also be invoked programmatically via the `javax.tools.JavaCompiler` interface. This approach is\noften used by build tools, which convert files on disk to runnable code that can be loaded into the JVM.\n\nFinally, there are a number of other tools that allow dynamic evaluation of code. The Apache Bean Scripting Framework\na range of scripting languages, and the scripting languages like Groovy can be added to the Java runtime by simply\nadding a jar in the classpath.\n\nWith all of these approaches, it is of vital importance that you only pass trusted code to the scripting API. Passing \nuntrusted content to the `ScriptingEngine` class, for instance,  will allow an attacker to execute arbitrary code in \nyour Java Virtual Machine - meaning they can steal sensitive information, read files from disk, or install malware.\n\nTo secure your code, you should ensure any strings passed to a scripting engine are taken from a trusted source, or \nvalidated against an allow-list:\n\n```java\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException \n{\n  String code = request.getParameter(\"script\");\n\n  // Since we are taking the code to execute from an untrusted source (the HTTP\n  // request) we *must* validate against an allowed list of scripts.      \n  if (!allowedCommands.contains(code))\n    throw new IOException(\"Not permitted\");\n\n  ScriptEngineManager manager = new ScriptEngineManager();\n  ScriptEngine        engine  = manager.getEngineByName(\"JavaScript\");\n  engine.eval(input);\n  \n  response.setStatus(200);\n}\n```\n\n## Further Considerations\n\nDynamic code evaluation is often used where there is a need to develop a *Domain Specific Language* (DSL) for expert \nusers. In such a scenario, it is preferable to execute DSL statements in a sandbox with limited permissions. (For\ninstance, you probably want to limit disk and network access if you are simply evaluating mathematical statements.) One\nway to achieve this is by formally defining the grammar of the DSL, and using a tool like Java Compiler Compiler (JavaCC)\nor ANTLR to generate a parser that can evaluate scripts at runtime. Since the grammar specification defines which\nfunctions are executable, you have full control over what the DSL can do.\n\n:::\n\n:::tab[C#]\n\n## Remote Code Execution in C#\n\nC# code can be evaluated dynamically using the Code Document Object Model (CodeDOM) module, defined in the \n`System.CodeDom` namespace. CodeDOM allows for templated code generation and dynamic compilation within the .NET \nruntime.\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your C# runtime -\nmeaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to using the CodeDOM module in applications that face\nthe internet.\n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in .NET, consider using one of\nthe following solutions:\n\n* Microsoft's DSL Tools, that come bundled with Visual Studio and allow the visual creation of DSLs.\n* A scripting language like Lua that can be dynamically loaded and executed within the .NET runtime.\n* ANTLR, a parser generator that can be used to generate and execute sand-boxed languages.\n\n:::\n\n:::tab[JavaScript]\n\n## Remote Code Execution in JavaScript Using Eval\n\nJavaScript makes dynamic evaluation of strings as code very easy by making the `eval(...)` function available. For\ninstance, the following JavaScript code will print \"WARNING\" to the console:\n\n```javascript\n  eval(\"console.log('WARNING')\")\n```\n\nIf an attacker is able to control the input to an `eval(...)` call by passing it in an HTTP request, they can run code\non your server. This will allow them to scan your file system, install a remote shell, and take over your server \ncompletely.\n\n## Other Types of Remote Code Execution in JavaScript\n\nInput strings can also be dynamically evaluated as code in the JavaScript runtime using the `Function(...)` or\n`Script(...)` constructors. There are various subtle ways of doing this, as illustrated by the following code:\n\n```javascript\nconst arbitraryObject = {},\n      a = 'constructor',\n      b = 'constructor',\n      s = 'console.log(\"Hacked!\")';\n\n// This will print the phrase 'Hacked!' to the console.\narbitraryObject[a][b](s)()\n```\n\nThese two lines of code illustrate an RCE vulnerability. Properties can be looked up on a JavaScript object by name, \nand this includes functions. The illustrated exploit gets the constructor function for an arbitrary object, looks up \nrhe constructor function for the constructor (which is actually `Function(...)`), passes it a command string, then \nexecutes that string. \n\nAlthough this example is contrived, it illustrates how any code that has the form:\n\n```javascript\narbitraryObject[parameterA][parameterB](parameterC)()\n```\n\n...enables a remote execution attack if all the parameters can be controlled by an attacker.\n\n## Mitigation\n\n* Don't use the `eval(...)` function in your code. Check your codebase with a linter as part of your build process.\n* Consider disabling use of `eval(...)` in the Node.js runtime by passing the `--disallow-code-generation-from-strings`\n  at startup. (You will have to ensure none of your dependencies use the `eval(...)` function to do this.)\n* Validate all untrusted input with allow-lists: check any input take from the HTTP request is safe before processing \n  it.\n* If you make nested lookups on objects, make assertions about object types when pulling them from another object. If\n  your code finds a function where it expects a string, don't invoke it!\n\n:::\n\n:::tab[Python]\n\n## Remote Code Execution in Python\n\nPython code can be evaluated dynamically using the global `eval(...)` and `exec(...)` functions. The former expects\na string representing a (single) valid Python expression, while the later can execute multiple expressions - making it \nable to create new module, class, and function definitions. Both functions have access to the global and local state\nat the point of invocation.\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your Python runtime -\nmeaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to avoid `eval(...)` and `exec(...)` functions of Python \naltogether. \n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Python, consider using the \n`ast` (*Abstract Syntax Tree*) module, which allows you to parse expressions and evaluate each node atomically. This will\nhelp you \"sandbox\" the functions a user can invoke, removing the risks of arbitrary code execution.\n\nHere's a simple example of a DSL that can evaluate mathematical expressions:\n\n```python\nimport ast, operator, math\n\ndef safe_eval(expression):\n  \"\"\"Evaluate a simple mathematical function by parsing an expression into an\n  abstract syntax tree and safely evaluating each node in turn.\"\"\"\n\n  def find_math_function(x, *args):\n    if x not in [x for x in dir(math) if not \"__\" in x]:\n      raise SyntaxError(f\"Unknown function {x}()\")\n\n    return getattr(math, x)\n\n  binary_operations = {\n    ast.Add:   operator.add,\n    ast.Sub:   operator.sub,\n    ast.Mult:  operator.mul,\n    ast.Div:   operator.truediv,\n    ast.Mod:   operator.mod,\n    ast.Pow:   operator.pow,\n    ast.Call:  find_math_function,\n    ast.BinOp: ast.BinOp,\n  }\n\n  unary_operations = {\n    ast.USub:    operator.neg,\n    ast.UAdd:    operator.pos,\n    ast.UnaryOp: ast.UnaryOp,\n  }\n\n  operations = tuple(binary_operations) + tuple(unary_operations)\n\n  syntax_tree = ast.parse(expression, mode='eval')\n\n  def _eval(node):\n    if isinstance(node, ast.Expression):\n      return _eval(node.body)\n    elif isinstance(node, ast.Str):\n      return node.s\n    elif isinstance(node, ast.Num):\n      return node.value\n    elif isinstance(node, ast.Constant):\n      return node.value\n    elif isinstance(node, ast.BinOp):\n      if isinstance(node.left, operations):\n        left = _eval(node.left)\n      else:\n        left = node.left.value\n      if isinstance(node.right, operations):\n        right = _eval(node.right)\n      else:\n        right = node.right.value\n      return binary_operations[type(node.op)](left, right)\n    elif isinstance(node, ast.UnaryOp):\n      if isinstance(node.operand, operations):\n        operand = _eval(node.operand)\n      else:\n        operand = node.operand.value\n      return unary_operations[type(node.op)](operand)\n    elif isinstance(node, ast.Call):\n      args = [_eval(x) for x in node.args]\n      function = find_math_function(node.func.id)\n      return function(*args)\n    else:\n      raise SyntaxError(f\"Bad syntax, {type(node)}\")\n\n  return _eval(syntax_tree)\n\nsafe_eval(\"1 + 1\")       # Will return 2\nsafe_eval(\"(100*10)+6\")  # Will return 1006\nsafe_eval(\"sqrt(16)+1\")  # Will return 5.0\n```\n\n:::\n\n:::tab[Scala]\n\n## Remote Code Execution in Scala\n\nScala code can be evaluated dynamically using the `scala-lang` package, that will generate bytecode objects to be loaded \ninto the underlying Java Virtual Machine. The following web-application takes a scriptlet from an HTTP parameter and\nevaluates the result:\n\n```scala\ncase class Scriptlet(code: String)\n\ndef scriptExecutionForm = Form(\n  mapping(\n    \"code\" -> text\n  )(Scriptlet.apply)(Scriptlet.unapply)\n)\n\ndef evaluateScript = Action(parse.form(scriptExecutionForm)) { request =>\n  val settings = new Settings\n\n  settings.usejavacp.value   = true\n  settings.deprecation.value = true\n\n  val eval      = new IMain(settings)\n  val evaluated = eval.interpret(request.body.code)\n\n  if (evaluated == Success) {\n    val result = eval.valueOfTerm(\"result\").get.asInstanceOf[String]\n    Ok(result)\n  }\n  else {\n    Status(488)(\"Unable to evaluate this code\")\n  }\n}\n```\n\nAnother common method of achieving dynamic execution in Scala is by using reflection:\n\n```scala\nimport scala.reflect.runtime.universe\nimport scala.tools.reflect.ToolBox\n\nval toolbox = universe.runtimeMirror(getClass.getClassLoader).mkToolBox()\ntoolbox.eval(toolbox.parse(\"\"\"println(\"Hello world\")\"\"\"))\n```\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your Java Virtual \nMachine - meaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to avoid using dynamic evaluation of Scala altogether. \n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Scala, consider using a\ntoolkit like the Scala Standard Parser Combinator Library, which allows you to write parsers that will \"sandbox\" the \nfunctions a user can invoke, removing the risks of arbitrary code execution.\n\nThe `math-expression-parser` library is good example of a well-scoped DSL that allows evaluation of simple arithmetic\nexpressions:\n\n```scala\nimport io.github.facaiy.math.expression.MathExp\n\nval expressionString = \"1.0 + sqrt(2 * $a1) + $a2 ** 2\"\nval parsedExpression = MathExp.parse(expressionString)\nval inputVariables   = Map(\"a1\" -> 2, \"a2\" -> 1)\n\n// This will return the value \"4.0\", by evaluating the expression with the supplied input variables.\nval output = parsedExpression.eval(inputVariables)\n```\n\n:::\n\n:::tab[Go]\n\n## Remote Code Execution in Go\n\nDynamic execution of Go is relatively rare. The Go playground (https://go.dev/play/) allows you to run Go code from a\nweb browser, and achieves this by dynamically compiling code using the Go toolchain, and executing the compiled code in\na sandbox on a remote server.\n\nMore common is the use of packages like `net/rpc` or `grpc` to allow remote invocation of individual methods across a \nnetwork. This allows a development team to build efficient, distributed micro-services.\n\nTo mitigate remote code execution attacks in a distributed computing environment, you must ensure any procedure calls \ncome from a trusted source. With `grpc` this can be achieved using Application Layer Transport Security (ALTS), a mutual \nauthentication and transport developed by Google:\n\n```go\nimport (\n  \"google.golang.org/grpc\"\n  \"google.golang.org/grpc/credentials/alts\"\n)\n\naltsTC          := alts.NewClientCreds(alts.DefaultClientOptions())\nconnection, err := grpc.Dial(serverAddr, grpc.WithTransportCredentials(altsTC))\n```\n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Go, consider using an \nembeddable scripting language like Lua:\n\n```go\nimport (\n  \"github.com/yuin/gopher-lua\"\n)\n\nfunc main() {\n  // Instantiate a Lua sandbox.\n  sandbox := lua.NewState()\n  \n  defer sandbox.Close()\n  \n  // Dynamically execute a string as Lua code.\n  if err := sandbox.DoString(`print(\"hello\")`); err != nil {\n    panic(err)\n  }\n}\n```\n\nThis example will execute the simple Lua expression `print(\"hello\")`. Using a Lua sandbox in this fashion will allow you \nto execute dynamic expressions passed by a user safely - simply pass the expression to the `sandbox.DoString(...)` \nfunction to execute it. The executed code will *only* be able to access state you pass to the sandbox via the \n`sandbox.SetField(...)` function, closing any security loopholes associated with remote code execution.\n\n:::\n\n:::tab[PHP]\n\n## Remote Code Execution in PHP\n\nPHP provides several functions that allow for the execution of system commands and the evaluation of code dynamically. Some commonly used functions for this purpose include `eval()`, `system()`, `exec()`, `passthru()`, `shell_exec()`, and others.\n\nThis vulnerability arises when developers use these functions without properly validating or sanitizing user inputs. This can allow an attacker to inject and execute arbitrary code on the server.\n\nConsider the following PHP snippet, which takes a script input from an HTTP request and evaluates it:\n\n```php\n<?php\n$script = $_GET['script'];\n\n// Using the eval function directly on unsanitized input poses a severe security risk.\n// An attacker can provide a malicious PHP code as a value for the \"script\" parameter and execute it.\neval($script);\n\necho \"Script executed successfully!\";\n?>\n```\n\nBy visiting a URL like `http://example.com/vulnerable.php?script=system('ls');` an attacker could execute the `ls` command, and with more malicious intent, they can cause significant harm.\n\n## Mitigation\n\nTo secure your code, ensure that strings passed to evaluation or execution functions are from trusted sources, or are validated against an allow-list:\n\n```php\n<?php\n$allowedScripts = ['print_hello' => 'echo \"Hello, World!\";'];\n\n$scriptKey = $_GET['scriptKey'];\n\n// Validate against an allow-list of scripts.\nif (!array_key_exists($scriptKey, $allowedScripts)) {\n    die(\"Not permitted\");\n}\n\neval($allowedScripts[$scriptKey]);\n\necho \"Script executed successfully!\";\n?>\n```\n\n## Further Considerations\n\nDynamic code evaluation in PHP should be used with extreme caution. Whenever possible, avoid using functions like `eval()` altogether. If dynamic functionality is needed, consider more secure alternatives like creating pre-defined safe functions or adopting a Domain-Specific Language (DSL) with strict parsing and validation. Always use PHP's built-in functions to sanitize and validate all user inputs to prevent code injections.\n\n:::\n\n::::\n\n## CWEs\n\n**[CWE-77](https://cwe.mitre.org/data/definitions/77.html)**\n\n**[CWE-78](https://cwe.mitre.org/data/definitions/78.html)**\n\n**[CWE-94](https://cwe.mitre.org/data/definitions/94.html)**\n\n**[CWE-917](https://cwe.mitre.org/data/definitions/917.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**",
                                "text": "Attacker-controlled data is used in a shell command without undergoing escaping or validation. This indicates a command injection vulnerability.\n\n# Remote Code Execution\n\nA **remote code execution** (RCE) vulnerability allows an attacker to execute arbitrary code on you server. On a\nweb-server, RCE vulnerabilities are typically cause when untrusted input from the HTTP request is evaluated as code.\n\n::::tabs\n\n:::tab[Java]\n\n## Remote Code Execution in Java\n\nDynamic evaluation of code in Java can be achieved in a number of ways. The Java scripting API (defined in the\n`javax.script` page) package allows you to evaluate code in a number of different scripting languages via the \n`ScriptEngineManager` class. There are, for instance, JVM compatible versions of Python (called Jython) and Ruby (called\nJRuby) that can be loaded as jars and invoked via the script manager.\n\nThe Java compiler can also be invoked programmatically via the `javax.tools.JavaCompiler` interface. This approach is\noften used by build tools, which convert files on disk to runnable code that can be loaded into the JVM.\n\nFinally, there are a number of other tools that allow dynamic evaluation of code. The Apache Bean Scripting Framework\na range of scripting languages, and the scripting languages like Groovy can be added to the Java runtime by simply\nadding a jar in the classpath.\n\nWith all of these approaches, it is of vital importance that you only pass trusted code to the scripting API. Passing \nuntrusted content to the `ScriptingEngine` class, for instance,  will allow an attacker to execute arbitrary code in \nyour Java Virtual Machine - meaning they can steal sensitive information, read files from disk, or install malware.\n\nTo secure your code, you should ensure any strings passed to a scripting engine are taken from a trusted source, or \nvalidated against an allow-list:\n\n```java\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException \n{\n  String code = request.getParameter(\"script\");\n\n  // Since we are taking the code to execute from an untrusted source (the HTTP\n  // request) we *must* validate against an allowed list of scripts.      \n  if (!allowedCommands.contains(code))\n    throw new IOException(\"Not permitted\");\n\n  ScriptEngineManager manager = new ScriptEngineManager();\n  ScriptEngine        engine  = manager.getEngineByName(\"JavaScript\");\n  engine.eval(input);\n  \n  response.setStatus(200);\n}\n```\n\n## Further Considerations\n\nDynamic code evaluation is often used where there is a need to develop a *Domain Specific Language* (DSL) for expert \nusers. In such a scenario, it is preferable to execute DSL statements in a sandbox with limited permissions. (For\ninstance, you probably want to limit disk and network access if you are simply evaluating mathematical statements.) One\nway to achieve this is by formally defining the grammar of the DSL, and using a tool like Java Compiler Compiler (JavaCC)\nor ANTLR to generate a parser that can evaluate scripts at runtime. Since the grammar specification defines which\nfunctions are executable, you have full control over what the DSL can do.\n\n:::\n\n:::tab[C#]\n\n## Remote Code Execution in C#\n\nC# code can be evaluated dynamically using the Code Document Object Model (CodeDOM) module, defined in the \n`System.CodeDom` namespace. CodeDOM allows for templated code generation and dynamic compilation within the .NET \nruntime.\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your C# runtime -\nmeaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to using the CodeDOM module in applications that face\nthe internet.\n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in .NET, consider using one of\nthe following solutions:\n\n* Microsoft's DSL Tools, that come bundled with Visual Studio and allow the visual creation of DSLs.\n* A scripting language like Lua that can be dynamically loaded and executed within the .NET runtime.\n* ANTLR, a parser generator that can be used to generate and execute sand-boxed languages.\n\n:::\n\n:::tab[JavaScript]\n\n## Remote Code Execution in JavaScript Using Eval\n\nJavaScript makes dynamic evaluation of strings as code very easy by making the `eval(...)` function available. For\ninstance, the following JavaScript code will print \"WARNING\" to the console:\n\n```javascript\n  eval(\"console.log('WARNING')\")\n```\n\nIf an attacker is able to control the input to an `eval(...)` call by passing it in an HTTP request, they can run code\non your server. This will allow them to scan your file system, install a remote shell, and take over your server \ncompletely.\n\n## Other Types of Remote Code Execution in JavaScript\n\nInput strings can also be dynamically evaluated as code in the JavaScript runtime using the `Function(...)` or\n`Script(...)` constructors. There are various subtle ways of doing this, as illustrated by the following code:\n\n```javascript\nconst arbitraryObject = {},\n      a = 'constructor',\n      b = 'constructor',\n      s = 'console.log(\"Hacked!\")';\n\n// This will print the phrase 'Hacked!' to the console.\narbitraryObject[a][b](s)()\n```\n\nThese two lines of code illustrate an RCE vulnerability. Properties can be looked up on a JavaScript object by name, \nand this includes functions. The illustrated exploit gets the constructor function for an arbitrary object, looks up \nrhe constructor function for the constructor (which is actually `Function(...)`), passes it a command string, then \nexecutes that string. \n\nAlthough this example is contrived, it illustrates how any code that has the form:\n\n```javascript\narbitraryObject[parameterA][parameterB](parameterC)()\n```\n\n...enables a remote execution attack if all the parameters can be controlled by an attacker.\n\n## Mitigation\n\n* Don't use the `eval(...)` function in your code. Check your codebase with a linter as part of your build process.\n* Consider disabling use of `eval(...)` in the Node.js runtime by passing the `--disallow-code-generation-from-strings`\n  at startup. (You will have to ensure none of your dependencies use the `eval(...)` function to do this.)\n* Validate all untrusted input with allow-lists: check any input take from the HTTP request is safe before processing \n  it.\n* If you make nested lookups on objects, make assertions about object types when pulling them from another object. If\n  your code finds a function where it expects a string, don't invoke it!\n\n:::\n\n:::tab[Python]\n\n## Remote Code Execution in Python\n\nPython code can be evaluated dynamically using the global `eval(...)` and `exec(...)` functions. The former expects\na string representing a (single) valid Python expression, while the later can execute multiple expressions - making it \nable to create new module, class, and function definitions. Both functions have access to the global and local state\nat the point of invocation.\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your Python runtime -\nmeaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to avoid `eval(...)` and `exec(...)` functions of Python \naltogether. \n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Python, consider using the \n`ast` (*Abstract Syntax Tree*) module, which allows you to parse expressions and evaluate each node atomically. This will\nhelp you \"sandbox\" the functions a user can invoke, removing the risks of arbitrary code execution.\n\nHere's a simple example of a DSL that can evaluate mathematical expressions:\n\n```python\nimport ast, operator, math\n\ndef safe_eval(expression):\n  \"\"\"Evaluate a simple mathematical function by parsing an expression into an\n  abstract syntax tree and safely evaluating each node in turn.\"\"\"\n\n  def find_math_function(x, *args):\n    if x not in [x for x in dir(math) if not \"__\" in x]:\n      raise SyntaxError(f\"Unknown function {x}()\")\n\n    return getattr(math, x)\n\n  binary_operations = {\n    ast.Add:   operator.add,\n    ast.Sub:   operator.sub,\n    ast.Mult:  operator.mul,\n    ast.Div:   operator.truediv,\n    ast.Mod:   operator.mod,\n    ast.Pow:   operator.pow,\n    ast.Call:  find_math_function,\n    ast.BinOp: ast.BinOp,\n  }\n\n  unary_operations = {\n    ast.USub:    operator.neg,\n    ast.UAdd:    operator.pos,\n    ast.UnaryOp: ast.UnaryOp,\n  }\n\n  operations = tuple(binary_operations) + tuple(unary_operations)\n\n  syntax_tree = ast.parse(expression, mode='eval')\n\n  def _eval(node):\n    if isinstance(node, ast.Expression):\n      return _eval(node.body)\n    elif isinstance(node, ast.Str):\n      return node.s\n    elif isinstance(node, ast.Num):\n      return node.value\n    elif isinstance(node, ast.Constant):\n      return node.value\n    elif isinstance(node, ast.BinOp):\n      if isinstance(node.left, operations):\n        left = _eval(node.left)\n      else:\n        left = node.left.value\n      if isinstance(node.right, operations):\n        right = _eval(node.right)\n      else:\n        right = node.right.value\n      return binary_operations[type(node.op)](left, right)\n    elif isinstance(node, ast.UnaryOp):\n      if isinstance(node.operand, operations):\n        operand = _eval(node.operand)\n      else:\n        operand = node.operand.value\n      return unary_operations[type(node.op)](operand)\n    elif isinstance(node, ast.Call):\n      args = [_eval(x) for x in node.args]\n      function = find_math_function(node.func.id)\n      return function(*args)\n    else:\n      raise SyntaxError(f\"Bad syntax, {type(node)}\")\n\n  return _eval(syntax_tree)\n\nsafe_eval(\"1 + 1\")       # Will return 2\nsafe_eval(\"(100*10)+6\")  # Will return 1006\nsafe_eval(\"sqrt(16)+1\")  # Will return 5.0\n```\n\n:::\n\n:::tab[Scala]\n\n## Remote Code Execution in Scala\n\nScala code can be evaluated dynamically using the `scala-lang` package, that will generate bytecode objects to be loaded \ninto the underlying Java Virtual Machine. The following web-application takes a scriptlet from an HTTP parameter and\nevaluates the result:\n\n```scala\ncase class Scriptlet(code: String)\n\ndef scriptExecutionForm = Form(\n  mapping(\n    \"code\" -> text\n  )(Scriptlet.apply)(Scriptlet.unapply)\n)\n\ndef evaluateScript = Action(parse.form(scriptExecutionForm)) { request =>\n  val settings = new Settings\n\n  settings.usejavacp.value   = true\n  settings.deprecation.value = true\n\n  val eval      = new IMain(settings)\n  val evaluated = eval.interpret(request.body.code)\n\n  if (evaluated == Success) {\n    val result = eval.valueOfTerm(\"result\").get.asInstanceOf[String]\n    Ok(result)\n  }\n  else {\n    Status(488)(\"Unable to evaluate this code\")\n  }\n}\n```\n\nAnother common method of achieving dynamic execution in Scala is by using reflection:\n\n```scala\nimport scala.reflect.runtime.universe\nimport scala.tools.reflect.ToolBox\n\nval toolbox = universe.runtimeMirror(getClass.getClassLoader).mkToolBox()\ntoolbox.eval(toolbox.parse(\"\"\"println(\"Hello world\")\"\"\"))\n```\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your Java Virtual \nMachine - meaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to avoid using dynamic evaluation of Scala altogether. \n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Scala, consider using a\ntoolkit like the Scala Standard Parser Combinator Library, which allows you to write parsers that will \"sandbox\" the \nfunctions a user can invoke, removing the risks of arbitrary code execution.\n\nThe `math-expression-parser` library is good example of a well-scoped DSL that allows evaluation of simple arithmetic\nexpressions:\n\n```scala\nimport io.github.facaiy.math.expression.MathExp\n\nval expressionString = \"1.0 + sqrt(2 * $a1) + $a2 ** 2\"\nval parsedExpression = MathExp.parse(expressionString)\nval inputVariables   = Map(\"a1\" -> 2, \"a2\" -> 1)\n\n// This will return the value \"4.0\", by evaluating the expression with the supplied input variables.\nval output = parsedExpression.eval(inputVariables)\n```\n\n:::\n\n:::tab[Go]\n\n## Remote Code Execution in Go\n\nDynamic execution of Go is relatively rare. The Go playground (https://go.dev/play/) allows you to run Go code from a\nweb browser, and achieves this by dynamically compiling code using the Go toolchain, and executing the compiled code in\na sandbox on a remote server.\n\nMore common is the use of packages like `net/rpc` or `grpc` to allow remote invocation of individual methods across a \nnetwork. This allows a development team to build efficient, distributed micro-services.\n\nTo mitigate remote code execution attacks in a distributed computing environment, you must ensure any procedure calls \ncome from a trusted source. With `grpc` this can be achieved using Application Layer Transport Security (ALTS), a mutual \nauthentication and transport developed by Google:\n\n```go\nimport (\n  \"google.golang.org/grpc\"\n  \"google.golang.org/grpc/credentials/alts\"\n)\n\naltsTC          := alts.NewClientCreds(alts.DefaultClientOptions())\nconnection, err := grpc.Dial(serverAddr, grpc.WithTransportCredentials(altsTC))\n```\n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Go, consider using an \nembeddable scripting language like Lua:\n\n```go\nimport (\n  \"github.com/yuin/gopher-lua\"\n)\n\nfunc main() {\n  // Instantiate a Lua sandbox.\n  sandbox := lua.NewState()\n  \n  defer sandbox.Close()\n  \n  // Dynamically execute a string as Lua code.\n  if err := sandbox.DoString(`print(\"hello\")`); err != nil {\n    panic(err)\n  }\n}\n```\n\nThis example will execute the simple Lua expression `print(\"hello\")`. Using a Lua sandbox in this fashion will allow you \nto execute dynamic expressions passed by a user safely - simply pass the expression to the `sandbox.DoString(...)` \nfunction to execute it. The executed code will *only* be able to access state you pass to the sandbox via the \n`sandbox.SetField(...)` function, closing any security loopholes associated with remote code execution.\n\n:::\n\n:::tab[PHP]\n\n## Remote Code Execution in PHP\n\nPHP provides several functions that allow for the execution of system commands and the evaluation of code dynamically. Some commonly used functions for this purpose include `eval()`, `system()`, `exec()`, `passthru()`, `shell_exec()`, and others.\n\nThis vulnerability arises when developers use these functions without properly validating or sanitizing user inputs. This can allow an attacker to inject and execute arbitrary code on the server.\n\nConsider the following PHP snippet, which takes a script input from an HTTP request and evaluates it:\n\n```php\n<?php\n$script = $_GET['script'];\n\n// Using the eval function directly on unsanitized input poses a severe security risk.\n// An attacker can provide a malicious PHP code as a value for the \"script\" parameter and execute it.\neval($script);\n\necho \"Script executed successfully!\";\n?>\n```\n\nBy visiting a URL like `http://example.com/vulnerable.php?script=system('ls');` an attacker could execute the `ls` command, and with more malicious intent, they can cause significant harm.\n\n## Mitigation\n\nTo secure your code, ensure that strings passed to evaluation or execution functions are from trusted sources, or are validated against an allow-list:\n\n```php\n<?php\n$allowedScripts = ['print_hello' => 'echo \"Hello, World!\";'];\n\n$scriptKey = $_GET['scriptKey'];\n\n// Validate against an allow-list of scripts.\nif (!array_key_exists($scriptKey, $allowedScripts)) {\n    die(\"Not permitted\");\n}\n\neval($allowedScripts[$scriptKey]);\n\necho \"Script executed successfully!\";\n?>\n```\n\n## Further Considerations\n\nDynamic code evaluation in PHP should be used with extreme caution. Whenever possible, avoid using functions like `eval()` altogether. If dynamic functionality is needed, consider more secure alternatives like creating pre-defined safe functions or adopting a Domain-Specific Language (DSL) with strict parsing and validation. Always use PHP's built-in functions to sanitize and validate all user inputs to prevent code injections.\n\n:::\n\n::::\n\n## CWEs\n\n**[CWE-77](https://cwe.mitre.org/data/definitions/77.html)**\n\n**[CWE-78](https://cwe.mitre.org/data/definitions/78.html)**\n\n**[CWE-94](https://cwe.mitre.org/data/definitions/94.html)**\n\n**[CWE-917](https://cwe.mitre.org/data/definitions/917.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**"
                            },
                            "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
                            "id": "Secret%20Keyword/7b2be704053344919e45a063df09788faa78eca804b0ab4a43721c6bd6f116fd",
                            "name": "Secret Keyword",
                            "properties": {
                                "precision": "very-high",
                                "security-severity": "5.5",
                                "tags": [
                                    "ng-sast",
                                    "CVSS 5.5",
                                    "Generic Secret",
                                    "OWASP a3-sensitive-data-exposure"
                                ]
                            },
                            "shortDescription": {
                                "text": "Secret Keyword"
                            }
                        },
                        {
                            "defaultConfiguration": {
                                "enabled": true,
                                "level": "warning",
                                "rank": -1
                            },
                            "fullDescription": {
                                "text": "The Access-Control-Allow-Origin (CORS) header is set to the `\"*\"` wildcard, allowing."
                            },
                            "help": {
                                "markdown": "The Access-Control-Allow-Origin (CORS) header is set to the `\"*\"` wildcard, allowing\ncross-site requests from untrusted third-party web sites. This opts out of standard protections against Cross-Site Request Forgery attacks.\n\n# Cross-Site Request Forgery\n\n**Cross-site request forgery** (CSRF) vulnerabilities can be used to trick a user into performing an unwanted action on\nyour website.\n\nWebsites consist of a combination of client-side and server-side code. The client-side code is the HTML and JavaScript that\nis rendered by and executed in the browser. This client-side code allows users to navigate to other URLs, submit HTML\nforms, and trigger AJAX requests via JavaScript. Your server-side code will intercept the data sent in the resulting\nHTTP requests, and act upon it appropriately.\n\nThese server-side actions can also be triggered by *forged* HTTP requests unless you explicitly put in protective\nmeasures. A forged request is when a malicious actor tricks a victim into clicking on a link, submitting a form, or \nrunning some code that triggers an unexpected action. This malicious code is typically hosted on a website controlled by \nthe attacker, on another domain - hence the *cross-site* part of the name.\n\nProtecting against CSRF requires two things: ensuring that `GET` requests are **side effect free**, and ensuring that\nother requests do not originate from a third-party site by using **anti-forgery tokens**.\n\n\n## Making GET Requests Side Effect Free\n\nHyperlinks on the internet trigger a `GET` request to the destination URL. This means that links into your website from\nexternal domains will almost always be `GET` requests. To make sure your users don't experience unexpected actions when\nclicking on links, `GET` requests should only retrieve resources from the server - never *change state* on the server. Anything\nthat changes state - a *side effect* - should be handled by `POST`, `PUT`  and `DELETE` requests, depending on whether\nthe request is adding, updating or deleting state.\n\nHere are some examples of side effects that should **not** be performed with `GET` requests:\n\n* Logging in\n* Logging out\n* Password resets\n* Sign-ups \n* Posting or editing content\n* Account deletion\n\n::::tabs\n\n:::tab[Java]\n\nFor example, consider the following implementation of an \"Account Deletion\" function:\n\n```java\n@WebServlet(\"/profile/delete\")\npublic class AccountDeletionServlet extends HttpServlet\n{\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        HttpSession session  = request.getSession();\n        String      username = (String) session.getAttribute(\"username\");\n\n        getDatabase().deleteUser(username);\n\n        session.invalidate();\n        response.sendRedirect(\"/\");\n    }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nIn a Java web application, this functionality is often achieved by implementing a filter:\n\n```java\n/**\n * A simple Filter that generates CSRF tokens, puts them in a cookie, and passes them downstream\n * as a request attribute, so they can be added to HTML forms. When a form is submitted the\n * filter validates that the value in the form and the value in the cookie match - thus ensuring\n * the request originated from our domain.\n *\n * To handle AJAX requests, CSRF tokens should be passed in a \"CSRF\" header.\n */\npublic class CSRFProtectionFilter extends HttpFilter\n{\n    private final static List METHODS_TO_PROTECT = Arrays.asList(\"PUT\", \"POST\", \"DELETE\");\n\n    @Override\n    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException\n    {\n        // Extract the CSRF token from the cookie if we can find it.\n        String csrfTokenFromCookie = null;\n\n        if (request.getCookies() != null) {\n            for (Cookie cookie : request.getCookies()) {\n                if (cookie.getName().equals(\"CSRF\")) {\n                    csrfTokenFromCookie = cookie.getValue();\n                }\n            }\n        }\n\n        // For sensitive HTTP methods check a matching token is sent in an HTML form\n        // parameter or in an HTTP header.\n        if (METHODS_TO_PROTECT.contains(request.getMethod())) {\n            if (csrfTokenFromCookie == null)\n                throw new ServletException(\"Missing CSRF token in cookie\");\n\n            String csrfTokenFromBody   = request.getParameter(\"CSRF\");\n            String csrfTokenFromHeader = request.getHeader(\"CSRF\");\n\n            if (csrfTokenFromBody == null && csrfTokenFromHeader == null)\n                throw new ServletException(\"Missing CSRF token in body\");\n\n            if (csrfTokenFromBody != null && !csrfTokenFromBody.equals(csrfTokenFromCookie))\n                throw new ServletException(\"Mismatched CSRF tokens\");\n\n            if (csrfTokenFromHeader != null && !csrfTokenFromHeader.equals(csrfTokenFromCookie))\n                throw new ServletException(\"Mismatched CSRF tokens\");\n        }\n\n        // If this a GET request, we may not have set the CSRF token in the cookie.\n        // Generate it now, and attach it to the request.\n        if (csrfTokenFromCookie == null) {\n            String newCSRFToken = generateCSRFToken();\n\n            // Ensure the cookie is not accessible from JavaScript, and\n            // is only sent over HTTPS. Strip cookies from all but GET\n            // requests from other sites.\n            response.addHeader(\"Set-Cookie\", \"CSRF=\" + newCSRFToken + \"; HttpOnly; Secure; SameSite=Lax\");\n            request.setAttribute(\"CSRF\", newCSRFToken);\n        }\n        else {\n            request.setAttribute(\"CSRF\", csrfTokenFromCookie);\n        }\n\n        chain.doFilter(request, response);\n    }\n\n    /**\n     * Generate a CSRF token from a securely random number.\n     */\n    private static String generateCSRFToken() throws ServletException\n    {\n        try {\n            SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\n            byte[] data = new byte[16];\n            random.nextBytes(data);\n\n            return Base64.getEncoder().encodeToString(data);\n        }\n        catch (NoSuchAlgorithmException e) {\n            throw new ServletException(\"Unexpected exception generating CSRF token.\", e);\n        }\n    }\n}\n```\n\nAny forms that sit down stream of this filter can inject the CSRF token into the request they generate with a single\nline of code:\n\n```html\n<form method=\"POST\" enctype=\"multipart/form-data\" action=\"/profile/photo\">\n  \n  <!-- Inject the CSRF token to secure our uploads. -->  \n  <input type=\"hidden\" name=\"CSRF\" value=\"<%= request.getAttribute(\"CSRF\") %>\">\n  <input type=\"file\" name=\"file\" id=\"file\">\n\n  <input type=\"submit\" value=\"Upload\" name=\"upload\">\n</form>\n```\n\n:::\n\n:::tab[Angular]\n\nFor example, consider the following implementation of a \"Logout\" function in Angular:\n\n```typescript\nexport class LogoutService {\n  constructor(private http: HttpClient) {}\n\n  logout(): void {\n    // Send a GET request to the server to trigger a logout.  \n    this.http.get('/api/auth/logout').subscribe()\n  }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `www.yoursite.com/logout`, that user will be logged out before \nthey are aware of what is happening. For this reason, it's recommended to implement logout functionality via `PUT` or \n`DELETE` requests. The situation becomes even more dire in the event of e.g. account deletion functionality: you will \nhave real problems if attackers can trick users into accidentally deleting their accounts.\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects. These tokens are called **anti-forgery tokens**. \n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nsent to the browser. The server will compare the token attached to any inbound requests with the original value. \nIf the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens should be generated on the web-server and provided to client-side code in some fashion - typically\nthey are written out as `<meta>` tags in the HTML header, or loaded asynchronously via an AJAX call. Any subsequent AJAX \ncalls should pass the token back in an HTTP header, so the server can validate it. \n\nAngular allows you to add anti-forgery tokens to HTTP requests using the `HttpClientXsrfModule` module:\n\n```typescript\n@NgModule({\n  declarations: [\n  ],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    HttpClientXsrfModule.withOptions({\n      cookieName: 'XSRF-TOKEN',\n      headerName: 'X-CSRF-TOKEN'\n    }),\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {\n}\n```\n\nThe name of the header and the name of the hidden form field will depend on what library you are using to generate your\nanti-forgery tokens on the server-side. Consult the library's documentation for details, and add the appropriate \ncorresponding names in your Angular configuration.\n\n:::\n\n:::tab[C#]\n\nFor example, consider the following route for an \"Account Deletion\" action in the ASP.NET core:\n\n```csharp\n[HttpGet(\"profile/delete\")]\npublic async Task DeleteAccount()\n{\n    var user = await UserManager.FindByNameAsync(User.Identity.Name);\n    \n    await UserManager.DeleteAsync(user);\n    await HttpContext.SignOutAsync();\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are generated *automatically *by ASP.NET Core since version 2.0. The Razor template files that are \nused to generate HTML will have tokens injected into any forms by default. You can even make the injection of \nanti-forgery tokens explicit with the following syntax:\n\n```html\n<form action=\"/\" method=\"post\">\n    @Html.AntiForgeryToken()\n</form>\n```\n\nTo help secure AJAX requests, anti-CSRF cookies can be made available to JavaScript code defined in Razor templates in the \nfollowing manner:\n\n```csharp\n@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery Xsrf\n@functions{\n    public string GetAntiXsrfRequestToken()\n    {\n        return Xsrf.GetAndStoreTokens(Context).RequestToken;\n    }\n}\n```\n\nYou can then secure your controller methods from CSRF attacks by adding the attribute `ValidateAntiForgeryTokenAttribute`.\nHere's how you would protect an account deletion action from CSRF attacks: \n\n```csharp\n[HttpDelete(\"profile\")]\n[Authorize]\n[ValidateAntiForgeryToken]\npublic async Task DeleteAccount()\n{\n    var user = await UserManager.FindByNameAsync(User.Identity.Name);\n    \n    await UserManager.DeleteAsync(user);\n    await HttpContext.SignOutAsync();\n}\n```\n\n:::\n\n:::tab[JavaScript]\n\nFor example, consider the following implementation of an \"Account Deletion\" function in Express:\n\n```javascript\nconst express      = require('express')\nconst session      = require('express-session')\nconst cookieParser = require('cookie-parser')\nconst app          = express()\n\napp.use(cookieParser())\napp.use(session({ cookie: { maxAge: 60000 }}))\n\napp.get('/profile/delete', (request, response) => {\n  const email = request.session.email\n\n  db.run('DELETE FROM users WHERE email = ?', [ email ], () => {\n    response.redirect('/')\n  })\n})\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nHere is how to use the `csurf` library in Node.js to write out anti-forgery tokens:\n\n```javascript\nconst cookieParser = require('cookie-parser')\nconst bodyParser   = require('body-parser')\n\nconst app = express()\n\nconst csrf           = require('csurf')\nconst csrfProtection = csrf({ cookie: true })\nconst parseForm      = bodyParser.urlencoded({ extended: false })\n\napp.use(cookieParser())\n\n/**\n * We set the '_csrf' value in the Cookie and the login form, so we\n * can cross check them during the login process.\n */\napp.get('/login', csrfProtection, (request, response) => {\n  response.send(\n    `<form action=\"/login\" method=\"POST\">\n       <input type=\"hidden\"   name=\"_csrf\"    value=\"${request.csrfToken()}\">\n       <input type=\"text\"     name=\"Username\" value=\"\">\n       <input type=\"password\" name=\"password\" value=\"\">\n  \n       <button type=\"submit\">Login</button>\n    </form>`\n  )\n})\n\n/**\n * Here the 'csrfProtection' function cross-checks the CSRF token in the Cookie\n * and that in the form, and rejects the request if they don't match.\n */\napp.post('/login', parseForm, csrfProtection, (request, response) => {\n  response.send('CSRF cookie validated!')\n})\n```\n\n:::\n\n:::tab[Python]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Flask web-server:\n\n```python\n@app.route('/profile/delete', methods=['GET'])\ndef delete_post(post_id):\n  user = session['user']\n    \n  with database() as db:\n    db.execute('delete from users where id = ?', user['id'])\n    del session['user']\n      \n  return redirect('/')\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are easily added in Flask web-server by registering the `CSRFProtect` extension:\n\n```python\nfrom flask import Flask\nfrom flask_wtf.csrf import CSRFProtect\n\napp  = Flask(__name__)\ncsrf = CSRFProtect(app)\n```\n\nAny HTML forms generated by templates should add the relevant form field as follows:\n\n```html\n<form method=\"post\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\"/>\n</form>\n```\n\nAJAX requests can similarly be amended to include anti-forgery tokens in the following manner:\n\n```html\n<script type=\"text/javascript\">\n    var csrf_token = \"{{ csrf_token() }}\";\n\n    $.ajaxSetup({\n        beforeSend: function(xhr, settings) {\n            if (!/^(GET|HEAD|OPTIONS|TRACE)$/i.test(settings.type) && !this.crossDomain) {\n                xhr.setRequestHeader(\"X-CSRFToken\", csrf_token);\n            }\n        }\n    });\n</script>\n```\n\nIn the Django web-framework, CSRF protection is provided by the `django.middleware.csrf.CsrfViewMiddleware` class.\n\n:::\n\n:::tab[React]\n\nFor example, consider the following implementation of a \"Logout\" function in React:\n\n```jsx\nclass Logout extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.updateLoginStatus = props.updateLoginStatus\n  }\n\n  async logout() {\n    \n    // Invalidate the session on the server.\n    const response = await fetch(\"/logout\", {\n      method: 'GET'\n    })\n\n    if (response.ok) {\n      \n      // Set the login status to \"Logged out\" and the username to null in the component state.\n      this.updateLoginStatus(false, null)\n    }\n  }\n\n  render() {\n    return (\n      <a onClick={() => { this.logout() }}>\n        Logout\n      </a>\n    )\n  }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `www.yoursite.com/logout`, that user will be logged out before \nthey are aware of what is happening. For this reason, it's recommended to implement logout functionality via `PUT` or \n`DELETE` requests. The situation becomes even more dire in the event of e.g. account deletion functionality: you will \nhave real problems if attackers can trick users into accidentally deleting their accounts.\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects. These tokens are called **anti-forgery tokens**. \n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nsent to the browser. The server will compare the token attached to any inbound requests with the original value. \nIf the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens should be generated on the web-server and provided to client-side code in some fashion - typically\nthey are written out as `<meta>` tags in the HTML header, or loaded asynchronously via an AJAX call. Any subsequent AJAX \ncalls should pass the token back in an HTTP header, so the server can validate it:\n\n```jsx\nclass Logout extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.updateLoginStatus = props.updateLoginStatus\n  }\n\n  async logout() {\n    \n    // Invalidate the session on the server, passing back the anti-forgery token\n    // in an HTTP header. The browser will attach a matching value in a cookie.\n    const response = await fetch(\"/logout\", {\n      method: 'DELETE',\n      headers: {\n        'CSRF-Token' : this.props.csrf\n      }\n    })\n\n    if (response.ok) {\n      \n      // Set the login status to \"Logged out\" and the username to null in the component state.\n      this.updateLoginStatus(false, null)\n    }\n  }\n\n  render() {\n    return (\n      <a onClick={() => { this.logout() }}>\n        Logout\n      </a>\n    )\n  }\n}\n```\n\nIf you generate HTTP requests using HTML forms, you should add the anti-forgery token in a hidden field of the form:\n\n```jsx\nfunction Comment(props) {\n  return (\n    <div className=\"post\">\n      <form action=\"/comment\" method=\"POST\">\n        <textarea name=\"comment\" placeholder=\"What's on your mind?\"/>\n        <input type=\"hidden\" name=\"_csrf\" value={props.csrf} />\n        <button type=\"submit\">Add Comment</button>\n      </form>\n    </div>\n  )\n}\n```\n\nThe name of the header and the name of the hidden form field will depend on what library you are using to generate your\nanti-forgery tokens on the server-side. Consult the library's documentation for details, and update your React code\naccordingly.\n\n:::\n\n:::tab[Scala]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Play framework:\n\n```scala\nGET   /profile/delete          controllers.Profile.delete\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nIn the Play framework, CSRF protection is enabled automatically. The `play.filters.csrf.CSRFFilter` will add an\nanti-forgery token to responses securely:\n\n```scala\n  def addTokenToResponse(request: RequestHeader, result: Result): Result = {\n    request.attrs.get(CSRF.Token.InfoAttr) match {\n      case None =>\n        filterLogger.warn(\"[CSRF] No token found on request!\")\n        result\n      case Some(tokenInfo) if {\n            tokenIsHttpOnly &&                             // the token is not going to be accessed and used from JS\n            result.body.isInstanceOf[HttpEntity.Strict] && // the body was fully rendered\n            !tokenInfo.wasRendered                         // the token was not rendered in the body of the response\n          } =>\n        filterLogger.trace(\"[CSRF] Not emitting CSRF token because token was never rendered\")\n        result\n      case _ if isCacheableBySharedCache(result) =>\n        filterLogger.trace(\"[CSRF] Not adding token to response that might get cached by a shared cache (e.g. proxies)\")\n        result\n      case Some(tokenInfo) =>\n        val Token(tokenName, tokenValue) = tokenInfo.toToken\n        filterLogger.trace(\"[CSRF] Adding token to result: \" + result)\n        csrfConfig.cookieName\n          .map { name =>\n            result.withCookies(\n              Cookie(\n                name,\n                tokenValue,\n                path = sessionConfiguration.path,\n                domain = sessionConfiguration.domain,\n                secure = csrfConfig.secureCookie,\n                httpOnly = csrfConfig.httpOnlyCookie,\n                sameSite = csrfConfig.sameSiteCookie\n              )\n            )\n          }\n          .getOrElse {\n            val newSession = result.session(request) + (tokenName -> tokenValue)\n            result.withSession(newSession)\n          }\n    }\n  }\n```\n\nYou can access token to add it to your forms and AJAX requests by calling `CSRF.getToken.get`, or using the built-in\nhelper methods for form-building:\n\n```scala\n@form(routes.ItemsController.save()) {\n    @CSRF.formField\n    ...\n}\n```\n\nWhich will render a form like:\n\n```html\n<form method=\"POST\" action=\"/items\">\n   <input type=\"hidden\" name=\"csrfToken\" value=\"1234567890abcdef\"/>\n   ...\n</form>\n```\n\n:::\n\n:::tab[Go]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Gorilla web toolkit:\n\n```go\nfunc DeleteProfileHandler(response http.ResponseWriter, request *http.Request) {\n  session, err := session.Get(request, \"session\")\n\n  if err != nil {\n    http.Error(response, \"Error loading session\", http.StatusInternalServerError)\n    return\n  }\n\n  userId := session.Values[\"userId\"]\n\n  deleteUser(userId)\n\n  session.Options.MaxAge = -1\n\n  err = session.Save(request, response)\n\n  if err != nil {\n    http.Error(response, \"Error saving session\", http.StatusInternalServerError)\n    return\n  }\n\n  http.Redirect(response, request, \"/\", http.StatusOK)\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are easily added using the `gorilla/csrf` package:\n\n```go\nfunc main() {\n  router := mux.NewRouter()\n  router.HandleFunc(\"/signup\", ShowSignupForm)\n\n  // All POST requests without a valid token will return HTTP 403 Forbidden.\n  // We should also ensure that our mutating (non-idempotent) handler only\n  // matches on POST requests. We can check that here, at the router level, or\n  // within the handler itself via r.Method.\n  router.HandleFunc(\"/signup/post\", SubmitSignupForm).Methods(\"POST\")\n\n  // Add the middleware to your router by wrapping it.\n  http.ListenAndServe(\":8000\",\n  csrf.Protect([]byte(\"32-byte-long-auth-key\"))(router))\n  \n  // PS: Don't forget to pass csrf.Secure(false) if you're developing locally\n  // over plain HTTP (just don't leave it on in production).\n}\n```\n\nAny HTML forms generated by templates should add the relevant form field as follows:\n\n```go\nfunc ShowSignupForm(w http.ResponseWriter, r *http.Request) {\n  // signup_form.tmpl just needs a {{ .csrfField }} template tag for\n  // csrf.TemplateField to inject the CSRF token into. Easy!\n  t.ExecuteTemplate(w, \"signup_form.tmpl\", map[string]interface{}{\n      csrf.TemplateTag: csrf.TemplateField(r),\n  })\n}\n```\n\nAJAX requests can similarly be amended to include anti-forgery tokens in the following manner:\n\n```javascript\n// Find the CSRF token.\nlet csrfToken = document.getElementsByName(\"gorilla.csrf.Token\")[0].value\n\n// Add the CSRF token to e.g. the Axios AJAX client.\nconst instance = axios.create({\n  baseURL: \"https://example.com/api/\",\n  timeout: 1000,\n  headers: { \"X-CSRF-Token\": csrfToken }\n})\n```\n\n:::\n\n:::tab[PHP]\n\nFor example, here's a potentially dangerous PHP script that deletes a user's account based on a `GET` request:\n\n```php\n<?php\nif (isset($_GET['deleteAccount'])) {\n    deleteUserAccount($_SESSION['userId']);\n    header('Location: /');\n}\n?>\n```\n\nBy having such code, a malicious actor could trick a user's browser into making a request to a URL with `?deleteAccount=true`, leading to the unintended deletion of their account. To avoid this, use a `POST` request:\n\n```php\n<?php\nif (isset($_POST['deleteAccount'])) {\n    deleteUserAccount($_SESSION['userId']);\n    header('Location: /');\n}\n?>\n\n<form method=\"POST\" action=\"\">\n    <button name=\"deleteAccount\" value=\"true\">Delete Account</button>\n</form>\n```\n\n## Anti-Forgery Tokens in PHP\n\nTo mitigate CSRF attacks in PHP applications, use anti-forgery tokens. One popular way is to generate and validate CSRF tokens using PHP sessions.\n\n1. **Generating the CSRF token**:\n   \n```php\nsession_start();\n\nif (empty($_SESSION['csrf_token'])) {\n    $_SESSION['csrf_token'] = bin2hex(random_bytes(32));\n}\n\n$csrf_token = $_SESSION['csrf_token'];\n```\n\n2. **Including the token in forms**:\n\n```html\n<form method=\"POST\" action=\"\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"<?php echo $csrf_token; ?>\">\n    <button type=\"submit\" name=\"submitAction\">Perform Action</button>\n</form>\n```\n\n3. **Validating the token**:\n\n```php\nif ($_SERVER['REQUEST_METHOD'] !== 'GET' && $_SERVER['REQUEST_METHOD'] !== 'HEAD') {\n    if (!isset($_SESSION['csrf_token']) || !isset($_POST['csrf_token'])) {\n        // Token not provided or not yet generated for session - potential CSRF attack.\n        die('Invalid request.');\n    }\n\n    $expectedToken = $_SESSION['csrf_token'];\n    $userToken = $_POST['csrf_token'];\n\n    if (!hash_equals($expectedToken, $userToken)) {\n        // Token validation failed, potential CSRF attack.\n        die('Invalid request.');\n    }\n\n    // Continue with the intended action\n    performSensitiveAction();\n}\n```\n\nUsing anti-forgery tokens ensures that the action is only executed if the request originates from your domain and the token matches the one in the user's session.\n\n:::\n\n::::\n\n### Ensure Cookies Are Sent With The SameSite Cookie Attribute\n\nThe `Same-Site` cookie attribute instructs the browser whether to send cookies with requests initiated by third-party \ndomains. Since anti-forgery tokens are typically validated by comparing the token value sent in the HTML form with a \nvalue in a cookie, they are only effective when the `Same-Site` attribute is set appropriately.\n\nA `Same-Site` value of `Strict` will mean than *any* request initiated by a third-party domain to *your* domain will not \nhave any cookies attacked. This is the most secure setting, since it prevents malicious sites attempting to perform\nharmful actions under a user's session.\n\nA value of `Lax` permits `GET` request from a third-party domain to *your* domain to have cookies attached - but *only* \n`GET` requests. With this setting a user will not have to sign in again to your site if they follow a link from another \nsite (say, Google search results). This makes for a friendlier user-experience - but make sure your `GET` requests are \nside effect free!\n\n## Further Considerations\n\n* Make sure your cookies cannot be accessed in JavaScript, and are only sent over HTTPS. This is done by adding the `HttpOnly` \n  and `Secure` attributes to each cookie.\n  \n* Many sites require a secondary authentication step, or require re-confirmation of login details when the user performs \n  a sensitive action. (Think of a typical  password reset page - usually the user will have to specify their old \n  password before setting a new password.) Not only does this protect users who may accidentally leave themselves \n  logged in on publicly accessible computers, but it also greatly reduces the possibility of CSRF attacks.\n  \n* Ensuring `GET` requests are side effect free is part of a series of design principles called *Representation State \n  Transfer (REST)* that assign certain types of action (view, create, delete, update) to different HTTP verbs. \n  REST insists that GET requests are used only to *view* resources. \n  \n## CWEs\n\n* [CWE-352](https://cwe.mitre.org/data/definitions/352.html)",
                                "text": "The Access-Control-Allow-Origin (CORS) header is set to the `\"*\"` wildcard, allowing\ncross-site requests from untrusted third-party web sites. This opts out of standard protections against Cross-Site Request Forgery attacks.\n\n# Cross-Site Request Forgery\n\n**Cross-site request forgery** (CSRF) vulnerabilities can be used to trick a user into performing an unwanted action on\nyour website.\n\nWebsites consist of a combination of client-side and server-side code. The client-side code is the HTML and JavaScript that\nis rendered by and executed in the browser. This client-side code allows users to navigate to other URLs, submit HTML\nforms, and trigger AJAX requests via JavaScript. Your server-side code will intercept the data sent in the resulting\nHTTP requests, and act upon it appropriately.\n\nThese server-side actions can also be triggered by *forged* HTTP requests unless you explicitly put in protective\nmeasures. A forged request is when a malicious actor tricks a victim into clicking on a link, submitting a form, or \nrunning some code that triggers an unexpected action. This malicious code is typically hosted on a website controlled by \nthe attacker, on another domain - hence the *cross-site* part of the name.\n\nProtecting against CSRF requires two things: ensuring that `GET` requests are **side effect free**, and ensuring that\nother requests do not originate from a third-party site by using **anti-forgery tokens**.\n\n\n## Making GET Requests Side Effect Free\n\nHyperlinks on the internet trigger a `GET` request to the destination URL. This means that links into your website from\nexternal domains will almost always be `GET` requests. To make sure your users don't experience unexpected actions when\nclicking on links, `GET` requests should only retrieve resources from the server - never *change state* on the server. Anything\nthat changes state - a *side effect* - should be handled by `POST`, `PUT`  and `DELETE` requests, depending on whether\nthe request is adding, updating or deleting state.\n\nHere are some examples of side effects that should **not** be performed with `GET` requests:\n\n* Logging in\n* Logging out\n* Password resets\n* Sign-ups \n* Posting or editing content\n* Account deletion\n\n::::tabs\n\n:::tab[Java]\n\nFor example, consider the following implementation of an \"Account Deletion\" function:\n\n```java\n@WebServlet(\"/profile/delete\")\npublic class AccountDeletionServlet extends HttpServlet\n{\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        HttpSession session  = request.getSession();\n        String      username = (String) session.getAttribute(\"username\");\n\n        getDatabase().deleteUser(username);\n\n        session.invalidate();\n        response.sendRedirect(\"/\");\n    }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nIn a Java web application, this functionality is often achieved by implementing a filter:\n\n```java\n/**\n * A simple Filter that generates CSRF tokens, puts them in a cookie, and passes them downstream\n * as a request attribute, so they can be added to HTML forms. When a form is submitted the\n * filter validates that the value in the form and the value in the cookie match - thus ensuring\n * the request originated from our domain.\n *\n * To handle AJAX requests, CSRF tokens should be passed in a \"CSRF\" header.\n */\npublic class CSRFProtectionFilter extends HttpFilter\n{\n    private final static List METHODS_TO_PROTECT = Arrays.asList(\"PUT\", \"POST\", \"DELETE\");\n\n    @Override\n    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException\n    {\n        // Extract the CSRF token from the cookie if we can find it.\n        String csrfTokenFromCookie = null;\n\n        if (request.getCookies() != null) {\n            for (Cookie cookie : request.getCookies()) {\n                if (cookie.getName().equals(\"CSRF\")) {\n                    csrfTokenFromCookie = cookie.getValue();\n                }\n            }\n        }\n\n        // For sensitive HTTP methods check a matching token is sent in an HTML form\n        // parameter or in an HTTP header.\n        if (METHODS_TO_PROTECT.contains(request.getMethod())) {\n            if (csrfTokenFromCookie == null)\n                throw new ServletException(\"Missing CSRF token in cookie\");\n\n            String csrfTokenFromBody   = request.getParameter(\"CSRF\");\n            String csrfTokenFromHeader = request.getHeader(\"CSRF\");\n\n            if (csrfTokenFromBody == null && csrfTokenFromHeader == null)\n                throw new ServletException(\"Missing CSRF token in body\");\n\n            if (csrfTokenFromBody != null && !csrfTokenFromBody.equals(csrfTokenFromCookie))\n                throw new ServletException(\"Mismatched CSRF tokens\");\n\n            if (csrfTokenFromHeader != null && !csrfTokenFromHeader.equals(csrfTokenFromCookie))\n                throw new ServletException(\"Mismatched CSRF tokens\");\n        }\n\n        // If this a GET request, we may not have set the CSRF token in the cookie.\n        // Generate it now, and attach it to the request.\n        if (csrfTokenFromCookie == null) {\n            String newCSRFToken = generateCSRFToken();\n\n            // Ensure the cookie is not accessible from JavaScript, and\n            // is only sent over HTTPS. Strip cookies from all but GET\n            // requests from other sites.\n            response.addHeader(\"Set-Cookie\", \"CSRF=\" + newCSRFToken + \"; HttpOnly; Secure; SameSite=Lax\");\n            request.setAttribute(\"CSRF\", newCSRFToken);\n        }\n        else {\n            request.setAttribute(\"CSRF\", csrfTokenFromCookie);\n        }\n\n        chain.doFilter(request, response);\n    }\n\n    /**\n     * Generate a CSRF token from a securely random number.\n     */\n    private static String generateCSRFToken() throws ServletException\n    {\n        try {\n            SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\n            byte[] data = new byte[16];\n            random.nextBytes(data);\n\n            return Base64.getEncoder().encodeToString(data);\n        }\n        catch (NoSuchAlgorithmException e) {\n            throw new ServletException(\"Unexpected exception generating CSRF token.\", e);\n        }\n    }\n}\n```\n\nAny forms that sit down stream of this filter can inject the CSRF token into the request they generate with a single\nline of code:\n\n```html\n<form method=\"POST\" enctype=\"multipart/form-data\" action=\"/profile/photo\">\n  \n  <!-- Inject the CSRF token to secure our uploads. -->  \n  <input type=\"hidden\" name=\"CSRF\" value=\"<%= request.getAttribute(\"CSRF\") %>\">\n  <input type=\"file\" name=\"file\" id=\"file\">\n\n  <input type=\"submit\" value=\"Upload\" name=\"upload\">\n</form>\n```\n\n:::\n\n:::tab[Angular]\n\nFor example, consider the following implementation of a \"Logout\" function in Angular:\n\n```typescript\nexport class LogoutService {\n  constructor(private http: HttpClient) {}\n\n  logout(): void {\n    // Send a GET request to the server to trigger a logout.  \n    this.http.get('/api/auth/logout').subscribe()\n  }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `www.yoursite.com/logout`, that user will be logged out before \nthey are aware of what is happening. For this reason, it's recommended to implement logout functionality via `PUT` or \n`DELETE` requests. The situation becomes even more dire in the event of e.g. account deletion functionality: you will \nhave real problems if attackers can trick users into accidentally deleting their accounts.\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects. These tokens are called **anti-forgery tokens**. \n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nsent to the browser. The server will compare the token attached to any inbound requests with the original value. \nIf the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens should be generated on the web-server and provided to client-side code in some fashion - typically\nthey are written out as `<meta>` tags in the HTML header, or loaded asynchronously via an AJAX call. Any subsequent AJAX \ncalls should pass the token back in an HTTP header, so the server can validate it. \n\nAngular allows you to add anti-forgery tokens to HTTP requests using the `HttpClientXsrfModule` module:\n\n```typescript\n@NgModule({\n  declarations: [\n  ],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    HttpClientXsrfModule.withOptions({\n      cookieName: 'XSRF-TOKEN',\n      headerName: 'X-CSRF-TOKEN'\n    }),\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {\n}\n```\n\nThe name of the header and the name of the hidden form field will depend on what library you are using to generate your\nanti-forgery tokens on the server-side. Consult the library's documentation for details, and add the appropriate \ncorresponding names in your Angular configuration.\n\n:::\n\n:::tab[C#]\n\nFor example, consider the following route for an \"Account Deletion\" action in the ASP.NET core:\n\n```csharp\n[HttpGet(\"profile/delete\")]\npublic async Task DeleteAccount()\n{\n    var user = await UserManager.FindByNameAsync(User.Identity.Name);\n    \n    await UserManager.DeleteAsync(user);\n    await HttpContext.SignOutAsync();\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are generated *automatically *by ASP.NET Core since version 2.0. The Razor template files that are \nused to generate HTML will have tokens injected into any forms by default. You can even make the injection of \nanti-forgery tokens explicit with the following syntax:\n\n```html\n<form action=\"/\" method=\"post\">\n    @Html.AntiForgeryToken()\n</form>\n```\n\nTo help secure AJAX requests, anti-CSRF cookies can be made available to JavaScript code defined in Razor templates in the \nfollowing manner:\n\n```csharp\n@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery Xsrf\n@functions{\n    public string GetAntiXsrfRequestToken()\n    {\n        return Xsrf.GetAndStoreTokens(Context).RequestToken;\n    }\n}\n```\n\nYou can then secure your controller methods from CSRF attacks by adding the attribute `ValidateAntiForgeryTokenAttribute`.\nHere's how you would protect an account deletion action from CSRF attacks: \n\n```csharp\n[HttpDelete(\"profile\")]\n[Authorize]\n[ValidateAntiForgeryToken]\npublic async Task DeleteAccount()\n{\n    var user = await UserManager.FindByNameAsync(User.Identity.Name);\n    \n    await UserManager.DeleteAsync(user);\n    await HttpContext.SignOutAsync();\n}\n```\n\n:::\n\n:::tab[JavaScript]\n\nFor example, consider the following implementation of an \"Account Deletion\" function in Express:\n\n```javascript\nconst express      = require('express')\nconst session      = require('express-session')\nconst cookieParser = require('cookie-parser')\nconst app          = express()\n\napp.use(cookieParser())\napp.use(session({ cookie: { maxAge: 60000 }}))\n\napp.get('/profile/delete', (request, response) => {\n  const email = request.session.email\n\n  db.run('DELETE FROM users WHERE email = ?', [ email ], () => {\n    response.redirect('/')\n  })\n})\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nHere is how to use the `csurf` library in Node.js to write out anti-forgery tokens:\n\n```javascript\nconst cookieParser = require('cookie-parser')\nconst bodyParser   = require('body-parser')\n\nconst app = express()\n\nconst csrf           = require('csurf')\nconst csrfProtection = csrf({ cookie: true })\nconst parseForm      = bodyParser.urlencoded({ extended: false })\n\napp.use(cookieParser())\n\n/**\n * We set the '_csrf' value in the Cookie and the login form, so we\n * can cross check them during the login process.\n */\napp.get('/login', csrfProtection, (request, response) => {\n  response.send(\n    `<form action=\"/login\" method=\"POST\">\n       <input type=\"hidden\"   name=\"_csrf\"    value=\"${request.csrfToken()}\">\n       <input type=\"text\"     name=\"Username\" value=\"\">\n       <input type=\"password\" name=\"password\" value=\"\">\n  \n       <button type=\"submit\">Login</button>\n    </form>`\n  )\n})\n\n/**\n * Here the 'csrfProtection' function cross-checks the CSRF token in the Cookie\n * and that in the form, and rejects the request if they don't match.\n */\napp.post('/login', parseForm, csrfProtection, (request, response) => {\n  response.send('CSRF cookie validated!')\n})\n```\n\n:::\n\n:::tab[Python]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Flask web-server:\n\n```python\n@app.route('/profile/delete', methods=['GET'])\ndef delete_post(post_id):\n  user = session['user']\n    \n  with database() as db:\n    db.execute('delete from users where id = ?', user['id'])\n    del session['user']\n      \n  return redirect('/')\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are easily added in Flask web-server by registering the `CSRFProtect` extension:\n\n```python\nfrom flask import Flask\nfrom flask_wtf.csrf import CSRFProtect\n\napp  = Flask(__name__)\ncsrf = CSRFProtect(app)\n```\n\nAny HTML forms generated by templates should add the relevant form field as follows:\n\n```html\n<form method=\"post\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\"/>\n</form>\n```\n\nAJAX requests can similarly be amended to include anti-forgery tokens in the following manner:\n\n```html\n<script type=\"text/javascript\">\n    var csrf_token = \"{{ csrf_token() }}\";\n\n    $.ajaxSetup({\n        beforeSend: function(xhr, settings) {\n            if (!/^(GET|HEAD|OPTIONS|TRACE)$/i.test(settings.type) && !this.crossDomain) {\n                xhr.setRequestHeader(\"X-CSRFToken\", csrf_token);\n            }\n        }\n    });\n</script>\n```\n\nIn the Django web-framework, CSRF protection is provided by the `django.middleware.csrf.CsrfViewMiddleware` class.\n\n:::\n\n:::tab[React]\n\nFor example, consider the following implementation of a \"Logout\" function in React:\n\n```jsx\nclass Logout extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.updateLoginStatus = props.updateLoginStatus\n  }\n\n  async logout() {\n    \n    // Invalidate the session on the server.\n    const response = await fetch(\"/logout\", {\n      method: 'GET'\n    })\n\n    if (response.ok) {\n      \n      // Set the login status to \"Logged out\" and the username to null in the component state.\n      this.updateLoginStatus(false, null)\n    }\n  }\n\n  render() {\n    return (\n      <a onClick={() => { this.logout() }}>\n        Logout\n      </a>\n    )\n  }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `www.yoursite.com/logout`, that user will be logged out before \nthey are aware of what is happening. For this reason, it's recommended to implement logout functionality via `PUT` or \n`DELETE` requests. The situation becomes even more dire in the event of e.g. account deletion functionality: you will \nhave real problems if attackers can trick users into accidentally deleting their accounts.\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects. These tokens are called **anti-forgery tokens**. \n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nsent to the browser. The server will compare the token attached to any inbound requests with the original value. \nIf the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens should be generated on the web-server and provided to client-side code in some fashion - typically\nthey are written out as `<meta>` tags in the HTML header, or loaded asynchronously via an AJAX call. Any subsequent AJAX \ncalls should pass the token back in an HTTP header, so the server can validate it:\n\n```jsx\nclass Logout extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.updateLoginStatus = props.updateLoginStatus\n  }\n\n  async logout() {\n    \n    // Invalidate the session on the server, passing back the anti-forgery token\n    // in an HTTP header. The browser will attach a matching value in a cookie.\n    const response = await fetch(\"/logout\", {\n      method: 'DELETE',\n      headers: {\n        'CSRF-Token' : this.props.csrf\n      }\n    })\n\n    if (response.ok) {\n      \n      // Set the login status to \"Logged out\" and the username to null in the component state.\n      this.updateLoginStatus(false, null)\n    }\n  }\n\n  render() {\n    return (\n      <a onClick={() => { this.logout() }}>\n        Logout\n      </a>\n    )\n  }\n}\n```\n\nIf you generate HTTP requests using HTML forms, you should add the anti-forgery token in a hidden field of the form:\n\n```jsx\nfunction Comment(props) {\n  return (\n    <div className=\"post\">\n      <form action=\"/comment\" method=\"POST\">\n        <textarea name=\"comment\" placeholder=\"What's on your mind?\"/>\n        <input type=\"hidden\" name=\"_csrf\" value={props.csrf} />\n        <button type=\"submit\">Add Comment</button>\n      </form>\n    </div>\n  )\n}\n```\n\nThe name of the header and the name of the hidden form field will depend on what library you are using to generate your\nanti-forgery tokens on the server-side. Consult the library's documentation for details, and update your React code\naccordingly.\n\n:::\n\n:::tab[Scala]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Play framework:\n\n```scala\nGET   /profile/delete          controllers.Profile.delete\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nIn the Play framework, CSRF protection is enabled automatically. The `play.filters.csrf.CSRFFilter` will add an\nanti-forgery token to responses securely:\n\n```scala\n  def addTokenToResponse(request: RequestHeader, result: Result): Result = {\n    request.attrs.get(CSRF.Token.InfoAttr) match {\n      case None =>\n        filterLogger.warn(\"[CSRF] No token found on request!\")\n        result\n      case Some(tokenInfo) if {\n            tokenIsHttpOnly &&                             // the token is not going to be accessed and used from JS\n            result.body.isInstanceOf[HttpEntity.Strict] && // the body was fully rendered\n            !tokenInfo.wasRendered                         // the token was not rendered in the body of the response\n          } =>\n        filterLogger.trace(\"[CSRF] Not emitting CSRF token because token was never rendered\")\n        result\n      case _ if isCacheableBySharedCache(result) =>\n        filterLogger.trace(\"[CSRF] Not adding token to response that might get cached by a shared cache (e.g. proxies)\")\n        result\n      case Some(tokenInfo) =>\n        val Token(tokenName, tokenValue) = tokenInfo.toToken\n        filterLogger.trace(\"[CSRF] Adding token to result: \" + result)\n        csrfConfig.cookieName\n          .map { name =>\n            result.withCookies(\n              Cookie(\n                name,\n                tokenValue,\n                path = sessionConfiguration.path,\n                domain = sessionConfiguration.domain,\n                secure = csrfConfig.secureCookie,\n                httpOnly = csrfConfig.httpOnlyCookie,\n                sameSite = csrfConfig.sameSiteCookie\n              )\n            )\n          }\n          .getOrElse {\n            val newSession = result.session(request) + (tokenName -> tokenValue)\n            result.withSession(newSession)\n          }\n    }\n  }\n```\n\nYou can access token to add it to your forms and AJAX requests by calling `CSRF.getToken.get`, or using the built-in\nhelper methods for form-building:\n\n```scala\n@form(routes.ItemsController.save()) {\n    @CSRF.formField\n    ...\n}\n```\n\nWhich will render a form like:\n\n```html\n<form method=\"POST\" action=\"/items\">\n   <input type=\"hidden\" name=\"csrfToken\" value=\"1234567890abcdef\"/>\n   ...\n</form>\n```\n\n:::\n\n:::tab[Go]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Gorilla web toolkit:\n\n```go\nfunc DeleteProfileHandler(response http.ResponseWriter, request *http.Request) {\n  session, err := session.Get(request, \"session\")\n\n  if err != nil {\n    http.Error(response, \"Error loading session\", http.StatusInternalServerError)\n    return\n  }\n\n  userId := session.Values[\"userId\"]\n\n  deleteUser(userId)\n\n  session.Options.MaxAge = -1\n\n  err = session.Save(request, response)\n\n  if err != nil {\n    http.Error(response, \"Error saving session\", http.StatusInternalServerError)\n    return\n  }\n\n  http.Redirect(response, request, \"/\", http.StatusOK)\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are easily added using the `gorilla/csrf` package:\n\n```go\nfunc main() {\n  router := mux.NewRouter()\n  router.HandleFunc(\"/signup\", ShowSignupForm)\n\n  // All POST requests without a valid token will return HTTP 403 Forbidden.\n  // We should also ensure that our mutating (non-idempotent) handler only\n  // matches on POST requests. We can check that here, at the router level, or\n  // within the handler itself via r.Method.\n  router.HandleFunc(\"/signup/post\", SubmitSignupForm).Methods(\"POST\")\n\n  // Add the middleware to your router by wrapping it.\n  http.ListenAndServe(\":8000\",\n  csrf.Protect([]byte(\"32-byte-long-auth-key\"))(router))\n  \n  // PS: Don't forget to pass csrf.Secure(false) if you're developing locally\n  // over plain HTTP (just don't leave it on in production).\n}\n```\n\nAny HTML forms generated by templates should add the relevant form field as follows:\n\n```go\nfunc ShowSignupForm(w http.ResponseWriter, r *http.Request) {\n  // signup_form.tmpl just needs a {{ .csrfField }} template tag for\n  // csrf.TemplateField to inject the CSRF token into. Easy!\n  t.ExecuteTemplate(w, \"signup_form.tmpl\", map[string]interface{}{\n      csrf.TemplateTag: csrf.TemplateField(r),\n  })\n}\n```\n\nAJAX requests can similarly be amended to include anti-forgery tokens in the following manner:\n\n```javascript\n// Find the CSRF token.\nlet csrfToken = document.getElementsByName(\"gorilla.csrf.Token\")[0].value\n\n// Add the CSRF token to e.g. the Axios AJAX client.\nconst instance = axios.create({\n  baseURL: \"https://example.com/api/\",\n  timeout: 1000,\n  headers: { \"X-CSRF-Token\": csrfToken }\n})\n```\n\n:::\n\n:::tab[PHP]\n\nFor example, here's a potentially dangerous PHP script that deletes a user's account based on a `GET` request:\n\n```php\n<?php\nif (isset($_GET['deleteAccount'])) {\n    deleteUserAccount($_SESSION['userId']);\n    header('Location: /');\n}\n?>\n```\n\nBy having such code, a malicious actor could trick a user's browser into making a request to a URL with `?deleteAccount=true`, leading to the unintended deletion of their account. To avoid this, use a `POST` request:\n\n```php\n<?php\nif (isset($_POST['deleteAccount'])) {\n    deleteUserAccount($_SESSION['userId']);\n    header('Location: /');\n}\n?>\n\n<form method=\"POST\" action=\"\">\n    <button name=\"deleteAccount\" value=\"true\">Delete Account</button>\n</form>\n```\n\n## Anti-Forgery Tokens in PHP\n\nTo mitigate CSRF attacks in PHP applications, use anti-forgery tokens. One popular way is to generate and validate CSRF tokens using PHP sessions.\n\n1. **Generating the CSRF token**:\n   \n```php\nsession_start();\n\nif (empty($_SESSION['csrf_token'])) {\n    $_SESSION['csrf_token'] = bin2hex(random_bytes(32));\n}\n\n$csrf_token = $_SESSION['csrf_token'];\n```\n\n2. **Including the token in forms**:\n\n```html\n<form method=\"POST\" action=\"\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"<?php echo $csrf_token; ?>\">\n    <button type=\"submit\" name=\"submitAction\">Perform Action</button>\n</form>\n```\n\n3. **Validating the token**:\n\n```php\nif ($_SERVER['REQUEST_METHOD'] !== 'GET' && $_SERVER['REQUEST_METHOD'] !== 'HEAD') {\n    if (!isset($_SESSION['csrf_token']) || !isset($_POST['csrf_token'])) {\n        // Token not provided or not yet generated for session - potential CSRF attack.\n        die('Invalid request.');\n    }\n\n    $expectedToken = $_SESSION['csrf_token'];\n    $userToken = $_POST['csrf_token'];\n\n    if (!hash_equals($expectedToken, $userToken)) {\n        // Token validation failed, potential CSRF attack.\n        die('Invalid request.');\n    }\n\n    // Continue with the intended action\n    performSensitiveAction();\n}\n```\n\nUsing anti-forgery tokens ensures that the action is only executed if the request originates from your domain and the token matches the one in the user's session.\n\n:::\n\n::::\n\n### Ensure Cookies Are Sent With The SameSite Cookie Attribute\n\nThe `Same-Site` cookie attribute instructs the browser whether to send cookies with requests initiated by third-party \ndomains. Since anti-forgery tokens are typically validated by comparing the token value sent in the HTML form with a \nvalue in a cookie, they are only effective when the `Same-Site` attribute is set appropriately.\n\nA `Same-Site` value of `Strict` will mean than *any* request initiated by a third-party domain to *your* domain will not \nhave any cookies attacked. This is the most secure setting, since it prevents malicious sites attempting to perform\nharmful actions under a user's session.\n\nA value of `Lax` permits `GET` request from a third-party domain to *your* domain to have cookies attached - but *only* \n`GET` requests. With this setting a user will not have to sign in again to your site if they follow a link from another \nsite (say, Google search results). This makes for a friendlier user-experience - but make sure your `GET` requests are \nside effect free!\n\n## Further Considerations\n\n* Make sure your cookies cannot be accessed in JavaScript, and are only sent over HTTPS. This is done by adding the `HttpOnly` \n  and `Secure` attributes to each cookie.\n  \n* Many sites require a secondary authentication step, or require re-confirmation of login details when the user performs \n  a sensitive action. (Think of a typical  password reset page - usually the user will have to specify their old \n  password before setting a new password.) Not only does this protect users who may accidentally leave themselves \n  logged in on publicly accessible computers, but it also greatly reduces the possibility of CSRF attacks.\n  \n* Ensuring `GET` requests are side effect free is part of a series of design principles called *Representation State \n  Transfer (REST)* that assign certain types of action (view, create, delete, update) to different HTTP verbs. \n  REST insists that GET requests are used only to *view* resources. \n  \n## CWEs\n\n* [CWE-352](https://cwe.mitre.org/data/definitions/352.html)"
                            },
                            "helpUri": "https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a6-Security_Misconfiguration",
                            "id": "cors-disabled/abf6a56d9c58899d4ed5c9cd3106f0c5",
                            "name": "Cross-Site Request Forgery: Overly Permissive Cors Policy In Add_csp_headers",
                            "properties": {
                                "precision": "very-high",
                                "security-severity": "4",
                                "tags": [
                                    "ng-sast",
                                    "CVSS 4",
                                    "CWE 942",
                                    "Cross-Site Request Forgery",
                                    "OWASP 2021 a05-security-misconfiguration",
                                    "OWASP a05-2021-security-misconfiguration",
                                    "OWASP a6-security-misconfiguration"
                                ]
                            },
                            "shortDescription": {
                                "text": "Cross-Site Request Forgery: Overly Permissive CORS Policy in add_csp_headers"
                            }
                        },
                        {
                            "defaultConfiguration": {
                                "enabled": true,
                                "level": "error",
                                "rank": -1
                            },
                            "fullDescription": {
                                "text": "Attacker-controlled data is deserialized. This indicates an insecure deserialization vulnerability."
                            },
                            "help": {
                                "markdown": "Attacker-controlled data is deserialized. This indicates an insecure deserialization vulnerability.\n\n# Insecure Deserialization\n\n*Serialization* describes the process of writing in-memory code object to a binary form, typically for storage to disk\nor transmission across a network. *Deserialization* is the opposite process: transforming incoming binary data into\nan in-memory code object. If your code uses deserialization, you need to ensure it is not deserializing untrusted input:\nthe presents an opportunity for an attacker to inject malicious code into your web-server at runtime.\n\n::::tabs\n\n:::tab[Java]\n\nJava objects can be serialized into a stream of bytes using the `java.io.ObjectOutputStream` class. Most built-in Java\nclasses are serializable, and you can customize how your own classes are serialized by implementing the \n`java.io.Serialazable` interface, and, if needs be, writing your own serialization code.\n\nSerialization is used during *Remote Method Invocation* (RMI) calls, and provides an easy way to store data structures \nto disk for later us. However, if you unserialize data coming from an untrusted source - like binary data attached to an\nHTTP request - this gives an attacker an opportunity to inject malicious code directly into your Java runtime.\n\n```java\npublic class DeserializationServlet extends HttpServlet\n{\n    protected void service(HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        try {\n            ServletInputStream stream       = request.getInputStream();\n            ObjectInputStream  objectStream = new ObjectInputStream(stream);\n\n            // This object is taken from an untrusted source and is potentially malicious.\n            Object deserialized = objectStream.readObject();\n        }\n        catch (ClassNotFoundException ex) {\n\n        }\n    }\n}\n```\n\n## Mitigation\n\nThe easiest way to avoid deserialization vulnerabilities is to avoid using serialization altogether. If you need to \naccept structured data from an HTTP request, XML or JSON are more common formats and less prone to malicious use.\n\nIf you *do* use serialization, ensure your byte streams come from a trusted source, deserialize to an expected form,\nand cannot be tampered with. Your code should make assertions about the class of each object as it is deserialized, as\na way of reducing the attack surface:\n\n```java\nServletInputStream stream = request.getInputStream();\n            \n// Restricting the classes we deserialize to reduces the risk.\nObjectInputStream objectStream = new ObjectInputStream(stream) {\n    protected Class<?> resolveClass(ObjectStreamClass osc) throws IOException, ClassNotFoundException {\n        if (!osc.getName().equals(java.util.HashMap.class.getName())) {\n            throw new InvalidClassException(\"Unexpected class\", osc.getName());\n        }\n        \n        return super.resolveClass(osc);\n    }\n};\n\nObject deserialized = objectStream.readObject();\n```\n\nTo detect tampering, you can generate a digital signature when you write out a byte stream for later use, then verify\nthat signature when reading the objects back in:\n\n```java\n/**\n * Generate a digital signature for some binary data, so we can verify it has not\n * been tampered with if it is returned from an untrusted source.\n */\npublic static String signData(byte[] data) throws Exception\n{\n    KeyPair keyPair = getKeyPair();\n\n    Signature signature = Signature.getInstance(\"SHA1WithRSA\");\n    signature.initSign(keyPair.getPrivate());\n    signature.update(data);\n\n    byte[] bytes = signature.sign();\n    \n    return Base64.getEncoder().encodeToString(bytes);\n}\n```\n\n:::\n\n:::tab[C#]\n\n## Serialization in C#\n\nThere is a number of ways to serialize data in ASP.NET: the `BinaryFormatter` can serializes and deserializes an object,\nor an entire graph of connected objects, in binary format. There are also a number of other serializers with more \nspecific uses:\n\n* `System.Runtime.Serialization.Formatters.Soap.SoapFormatter` - for serialization to and from SOAP format.\n* `System.Runtime.Serialization.NetDataContractSerializer` - for serialization to and from XML format.\n* `System.Web.UI.ObjectStateFormatter` - used for page state persistence.\n* `System.Web.UI.LosFormatter` - serializes the view state for a Web Forms page.\n\nEach of these allow an attacker to perform denial-of-service attacks, read sensitive information and achieve remote\ncode execution if they are used to unserialize untrusted contents.\n\n## Mitigation\n\nThe easiest way to avoid deserialization vulnerabilities is to avoid using serialization altogether. If you need to \naccept structured data from an HTTP request, XML or JSON are more common formats and less prone to malicious use. .NET \noffers several built-in serializers that can handle untrusted data safely:\n\n* `System.Xml.Serialization.XmlSerializer` and `System.Runtime.Serialization.DataContractSerializer` to serialize object graphs into and from XML. \n* `System.Io.BinaryReader` and `System.Io.BinaryWriter` for writing and reading binary data.\n* The `System.Text.Json` APIs to serialize object graphs into JSON.\n\nIf your legacy code uses any of the module mentioned in the previous section, you should ensure your data streams come \nfrom a trusted source, deserialize to an expected form, and cannot be tampered with. You should never unserialize data \nsent from an HTTP request.\n\nHere's how to restrict the permitted types the `BinaryFormatter` can deserialize to:\n\n```csharp\nsealed class TypeRestrictionBinder : SerializationBinder\n{\n    // These are the only types we will allow to be unserialized when reading a data stream.\n    private static string[] permittedTypes = { \"Type1\", \"Type2\", \"Type3\" };\n\n    public override Type BindToType(string assemblyName, string typeName)\n    {\n        if (!(permittedTypes.Contains(typeName)))\n        {\n            throw new SerializationException($\"Not a permitted type: {typeName}\"); \n        }\n        \n        return Assembly.Load(assemblyName).GetType(typeName);\n    }\n}\n\nvar deserializer    = new BinaryFormatter();\ndeserializer.Binder = new TypeRestrictionBinder();\ndeserializer.Deserialize(stream);\n```\n\n:::\n\n:::tab[Python]\n\n## Serialization in Python\n\nThere are a number of ways to serialize data in Python: the `pickle` module has `dumps(...)` and `loads(...)` functions\nto write in-memory objects to binary form and read them back in. The NumPy library is frequently used to write and read\narray data, and the Google's Protobuf library allows you to serialize objects in a language-neutral way.\n\nUnserializing data using `pickle.loads(...)` function - or using the `shelve` module, which is backed by `pickle` - can\nresult in arbitrary code execution. Any class which defines a method called `__setstate__(state)` will have that method\ninvoked when the data-stream is unpickled. This will allow an attacker to execute code on your server if they you \nunpickle untrusted content.\n\nDeserialization vulnerabilities can also occur when reading in YAML (*Yet Another Markup Language*) files. YAML is a popular\nfile format for storing configuration values, but the default loader in the `yaml` module allows the YAML file to \nspecify which classes YAML files deserialize to using the `!!python/object` tag:\n\n```python\nimport yaml\n\nclass Hero:\n  def __init__(self, name, hp, sp):\n    self.name = name\n    self.hp = hp\n    self.sp = sp\n\n# This will return an instance of the Hero class      \nyaml.load(\"\"\"\n!!python/object:__main__.Hero\nname: Welthyr Syxgon\nhp: 1200\nsp: 0\n\"\"\", Loader=yaml.Loader)\n```\n\n## Mitigation\n\nThe easiest way to avoid deserialization vulnerabilities is to avoid using serialization altogether. If you need to \naccept structured data from an HTTP request, XML or JSON are more common formats and less prone to malicious use.\n\nYou can securely deserialize YAML files by turning off the support for custom classes using the `yaml.SafeLoader` class:\n\n```python\n\n# This will return an array with form ['First', 'Second', 'Third'], but will\n# not support custom classes.\nyaml.load(\"\"\"\n- First\n- Second\n- Third\n\"\"\", Loader=yaml.SafeLoader)\n```\n\nIf you *do* use the `pickle` module, you should ensure your byte or object streams come from a trusted source, \ndeserialize to an expected form, and cannot be tampered with. Since code can be executed during the unpickling process,\nyou should never unpickle data sent from an HTTP request.\n\nTo detect tampering of pickled objects, you should generate a digital signature when you write out a byte stream for \nlater use, then verify that signature when reading the objects back in:\n\n```python\nimport pickle, hmac, hashlib\n\n# Only those possessing the secret key will be able to generate a valid signature.\nsecret_key = b'0c07187d-5fd7-486f-a3a2-699200a623a5'\n\n# The signature can be shared publicly, along with the serialized data.\npickled_data = pickle.dumps(data)\nsignature    = hmac.new(secret_key, pickled_data, hashlib.sha1).hexdigest()\n\n# Here we recalculate the signature to check if the data has been tampered with.\nuntrusted_data         = pickled_data\nrecalculated_signature = hmac.new(secret_key, untrusted_data, hashlib.sha1).hexdigest()\n\n# A change in signature indicates this data isn't safe to deserialize.\nif signature != recalculated_signature:\n  raise Exception('Data has been tampered with')\n\n# If the newly calculated signature is the same as the old value, the data has not\n# been tampered with. (Only those in possession of the signing key will be able to\n# generate a valid signature.)\npickle.dumps(untrusted_data)\n```\n\n:::\n\n:::tab[Scala]\n\n## Serialization in Scala\n\nScala objects can be serialized into a stream of bytes using the `java.io.ObjectOutputStream` class. Most built-in Scala\nobjects and classes extend the `scala.Serializable` trait, meaning they are easily transformed into binary data. You can\nextend the trait in the same way for your own custom classes.\n\nIn addition to this, there are also a number of third-party libraries like Google Protocol Buffers that can serialize \nand deserialize objects in a language-neutral way - allowing you to send and receive objects to and from other \nplatforms.\n\nSerialization is used during *Remote Method Invocation* (RMI) calls in distributed computing environments. However, if \nyou unserialize data coming from an untrusted source, this gives an attacker an opportunity to inject malicious code \ndirectly into your Java Virtual Machine:\n\n```scala\ndef uploadObject = Action { request =>\n  val bytes : ByteString = request.body.asRaw.get.asBytes().get\n\n  // Since this object is taken from the HTTP request, we are deserializing a potentially malicious object.\n  val deserializedObject = new ObjectInputStream(new ByteArrayInputStream(bytes.toArray)).readObject()\n\n  Ok(\"Object uploaded\")\n}\n```\n\n## Mitigation\n\nThe easiest way to avoid deserialization vulnerabilities is to avoid using serialization altogether. If you need to \naccept structured data from an HTTP request, XML or JSON are more common formats and less prone to malicious use.\n\nIf you *do* use serialization, you should ensure your byte or object streams come from a trusted source, deserialize to \nan expected form, and cannot be tampered with. At a minimum, your code should make assertions about the class of each \nobject as it is deserialized, as a way of reducing the attack surface:\n\n```scala\ndef uploadObject = Action { request =>\n  val bytes : ByteString = request.body.asRaw.get.asBytes().get\n\n  val deserializedObject = new ObjectInputStream(new ByteArrayInputStream(bytes.toArray)).readObject()\n\n  // Checking the type of the object reduces some of the risks.\n  if (!deserialzedObject.isInstanceOf(MyExpectedType.class)) {\n    Redirect(\"/\")\n  }\n  else {\n    Ok(\"Object uploaded\")\n  }\n}\n```\n\nTo detect tampering, you can generate a digital signature when you write out a byte stream for later use, then verify\nthat signature when reading the objects back in:\n\n```scala\n/**\n * Generate a signature for some bytes we wish to secure using a the HMAC-SHA1 algorithm.\n * Only we will know the secret key, so we can detect data-tampering by recalculating\n * the signature at a later point in time.\n */\ndef sign(data: Array[Byte], secretKey: String): String = {\n  val mac = Mac.getInstance(\"HmacSHA1\")\n  mac.init(new SecretKeySpec(secretKey.getBytes(StandardCharsets.UTF_8), \"HmacSHA1\"))\n  Codecs.toHexString(mac.doFinal(data))\n}\n```\n\n:::\n\n:::tab[Go]\n\n## Serialization in Go\n\nThere are a number of ways to serialize data in Go. The built-in `encoding/gob` encodes binary streams of data, and\nthe `google.golang.org/protobuf` package implements the Protocol Buffers mechanism for serializing data to and from \nother languages. There are also third-party libraries like Cap'n Proto that skip the encoding and decoding step \nentirely, taking advantage of the fact that structs are encoded in Go in a platform-independent manner.\n\nIf the serialization library you use allows invocation of methods during the deserialization process, this gives an\nattacker a way to launch Remote Code Execution (RPC) attacks. \n\nSerialization is used to allow remote procedure calls on, for example, a grid computing application. Go is often for big \ndata tasks, and using remote procedure calls to distribute large processing tasks is a common approach. In this \narchitectural model you are responsible for ensuring all remote calls come from authorized \n servers.\n\n## Mitigation\n\nTo avoid deserialization vulnerabilities ensure your serialization library does not invocation of methods during the \ndeserialization process. You should also ensure your byte or object streams come from a trusted source, deserialize to \nan expected form, and cannot be tampered with. \n\nTo detect tampering of serialized objects, you can generate a digital signature when you write out a byte stream for \nlater use, then verify that signature when reading the objects back in. The `crypto/dsa` package allows you easily\ngenerate digital signatures for structs in Go:\n\n```go\nimport (\n  \"crypto/dsa\"\n}\n\n// sign generates a digital signature as a unique fingerprint for a byte stream.\nfunc sign(hash []byte, key *dsa.PrivateKey) ([]byte, error) {\n  var s dsaSignature\n  s.R, s.S, err = dsa.Sign(rand.Reader, key, hash)\n  \n  if err != nil {\n    return nil, err\n  }\n\n  return asn1.Marshal(s)\n}\n\n// verify checks digital signature in order to detect tampering.\nfunc verify(hash []byte, key *dsa.PublicKey, signatureFile string) ([]byte, error) {\n  r, s, err := ParseSignatureFromFile(signatureFile)\n  \n  if err != nil {\n    return nil, err\n  }\n  \n  if dsa.Verify(pub, hash, r, s) {\n    return []byte(\"Verified OK\\n\"), nil\n  } else {\n    return nil, errors.New(\"Verification Failure\")\n  }\n}\n\n```\n\n:::\n\n:::tab[PHP]\n\nIn PHP, the `serialize()` function converts an object into a storable representation (a string), while the `unserialize()` function restores the original object from its stored representation. However, using `unserialize()` on data coming from untrusted sources exposes a PHP application to code injection and remote code execution.\n\nConsider the following simple vulnerable example:\n\n```php\n$data = $_GET['data'];\n$object = unserialize($data);\n```\n\nBy passing a specially crafted serialized object, an attacker can potentially exploit vulnerable `__wakeup()` or `__destruct()` magic methods in PHP objects to trigger execution of arbitrary code.\n\n## Mitigation\n\n1. **Avoid Deserialization**: The safest approach is not to deserialize data from untrusted sources. Use safer data interchange formats like JSON (`json_encode()`, `json_decode()`) or XML. The `json_decode()` function, for example, does not invoke any object constructors or methods, making it inherently safer:\n\n```php\n$data = $_GET['data'];\n$array = json_decode($data, true);\n```\n\n2. **Restrict Object Instantiation**: If you must use `unserialize()`, restrict which objects can be instantiated by providing a list of allowed classes using the second parameter of `unserialize()`:\n\n```php\n$allowed_classes = ['MySafeClass1', 'MySafeClass2'];\n$object = unserialize($data, [\"allowed_classes\" => $allowed_classes]);\n```\n\nEnsure that all methods in these classes can deal safely with untrusted inputs.\n\n3. **Validation and Integrity Checks**: Before deserializing, validate the serialized data or use cryptographic techniques to ensure its integrity and authenticity. For instance, you can sign the serialized data with a HMAC, and verify integrity before deserialization:\n\n```php\nfunction generateHMAC($data, $key) {\n    return hash_hmac('sha256', $data, $key);\n}\n\n// Generating HMAC\n$serializedData = serialize($someObject);\n$hmac = generateHMAC($serializedData, SECRET_KEY);\n\n// Verifying HMAC before deserialization\nif (hash_equals(generateHMAC($receivedData, SECRET_KEY), $receivedHMAC)) {\n    $object = unserialize($receivedData);\n} else {\n    die('Data integrity check failed.');\n}\n```\n\nIn the above example, `SECRET_KEY` is a secret cryptographic key only known to the server. The HMAC ensures that the serialized data has not been tampered with by an attacker.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-502](https://cwe.mitre.org/data/definitions/502.html)**\n\n**[OWASP-A8](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A8-Insecure_Deserialization)**",
                                "text": "Attacker-controlled data is deserialized. This indicates an insecure deserialization vulnerability.\n\n# Insecure Deserialization\n\n*Serialization* describes the process of writing in-memory code object to a binary form, typically for storage to disk\nor transmission across a network. *Deserialization* is the opposite process: transforming incoming binary data into\nan in-memory code object. If your code uses deserialization, you need to ensure it is not deserializing untrusted input:\nthe presents an opportunity for an attacker to inject malicious code into your web-server at runtime.\n\n::::tabs\n\n:::tab[Java]\n\nJava objects can be serialized into a stream of bytes using the `java.io.ObjectOutputStream` class. Most built-in Java\nclasses are serializable, and you can customize how your own classes are serialized by implementing the \n`java.io.Serialazable` interface, and, if needs be, writing your own serialization code.\n\nSerialization is used during *Remote Method Invocation* (RMI) calls, and provides an easy way to store data structures \nto disk for later us. However, if you unserialize data coming from an untrusted source - like binary data attached to an\nHTTP request - this gives an attacker an opportunity to inject malicious code directly into your Java runtime.\n\n```java\npublic class DeserializationServlet extends HttpServlet\n{\n    protected void service(HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        try {\n            ServletInputStream stream       = request.getInputStream();\n            ObjectInputStream  objectStream = new ObjectInputStream(stream);\n\n            // This object is taken from an untrusted source and is potentially malicious.\n            Object deserialized = objectStream.readObject();\n        }\n        catch (ClassNotFoundException ex) {\n\n        }\n    }\n}\n```\n\n## Mitigation\n\nThe easiest way to avoid deserialization vulnerabilities is to avoid using serialization altogether. If you need to \naccept structured data from an HTTP request, XML or JSON are more common formats and less prone to malicious use.\n\nIf you *do* use serialization, ensure your byte streams come from a trusted source, deserialize to an expected form,\nand cannot be tampered with. Your code should make assertions about the class of each object as it is deserialized, as\na way of reducing the attack surface:\n\n```java\nServletInputStream stream = request.getInputStream();\n            \n// Restricting the classes we deserialize to reduces the risk.\nObjectInputStream objectStream = new ObjectInputStream(stream) {\n    protected Class<?> resolveClass(ObjectStreamClass osc) throws IOException, ClassNotFoundException {\n        if (!osc.getName().equals(java.util.HashMap.class.getName())) {\n            throw new InvalidClassException(\"Unexpected class\", osc.getName());\n        }\n        \n        return super.resolveClass(osc);\n    }\n};\n\nObject deserialized = objectStream.readObject();\n```\n\nTo detect tampering, you can generate a digital signature when you write out a byte stream for later use, then verify\nthat signature when reading the objects back in:\n\n```java\n/**\n * Generate a digital signature for some binary data, so we can verify it has not\n * been tampered with if it is returned from an untrusted source.\n */\npublic static String signData(byte[] data) throws Exception\n{\n    KeyPair keyPair = getKeyPair();\n\n    Signature signature = Signature.getInstance(\"SHA1WithRSA\");\n    signature.initSign(keyPair.getPrivate());\n    signature.update(data);\n\n    byte[] bytes = signature.sign();\n    \n    return Base64.getEncoder().encodeToString(bytes);\n}\n```\n\n:::\n\n:::tab[C#]\n\n## Serialization in C#\n\nThere is a number of ways to serialize data in ASP.NET: the `BinaryFormatter` can serializes and deserializes an object,\nor an entire graph of connected objects, in binary format. There are also a number of other serializers with more \nspecific uses:\n\n* `System.Runtime.Serialization.Formatters.Soap.SoapFormatter` - for serialization to and from SOAP format.\n* `System.Runtime.Serialization.NetDataContractSerializer` - for serialization to and from XML format.\n* `System.Web.UI.ObjectStateFormatter` - used for page state persistence.\n* `System.Web.UI.LosFormatter` - serializes the view state for a Web Forms page.\n\nEach of these allow an attacker to perform denial-of-service attacks, read sensitive information and achieve remote\ncode execution if they are used to unserialize untrusted contents.\n\n## Mitigation\n\nThe easiest way to avoid deserialization vulnerabilities is to avoid using serialization altogether. If you need to \naccept structured data from an HTTP request, XML or JSON are more common formats and less prone to malicious use. .NET \noffers several built-in serializers that can handle untrusted data safely:\n\n* `System.Xml.Serialization.XmlSerializer` and `System.Runtime.Serialization.DataContractSerializer` to serialize object graphs into and from XML. \n* `System.Io.BinaryReader` and `System.Io.BinaryWriter` for writing and reading binary data.\n* The `System.Text.Json` APIs to serialize object graphs into JSON.\n\nIf your legacy code uses any of the module mentioned in the previous section, you should ensure your data streams come \nfrom a trusted source, deserialize to an expected form, and cannot be tampered with. You should never unserialize data \nsent from an HTTP request.\n\nHere's how to restrict the permitted types the `BinaryFormatter` can deserialize to:\n\n```csharp\nsealed class TypeRestrictionBinder : SerializationBinder\n{\n    // These are the only types we will allow to be unserialized when reading a data stream.\n    private static string[] permittedTypes = { \"Type1\", \"Type2\", \"Type3\" };\n\n    public override Type BindToType(string assemblyName, string typeName)\n    {\n        if (!(permittedTypes.Contains(typeName)))\n        {\n            throw new SerializationException($\"Not a permitted type: {typeName}\"); \n        }\n        \n        return Assembly.Load(assemblyName).GetType(typeName);\n    }\n}\n\nvar deserializer    = new BinaryFormatter();\ndeserializer.Binder = new TypeRestrictionBinder();\ndeserializer.Deserialize(stream);\n```\n\n:::\n\n:::tab[Python]\n\n## Serialization in Python\n\nThere are a number of ways to serialize data in Python: the `pickle` module has `dumps(...)` and `loads(...)` functions\nto write in-memory objects to binary form and read them back in. The NumPy library is frequently used to write and read\narray data, and the Google's Protobuf library allows you to serialize objects in a language-neutral way.\n\nUnserializing data using `pickle.loads(...)` function - or using the `shelve` module, which is backed by `pickle` - can\nresult in arbitrary code execution. Any class which defines a method called `__setstate__(state)` will have that method\ninvoked when the data-stream is unpickled. This will allow an attacker to execute code on your server if they you \nunpickle untrusted content.\n\nDeserialization vulnerabilities can also occur when reading in YAML (*Yet Another Markup Language*) files. YAML is a popular\nfile format for storing configuration values, but the default loader in the `yaml` module allows the YAML file to \nspecify which classes YAML files deserialize to using the `!!python/object` tag:\n\n```python\nimport yaml\n\nclass Hero:\n  def __init__(self, name, hp, sp):\n    self.name = name\n    self.hp = hp\n    self.sp = sp\n\n# This will return an instance of the Hero class      \nyaml.load(\"\"\"\n!!python/object:__main__.Hero\nname: Welthyr Syxgon\nhp: 1200\nsp: 0\n\"\"\", Loader=yaml.Loader)\n```\n\n## Mitigation\n\nThe easiest way to avoid deserialization vulnerabilities is to avoid using serialization altogether. If you need to \naccept structured data from an HTTP request, XML or JSON are more common formats and less prone to malicious use.\n\nYou can securely deserialize YAML files by turning off the support for custom classes using the `yaml.SafeLoader` class:\n\n```python\n\n# This will return an array with form ['First', 'Second', 'Third'], but will\n# not support custom classes.\nyaml.load(\"\"\"\n- First\n- Second\n- Third\n\"\"\", Loader=yaml.SafeLoader)\n```\n\nIf you *do* use the `pickle` module, you should ensure your byte or object streams come from a trusted source, \ndeserialize to an expected form, and cannot be tampered with. Since code can be executed during the unpickling process,\nyou should never unpickle data sent from an HTTP request.\n\nTo detect tampering of pickled objects, you should generate a digital signature when you write out a byte stream for \nlater use, then verify that signature when reading the objects back in:\n\n```python\nimport pickle, hmac, hashlib\n\n# Only those possessing the secret key will be able to generate a valid signature.\nsecret_key = b'0c07187d-5fd7-486f-a3a2-699200a623a5'\n\n# The signature can be shared publicly, along with the serialized data.\npickled_data = pickle.dumps(data)\nsignature    = hmac.new(secret_key, pickled_data, hashlib.sha1).hexdigest()\n\n# Here we recalculate the signature to check if the data has been tampered with.\nuntrusted_data         = pickled_data\nrecalculated_signature = hmac.new(secret_key, untrusted_data, hashlib.sha1).hexdigest()\n\n# A change in signature indicates this data isn't safe to deserialize.\nif signature != recalculated_signature:\n  raise Exception('Data has been tampered with')\n\n# If the newly calculated signature is the same as the old value, the data has not\n# been tampered with. (Only those in possession of the signing key will be able to\n# generate a valid signature.)\npickle.dumps(untrusted_data)\n```\n\n:::\n\n:::tab[Scala]\n\n## Serialization in Scala\n\nScala objects can be serialized into a stream of bytes using the `java.io.ObjectOutputStream` class. Most built-in Scala\nobjects and classes extend the `scala.Serializable` trait, meaning they are easily transformed into binary data. You can\nextend the trait in the same way for your own custom classes.\n\nIn addition to this, there are also a number of third-party libraries like Google Protocol Buffers that can serialize \nand deserialize objects in a language-neutral way - allowing you to send and receive objects to and from other \nplatforms.\n\nSerialization is used during *Remote Method Invocation* (RMI) calls in distributed computing environments. However, if \nyou unserialize data coming from an untrusted source, this gives an attacker an opportunity to inject malicious code \ndirectly into your Java Virtual Machine:\n\n```scala\ndef uploadObject = Action { request =>\n  val bytes : ByteString = request.body.asRaw.get.asBytes().get\n\n  // Since this object is taken from the HTTP request, we are deserializing a potentially malicious object.\n  val deserializedObject = new ObjectInputStream(new ByteArrayInputStream(bytes.toArray)).readObject()\n\n  Ok(\"Object uploaded\")\n}\n```\n\n## Mitigation\n\nThe easiest way to avoid deserialization vulnerabilities is to avoid using serialization altogether. If you need to \naccept structured data from an HTTP request, XML or JSON are more common formats and less prone to malicious use.\n\nIf you *do* use serialization, you should ensure your byte or object streams come from a trusted source, deserialize to \nan expected form, and cannot be tampered with. At a minimum, your code should make assertions about the class of each \nobject as it is deserialized, as a way of reducing the attack surface:\n\n```scala\ndef uploadObject = Action { request =>\n  val bytes : ByteString = request.body.asRaw.get.asBytes().get\n\n  val deserializedObject = new ObjectInputStream(new ByteArrayInputStream(bytes.toArray)).readObject()\n\n  // Checking the type of the object reduces some of the risks.\n  if (!deserialzedObject.isInstanceOf(MyExpectedType.class)) {\n    Redirect(\"/\")\n  }\n  else {\n    Ok(\"Object uploaded\")\n  }\n}\n```\n\nTo detect tampering, you can generate a digital signature when you write out a byte stream for later use, then verify\nthat signature when reading the objects back in:\n\n```scala\n/**\n * Generate a signature for some bytes we wish to secure using a the HMAC-SHA1 algorithm.\n * Only we will know the secret key, so we can detect data-tampering by recalculating\n * the signature at a later point in time.\n */\ndef sign(data: Array[Byte], secretKey: String): String = {\n  val mac = Mac.getInstance(\"HmacSHA1\")\n  mac.init(new SecretKeySpec(secretKey.getBytes(StandardCharsets.UTF_8), \"HmacSHA1\"))\n  Codecs.toHexString(mac.doFinal(data))\n}\n```\n\n:::\n\n:::tab[Go]\n\n## Serialization in Go\n\nThere are a number of ways to serialize data in Go. The built-in `encoding/gob` encodes binary streams of data, and\nthe `google.golang.org/protobuf` package implements the Protocol Buffers mechanism for serializing data to and from \nother languages. There are also third-party libraries like Cap'n Proto that skip the encoding and decoding step \nentirely, taking advantage of the fact that structs are encoded in Go in a platform-independent manner.\n\nIf the serialization library you use allows invocation of methods during the deserialization process, this gives an\nattacker a way to launch Remote Code Execution (RPC) attacks. \n\nSerialization is used to allow remote procedure calls on, for example, a grid computing application. Go is often for big \ndata tasks, and using remote procedure calls to distribute large processing tasks is a common approach. In this \narchitectural model you are responsible for ensuring all remote calls come from authorized \n servers.\n\n## Mitigation\n\nTo avoid deserialization vulnerabilities ensure your serialization library does not invocation of methods during the \ndeserialization process. You should also ensure your byte or object streams come from a trusted source, deserialize to \nan expected form, and cannot be tampered with. \n\nTo detect tampering of serialized objects, you can generate a digital signature when you write out a byte stream for \nlater use, then verify that signature when reading the objects back in. The `crypto/dsa` package allows you easily\ngenerate digital signatures for structs in Go:\n\n```go\nimport (\n  \"crypto/dsa\"\n}\n\n// sign generates a digital signature as a unique fingerprint for a byte stream.\nfunc sign(hash []byte, key *dsa.PrivateKey) ([]byte, error) {\n  var s dsaSignature\n  s.R, s.S, err = dsa.Sign(rand.Reader, key, hash)\n  \n  if err != nil {\n    return nil, err\n  }\n\n  return asn1.Marshal(s)\n}\n\n// verify checks digital signature in order to detect tampering.\nfunc verify(hash []byte, key *dsa.PublicKey, signatureFile string) ([]byte, error) {\n  r, s, err := ParseSignatureFromFile(signatureFile)\n  \n  if err != nil {\n    return nil, err\n  }\n  \n  if dsa.Verify(pub, hash, r, s) {\n    return []byte(\"Verified OK\\n\"), nil\n  } else {\n    return nil, errors.New(\"Verification Failure\")\n  }\n}\n\n```\n\n:::\n\n:::tab[PHP]\n\nIn PHP, the `serialize()` function converts an object into a storable representation (a string), while the `unserialize()` function restores the original object from its stored representation. However, using `unserialize()` on data coming from untrusted sources exposes a PHP application to code injection and remote code execution.\n\nConsider the following simple vulnerable example:\n\n```php\n$data = $_GET['data'];\n$object = unserialize($data);\n```\n\nBy passing a specially crafted serialized object, an attacker can potentially exploit vulnerable `__wakeup()` or `__destruct()` magic methods in PHP objects to trigger execution of arbitrary code.\n\n## Mitigation\n\n1. **Avoid Deserialization**: The safest approach is not to deserialize data from untrusted sources. Use safer data interchange formats like JSON (`json_encode()`, `json_decode()`) or XML. The `json_decode()` function, for example, does not invoke any object constructors or methods, making it inherently safer:\n\n```php\n$data = $_GET['data'];\n$array = json_decode($data, true);\n```\n\n2. **Restrict Object Instantiation**: If you must use `unserialize()`, restrict which objects can be instantiated by providing a list of allowed classes using the second parameter of `unserialize()`:\n\n```php\n$allowed_classes = ['MySafeClass1', 'MySafeClass2'];\n$object = unserialize($data, [\"allowed_classes\" => $allowed_classes]);\n```\n\nEnsure that all methods in these classes can deal safely with untrusted inputs.\n\n3. **Validation and Integrity Checks**: Before deserializing, validate the serialized data or use cryptographic techniques to ensure its integrity and authenticity. For instance, you can sign the serialized data with a HMAC, and verify integrity before deserialization:\n\n```php\nfunction generateHMAC($data, $key) {\n    return hash_hmac('sha256', $data, $key);\n}\n\n// Generating HMAC\n$serializedData = serialize($someObject);\n$hmac = generateHMAC($serializedData, SECRET_KEY);\n\n// Verifying HMAC before deserialization\nif (hash_equals(generateHMAC($receivedData, SECRET_KEY), $receivedHMAC)) {\n    $object = unserialize($receivedData);\n} else {\n    die('Data integrity check failed.');\n}\n```\n\nIn the above example, `SECRET_KEY` is a secret cryptographic key only known to the server. The HMAC ensures that the serialized data has not been tampered with by an attacker.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-502](https://cwe.mitre.org/data/definitions/502.html)**\n\n**[OWASP-A8](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A8-Insecure_Deserialization)**"
                            },
                            "helpUri": "https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A8-Insecure_Deserialization",
                            "id": "deserialization-attacker-controlled/5a0f3a67399030e2db46c0ae489e2615",
                            "name": "Deserialization: Attacker-Controlled Data Used In Unsafe Deserialization Function In Actions.py",
                            "properties": {
                                "precision": "very-high",
                                "security-severity": "8",
                                "tags": [
                                    "ng-sast",
                                    "CVSS 8",
                                    "CWE 502",
                                    "Deserialization",
                                    "OWASP 2021 a08-software-and-data-integrity-failures",
                                    "OWASP a08-2021-software-and-data-integrity-failures",
                                    "OWASP a8-insecure-deserialization"
                                ]
                            },
                            "shortDescription": {
                                "text": "Deserialization: Attacker-controlled Data Used in Unsafe Deserialization Function in actions.py"
                            }
                        },
                        {
                            "defaultConfiguration": {
                                "enabled": true,
                                "level": "note",
                                "rank": -1
                            },
                            "fullDescription": {
                                "text": "The same file path is used sequentially first in an existence or file property check and then in a read or write operation. This indicates a time-of-check time-of-use race condition. By sending multiple concurrent requests, an attacker can potentially subvert the existence or file property check in the timing window between the two file operations."
                            },
                            "help": {
                                "markdown": "The same file path is used sequentially first in an existence or file property check and then in a read or write operation. This indicates a time-of-check time-of-use race condition. By sending multiple concurrent requests, an attacker can potentially subvert the existence or file property check in the timing window between the two file operations.\n\n# Race Condition \n\nA **race condition** appears when a program state changed between checking and accessing the state. \n\nThe impacts of race conditions can vary from deadlocks, where a program is not responding because multiple threads are\nblocking each other to reading files to (remote) code execution.\n\nA common kind of race conditions is often referred to as **Time-of-check Time-of-use** (TOCTOU). These are bugs where a \nprogram is first checking whether a condition holds and afterwards performs an action based on that, when it's not \nguaranteed that this condition never changes in the time that elapses between the **check** and the **use**.\n\n## `Time-of-check Time-of-use` (TOCTOU) With File System Operations\n\nFor example, applications that use the file system in directories that are also\naccessible to other users or applications (e.g. `/tmp` on UNIX-like systems)\nmust be very careful about what they are doing. For example, a file or directory\nthat was first verified to be a plain file could be switched out with a symbolic\nlink pointing to sensitive data (e.g. a password database) to trick an\napplication to reveal or overwrite the contents of that file.\n\nTo prevent this vulnerability, use file operations that perform the check and\nthe subsequent action atomically. For example, instead of checking for file\nexistence before creating it - try to create it and handle the error when it\nalready exists. Sometimes the desired sequence of file operations cannot be\nperformed in a single operating-system level call. When machine-local attacks\nare of no concern, you can use application-level locking in such cases.\nOtherwise, use OS-specific facilities that guarantee that multiple file\noperations act on the same file object (e.g. using `O_PATH` on Linux).\n\n::::tabs\n\n:::tab[Java]\n\n## Race Conditions in Java\n\nRace conditions in java often result in corrupted data caused by shared resources used by multiple threads. Java is also \nprone to TOCTOU vulnerabilities. \n\nThe following example outlines a race condition and thus corrupted data in the output file `/tmp/text.txt`.\n\n```java\nimport java.io.FileWriter;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\n\nclass FileThread implements Runnable {\n    String filePath;\n    int number;\n    public FileThread(int number, String filePath) {\n        this.filePath = filePath;\n        this.number = number;\n    }\n    @Override\n    public void run() {\n        try {\n            FileWriter fileWriter = new FileWriter(this.filePath, true);\n            BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);\n            for(int i=0; i<1000; i++) {\n                bufferedWriter.write(\"Thread number: \"+number+\" \"+i);\n                bufferedWriter.newLine();\n                Thread.sleep(1);\n            }\n            bufferedWriter.close();\n            fileWriter.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n\npublic class Main{\n    public static void main(String[] args){\n        new Thread(new FileThread(1, \"/tmp/test.txt\")).start();\n        new Thread(new FileThread(2, \"/tmp/test.txt\")).start();\n    }\n}\n```\n\n:::\n\n:::tab[C#]\n\nRace conditions in C# often result in corrupted data caused by shared resources used by multiple threads. C# is also\nprone to TOCTOU vulnerabilities.\n\nThe following example outlines a race condition and thus corrupted data in the output file `/tmp/text.txt`.\n\n## Race Condition in C#\n\n```csharp\nclass FileThread\n{\n   private int _number;\n   private string _filePath;\n   public FileThread(int number, string filePath)\n   {\n      _number = number;\n      _filePath = filePath;\n   }\n\n   public void DoRun() \n   {\n      for(int i = 0; i< 1000; i++)\n      {\n         using (StreamWriter sw = File.AppendText(_filePath))\n         {\n            sw.WriteLine(String.Format(\"Thread number: {0}: {1} \", _number, i));\n         }\t\n      }\n   }\n}\n\npublic class Test\n{\n   public static void Main()\n   {\n      var first = new FileThread(1, \"/tmp/test1.txt\");\n      var second = new FileThread(2, \"/tmp/test1.txt\");\n      var t1 = new Thread(first.DoRun);\n      var t2 = new Thread(second.DoRun);\n      t1.Start();\n      t2.Start();\n   }\n}\n```\n\n:::\n\n:::tab[JavaScript]\n\nEven though JavaScript is single threaded, race conditions might still appear\nfrom concurrency in async functions, promises and callbacks. They can also\nhappen when multiple instances of the application share state through e.g. a\ncommon database, cache or file system.\n\n## Race Condition in JavaScript \n\nThe following code should be executed within a node environment multiple times. \nThe result number should change on every run. \n\n```javascript\nlet sharedNumber = 0;\nconst times = 100;\n\nasync function increaseNumber() {\n    for (let i = 0; i < times; i++) {\n        await new Promise((resolve) => setTimeout(resolve, Math.random() * 5));\n        let  read = sharedNumber + 1;\n        await new Promise((resolve) => setTimeout(resolve, Math.random() * 5));\n        sharedNumber = read;\n    }\n}\n\nasync function decreaseNumber() {\n    for (let i = 0; i < times; i++) {\n        await new Promise((resolve) => setTimeout(resolve, Math.random() * 5));\n        let  read = sharedNumber - 1;\n        await new Promise((resolve) => setTimeout(resolve, Math.random() * 5));\n        sharedNumber = read;\n    }\n}\n\nasync function main() {\n    console.log(\"Initial value is\", sharedNumber);\n\n    /* \n     * call async functions\n     * that work on a shared \n     * global sharedNumber\n     */\n    await Promise.all([\n        increaseValue(),\n        decreaseNumber(),\n    ]);\n\n    console.log(\"Ended with\", sharedNumber);\n}\n\nmain()\n\n```\n\n:::\n\n:::tab[Python]\n\n## Race Conditions in Python\n\nPython can sometimes make it seem like it is immune to race conditions, because\nthe CPython interpreter has a global interpreter lock (GIL) that only allows one\nPython thread to make progress at a time. However, there are few guarantees\naround this and code which has not been observed to have race-related problems\nmay still run into one under the right circumstances.\n\nEven single-threaded Python applications can have race condition bugs from\nconcurrency in async functions, promises and callbacks. They can also happen\nwhen multiple instances of the application share state through e.g. a common\ndatabase, cache or file system.\n\n```python\nimport os, shutil\n\ndef copy_file(dst_file, src_file):\n    # 1) check\n    if not os.access(src_file, os.R_OK):\n        return False\n\n    # 2) at this time, another application or thread can unexpectedly remove or change the source file, causing an error in 3)\n\n    # 3) use\n    shutil.copyfile(src_file, dst_file)\n\n    return True\n```\n\nA fixed version instead performs the copy in a single step and gracefully handles the errors when the file does not exist, or we have no permissions to access it:\n\n```python\nimport os, shutil\n\ndef copy_file(dst_file, src_file):\n    try:\n        # just try to copy\n        shutil.copyfile(src_file, dst_file)\n        return True\n    except OSError:\n        return False\n```\n\n:::\n\n:::tab[Scala]\n\n## Race Conditions in Scala\n\nRace conditions in Java often result in corrupting data that is shared by multiple threads. Java is also\nprone to TOCTOU vulnerabilities.\n\nThe following example outlines a race condition and thus corrupted data in the output file `/tmp/text.txt`.\n\n```scala\nimport java.io._\n\nclass FileThread(number: Int, filePath: String) extends Runnable {\n  def run(): Unit = {\n    try {\n      val fileWriter = new FileWriter(this.filePath, true)\n      val bufferedWriter = new BufferedWriter(fileWriter)\n      var i = 0\n      for (i <- 0 to 10000) {\n        bufferedWriter.write(\"Thread number: \" + number + \" \" + i)\n        bufferedWriter.newLine()\n        Thread.sleep(10)\n      }\n      bufferedWriter.close()\n      fileWriter.close()\n    } catch {\n      case e: Exception => println(e.getMessage)\n    }\n  }\n}\n\nobject Main extends App {\n  new Thread(new FileThread(1, \"/tmp/test.txt\")).start()\n  new Thread(new FileThread(2, \"/tmp/test.txt\")).start()\n}\n```\n\n:::\n\n:::tab[Go]\n\n## Race Conditions in Go\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"time\"\n)\n\nfunc copyFile(srcPath, dstPath string) bool {\n    # 1) check (file existence)\n    if _, err := os.Stat(srcPath); os.IsNotExist(err) {\n        return false\n    }\n\n    # 2) at this time, another application or thread can unexpectedly remove or change the source file, causing an error in 3)\n\n    # 3) use (copy files)\n    srcFile, _ := os.Open(srcPath)\n    defer srcFile.Close()\n\n    dstFile, _ := os.Create(dstPath)\n    defer dstFile.Close()\n\n    _, err = io.Copy(dstFile, srcFile)\n    return true\n}\n```\n\nA fixed version instead performs the copy in a single step and gracefully handles the errors when the file does not exist, or we have no permissions to access it:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"time\"\n)\n\nfunc copyFile(srcPath, dstPath string) bool {\n    srcFile, err := os.Open(srcPath)\n    if err != nil {\n        return false\n    }\n    defer srcFile.Close()\n\n    dstFile, err := os.Create(dstPath)\n    if err != nil {\n        return false\n    }\n    defer dstFile.Close()\n\n    _, err = io.Copy(dstFile, srcFile)\n    if err != nil {\n        return false\n    }\n    return true\n}\n```\n\n:::\n\n:::tab[C]\n\nRace conditions in C are often problems with TOCTOU.\n\n## Race Conditions in C\n\n```C\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    char *buffer = \"file content\";\n    // 1) check\n    if (access(\"example.txt\", W_OK) != 0) {\n        exit(1);\n    }\n\n    // 2) at this time, another application or thread can unexpectedly remove or change the source file, causing an error in 3)\n\n    // 3) use\n    int fd = open(\"example.txt\", O_WRONLY);\n    write(fd, buffer, sizeof(buffer));\n\n    close(fd);\n}\n```\n\nA fixed version instead opens the file in a single step and gracefully handles the errors when the file does not exist, or we have no permissions to access it:\n\n```C\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    char *buffer = \"file content\";\n    int fd = open(\"example.txt\", O_WRONLY);\n    if (fd == -1)\n        exit(1);\n    write(fd, buffer, sizeof(buffer));\n\n    close(fd);\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Race Conditions in PHP\n\nRace conditions in PHP can arise in a multithreaded environment or in web applications where multiple simultaneous requests can lead to unintended consequences. PHP, due to its share-nothing architecture in the web context, primarily faces race conditions involving file or database operations.\n\nConsider the following example which showcases a TOCTOU race condition involving file operations:\n\n```php\n<?php\n\nfunction writeToFile($filename, $data) {\n    // Check if file exists\n    if (!file_exists($filename)) {\n        // Create and write to the file\n        file_put_contents($filename, $data);\n    } else {\n        echo \"File already exists!\";\n    }\n}\n\n$filename = \"/tmp/example.txt\";\n$data = \"Some content for the file.\";\n\nwriteToFile($filename, $data);\n?>\n```\n\nIn the above code, between checking if the file exists (`file_exists()`) and writing to it (`file_put_contents()`). If two instances of this script were to run nearly simultaneously, they might both pass the `file_exists()` check and then both attempt to write to the file, leading to potential overwrites or data inconsistencies.\n\n## Mitigation\n\nThe best way to handle the situation is to attempt the action and then handle any errors, rather than checking conditions before performing the action. This reduces the time frame in which the state can change:\n\n```php\n<?php\n\nfunction writeToFile($filename, $data) {\n    $file = fopen($filename, \"x\"); // mode \"x\" ensures in a race-free way that the operation fails if the file already exists\n    if ($file === false) {\n        echo \"Failed to write to file or file already exists.\";\n    } else {\n        fwrite($file, $data);\n        fclose($file);\n\n        echo \"Data written successfully.\";\n    }\n}\n\n$filename = \"/tmp/example.txt\";\n$data = \"Some content for the file.\";\n\nwriteToFile($filename, $data);\n?>\n```\n\nHere, `fopen()` with the `x` mode is used to create a file only if it does not already exist. If another instance of the script has already created the file, the operating system ensures that the `fopen()` call fails without any chance for a race condition.\n\n\n:::\n\n::::\n\n\n## CWEs\n\n**[CWE-367](https://cwe.mitre.org/data/definitions/367.html)**\n**[CWE-362](https://cwe.mitre.org/data/definitions/362.html)**",
                                "text": "The same file path is used sequentially first in an existence or file property check and then in a read or write operation. This indicates a time-of-check time-of-use race condition. By sending multiple concurrent requests, an attacker can potentially subvert the existence or file property check in the timing window between the two file operations.\n\n# Race Condition \n\nA **race condition** appears when a program state changed between checking and accessing the state. \n\nThe impacts of race conditions can vary from deadlocks, where a program is not responding because multiple threads are\nblocking each other to reading files to (remote) code execution.\n\nA common kind of race conditions is often referred to as **Time-of-check Time-of-use** (TOCTOU). These are bugs where a \nprogram is first checking whether a condition holds and afterwards performs an action based on that, when it's not \nguaranteed that this condition never changes in the time that elapses between the **check** and the **use**.\n\n## `Time-of-check Time-of-use` (TOCTOU) With File System Operations\n\nFor example, applications that use the file system in directories that are also\naccessible to other users or applications (e.g. `/tmp` on UNIX-like systems)\nmust be very careful about what they are doing. For example, a file or directory\nthat was first verified to be a plain file could be switched out with a symbolic\nlink pointing to sensitive data (e.g. a password database) to trick an\napplication to reveal or overwrite the contents of that file.\n\nTo prevent this vulnerability, use file operations that perform the check and\nthe subsequent action atomically. For example, instead of checking for file\nexistence before creating it - try to create it and handle the error when it\nalready exists. Sometimes the desired sequence of file operations cannot be\nperformed in a single operating-system level call. When machine-local attacks\nare of no concern, you can use application-level locking in such cases.\nOtherwise, use OS-specific facilities that guarantee that multiple file\noperations act on the same file object (e.g. using `O_PATH` on Linux).\n\n::::tabs\n\n:::tab[Java]\n\n## Race Conditions in Java\n\nRace conditions in java often result in corrupted data caused by shared resources used by multiple threads. Java is also \nprone to TOCTOU vulnerabilities. \n\nThe following example outlines a race condition and thus corrupted data in the output file `/tmp/text.txt`.\n\n```java\nimport java.io.FileWriter;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\n\nclass FileThread implements Runnable {\n    String filePath;\n    int number;\n    public FileThread(int number, String filePath) {\n        this.filePath = filePath;\n        this.number = number;\n    }\n    @Override\n    public void run() {\n        try {\n            FileWriter fileWriter = new FileWriter(this.filePath, true);\n            BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);\n            for(int i=0; i<1000; i++) {\n                bufferedWriter.write(\"Thread number: \"+number+\" \"+i);\n                bufferedWriter.newLine();\n                Thread.sleep(1);\n            }\n            bufferedWriter.close();\n            fileWriter.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n\npublic class Main{\n    public static void main(String[] args){\n        new Thread(new FileThread(1, \"/tmp/test.txt\")).start();\n        new Thread(new FileThread(2, \"/tmp/test.txt\")).start();\n    }\n}\n```\n\n:::\n\n:::tab[C#]\n\nRace conditions in C# often result in corrupted data caused by shared resources used by multiple threads. C# is also\nprone to TOCTOU vulnerabilities.\n\nThe following example outlines a race condition and thus corrupted data in the output file `/tmp/text.txt`.\n\n## Race Condition in C#\n\n```csharp\nclass FileThread\n{\n   private int _number;\n   private string _filePath;\n   public FileThread(int number, string filePath)\n   {\n      _number = number;\n      _filePath = filePath;\n   }\n\n   public void DoRun() \n   {\n      for(int i = 0; i< 1000; i++)\n      {\n         using (StreamWriter sw = File.AppendText(_filePath))\n         {\n            sw.WriteLine(String.Format(\"Thread number: {0}: {1} \", _number, i));\n         }\t\n      }\n   }\n}\n\npublic class Test\n{\n   public static void Main()\n   {\n      var first = new FileThread(1, \"/tmp/test1.txt\");\n      var second = new FileThread(2, \"/tmp/test1.txt\");\n      var t1 = new Thread(first.DoRun);\n      var t2 = new Thread(second.DoRun);\n      t1.Start();\n      t2.Start();\n   }\n}\n```\n\n:::\n\n:::tab[JavaScript]\n\nEven though JavaScript is single threaded, race conditions might still appear\nfrom concurrency in async functions, promises and callbacks. They can also\nhappen when multiple instances of the application share state through e.g. a\ncommon database, cache or file system.\n\n## Race Condition in JavaScript \n\nThe following code should be executed within a node environment multiple times. \nThe result number should change on every run. \n\n```javascript\nlet sharedNumber = 0;\nconst times = 100;\n\nasync function increaseNumber() {\n    for (let i = 0; i < times; i++) {\n        await new Promise((resolve) => setTimeout(resolve, Math.random() * 5));\n        let  read = sharedNumber + 1;\n        await new Promise((resolve) => setTimeout(resolve, Math.random() * 5));\n        sharedNumber = read;\n    }\n}\n\nasync function decreaseNumber() {\n    for (let i = 0; i < times; i++) {\n        await new Promise((resolve) => setTimeout(resolve, Math.random() * 5));\n        let  read = sharedNumber - 1;\n        await new Promise((resolve) => setTimeout(resolve, Math.random() * 5));\n        sharedNumber = read;\n    }\n}\n\nasync function main() {\n    console.log(\"Initial value is\", sharedNumber);\n\n    /* \n     * call async functions\n     * that work on a shared \n     * global sharedNumber\n     */\n    await Promise.all([\n        increaseValue(),\n        decreaseNumber(),\n    ]);\n\n    console.log(\"Ended with\", sharedNumber);\n}\n\nmain()\n\n```\n\n:::\n\n:::tab[Python]\n\n## Race Conditions in Python\n\nPython can sometimes make it seem like it is immune to race conditions, because\nthe CPython interpreter has a global interpreter lock (GIL) that only allows one\nPython thread to make progress at a time. However, there are few guarantees\naround this and code which has not been observed to have race-related problems\nmay still run into one under the right circumstances.\n\nEven single-threaded Python applications can have race condition bugs from\nconcurrency in async functions, promises and callbacks. They can also happen\nwhen multiple instances of the application share state through e.g. a common\ndatabase, cache or file system.\n\n```python\nimport os, shutil\n\ndef copy_file(dst_file, src_file):\n    # 1) check\n    if not os.access(src_file, os.R_OK):\n        return False\n\n    # 2) at this time, another application or thread can unexpectedly remove or change the source file, causing an error in 3)\n\n    # 3) use\n    shutil.copyfile(src_file, dst_file)\n\n    return True\n```\n\nA fixed version instead performs the copy in a single step and gracefully handles the errors when the file does not exist, or we have no permissions to access it:\n\n```python\nimport os, shutil\n\ndef copy_file(dst_file, src_file):\n    try:\n        # just try to copy\n        shutil.copyfile(src_file, dst_file)\n        return True\n    except OSError:\n        return False\n```\n\n:::\n\n:::tab[Scala]\n\n## Race Conditions in Scala\n\nRace conditions in Java often result in corrupting data that is shared by multiple threads. Java is also\nprone to TOCTOU vulnerabilities.\n\nThe following example outlines a race condition and thus corrupted data in the output file `/tmp/text.txt`.\n\n```scala\nimport java.io._\n\nclass FileThread(number: Int, filePath: String) extends Runnable {\n  def run(): Unit = {\n    try {\n      val fileWriter = new FileWriter(this.filePath, true)\n      val bufferedWriter = new BufferedWriter(fileWriter)\n      var i = 0\n      for (i <- 0 to 10000) {\n        bufferedWriter.write(\"Thread number: \" + number + \" \" + i)\n        bufferedWriter.newLine()\n        Thread.sleep(10)\n      }\n      bufferedWriter.close()\n      fileWriter.close()\n    } catch {\n      case e: Exception => println(e.getMessage)\n    }\n  }\n}\n\nobject Main extends App {\n  new Thread(new FileThread(1, \"/tmp/test.txt\")).start()\n  new Thread(new FileThread(2, \"/tmp/test.txt\")).start()\n}\n```\n\n:::\n\n:::tab[Go]\n\n## Race Conditions in Go\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"time\"\n)\n\nfunc copyFile(srcPath, dstPath string) bool {\n    # 1) check (file existence)\n    if _, err := os.Stat(srcPath); os.IsNotExist(err) {\n        return false\n    }\n\n    # 2) at this time, another application or thread can unexpectedly remove or change the source file, causing an error in 3)\n\n    # 3) use (copy files)\n    srcFile, _ := os.Open(srcPath)\n    defer srcFile.Close()\n\n    dstFile, _ := os.Create(dstPath)\n    defer dstFile.Close()\n\n    _, err = io.Copy(dstFile, srcFile)\n    return true\n}\n```\n\nA fixed version instead performs the copy in a single step and gracefully handles the errors when the file does not exist, or we have no permissions to access it:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"time\"\n)\n\nfunc copyFile(srcPath, dstPath string) bool {\n    srcFile, err := os.Open(srcPath)\n    if err != nil {\n        return false\n    }\n    defer srcFile.Close()\n\n    dstFile, err := os.Create(dstPath)\n    if err != nil {\n        return false\n    }\n    defer dstFile.Close()\n\n    _, err = io.Copy(dstFile, srcFile)\n    if err != nil {\n        return false\n    }\n    return true\n}\n```\n\n:::\n\n:::tab[C]\n\nRace conditions in C are often problems with TOCTOU.\n\n## Race Conditions in C\n\n```C\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    char *buffer = \"file content\";\n    // 1) check\n    if (access(\"example.txt\", W_OK) != 0) {\n        exit(1);\n    }\n\n    // 2) at this time, another application or thread can unexpectedly remove or change the source file, causing an error in 3)\n\n    // 3) use\n    int fd = open(\"example.txt\", O_WRONLY);\n    write(fd, buffer, sizeof(buffer));\n\n    close(fd);\n}\n```\n\nA fixed version instead opens the file in a single step and gracefully handles the errors when the file does not exist, or we have no permissions to access it:\n\n```C\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    char *buffer = \"file content\";\n    int fd = open(\"example.txt\", O_WRONLY);\n    if (fd == -1)\n        exit(1);\n    write(fd, buffer, sizeof(buffer));\n\n    close(fd);\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Race Conditions in PHP\n\nRace conditions in PHP can arise in a multithreaded environment or in web applications where multiple simultaneous requests can lead to unintended consequences. PHP, due to its share-nothing architecture in the web context, primarily faces race conditions involving file or database operations.\n\nConsider the following example which showcases a TOCTOU race condition involving file operations:\n\n```php\n<?php\n\nfunction writeToFile($filename, $data) {\n    // Check if file exists\n    if (!file_exists($filename)) {\n        // Create and write to the file\n        file_put_contents($filename, $data);\n    } else {\n        echo \"File already exists!\";\n    }\n}\n\n$filename = \"/tmp/example.txt\";\n$data = \"Some content for the file.\";\n\nwriteToFile($filename, $data);\n?>\n```\n\nIn the above code, between checking if the file exists (`file_exists()`) and writing to it (`file_put_contents()`). If two instances of this script were to run nearly simultaneously, they might both pass the `file_exists()` check and then both attempt to write to the file, leading to potential overwrites or data inconsistencies.\n\n## Mitigation\n\nThe best way to handle the situation is to attempt the action and then handle any errors, rather than checking conditions before performing the action. This reduces the time frame in which the state can change:\n\n```php\n<?php\n\nfunction writeToFile($filename, $data) {\n    $file = fopen($filename, \"x\"); // mode \"x\" ensures in a race-free way that the operation fails if the file already exists\n    if ($file === false) {\n        echo \"Failed to write to file or file already exists.\";\n    } else {\n        fwrite($file, $data);\n        fclose($file);\n\n        echo \"Data written successfully.\";\n    }\n}\n\n$filename = \"/tmp/example.txt\";\n$data = \"Some content for the file.\";\n\nwriteToFile($filename, $data);\n?>\n```\n\nHere, `fopen()` with the `x` mode is used to create a file only if it does not already exist. If another instance of the script has already created the file, the operating system ensures that the `fopen()` call fails without any chance for a race condition.\n\n\n:::\n\n::::\n\n\n## CWEs\n\n**[CWE-367](https://cwe.mitre.org/data/definitions/367.html)**\n**[CWE-362](https://cwe.mitre.org/data/definitions/362.html)**"
                            },
                            "helpUri": "https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control",
                            "id": "file-toctou/e09e0e192b233e78426e0ef3ff3097f9",
                            "name": "Race Condition: Check Followed By Read Or Write Operation On Same File Path In Log_entry",
                            "properties": {
                                "precision": "very-high",
                                "security-severity": "3",
                                "tags": [
                                    "ng-sast",
                                    "CVSS 3",
                                    "CWE 367",
                                    "OWASP 2021 a01-broken-access-control",
                                    "OWASP a01-2021-broken-access-control",
                                    "OWASP a5-broken-access-control",
                                    "Race Condition"
                                ]
                            },
                            "shortDescription": {
                                "text": "Race Condition: Check Followed by Read or Write Operation on Same File Path in log_entry"
                            }
                        },
                        {
                            "defaultConfiguration": {
                                "enabled": true,
                                "level": "error",
                                "rank": -1
                            },
                            "fullDescription": {
                                "text": "Attacker controlled data is used in a SQL query without undergoing escaping or validation. This indicates a SQL injection vulnerability."
                            },
                            "help": {
                                "markdown": "Attacker controlled data is used in a SQL query without undergoing escaping or validation. This indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**",
                                "text": "Attacker controlled data is used in a SQL query without undergoing escaping or validation. This indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**"
                            },
                            "helpUri": "https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection",
                            "id": "sql-injection-attacker-controlled/a55eb487bc5de2aad461b8d46ea69d74",
                            "name": "Sql Injection: Attacker-Controlled Data Used In Sql Query In Users.py",
                            "properties": {
                                "precision": "very-high",
                                "security-severity": "9",
                                "tags": [
                                    "ng-sast",
                                    "CVSS 9",
                                    "CWE 89",
                                    "OWASP 2021 a03-injection",
                                    "OWASP a03-2021-injection",
                                    "OWASP a1-injection",
                                    "SQL Injection"
                                ]
                            },
                            "shortDescription": {
                                "text": "SQL Injection: Attacker-controlled Data Used in SQL Query in users.py"
                            }
                        },
                        {
                            "defaultConfiguration": {
                                "enabled": true,
                                "level": "error",
                                "rank": -1
                            },
                            "fullDescription": {
                                "text": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability."
                            },
                            "help": {
                                "markdown": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**",
                                "text": "This SQL statement is not a string literal. When unescaped attacker-controlled inputs are used as part of a SQL statement this indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**"
                            },
                            "helpUri": "https://cwe.mitre.org/data/definitions/89.html",
                            "id": "warning-sink-sql/8ffca272ab87817404c8228a4263bfc8",
                            "name": "Sql Injection: Non-Constant Sql Statement In Query_db",
                            "properties": {
                                "precision": "very-high",
                                "security-severity": "8",
                                "tags": [
                                    "ng-sast",
                                    "CVSS 8",
                                    "CWE 89",
                                    "OWASP 2021 a03-injection",
                                    "OWASP a03-2021-injection",
                                    "OWASP a1-injection",
                                    "SQL Injection"
                                ]
                            },
                            "shortDescription": {
                                "text": "SQL Injection: Non-Constant SQL Statement in query_db"
                            }
                        },
                        {
                            "defaultConfiguration": {
                                "enabled": true,
                                "level": "warning",
                                "rank": -1
                            },
                            "fullDescription": {
                                "text": "This affects the package jinja2 from 0.0.0 and before 2.11.3. The ReDOS vulnerability of the regex is mainly due to the sub-pattern [a-zA-Z0-9._-]+.[a-zA-Z0-9._-]+ This issue can be mitigated by Markdown to format user content instead of the urlize filter, or by implementing request timeouts and limiting process memory."
                            },
                            "help": {
                                "markdown": "This affects the package jinja2 from 0.0.0 and before 2.11.3. The ReDOS vulnerability of the regex is mainly due to the sub-pattern [a-zA-Z0-9._-]+.[a-zA-Z0-9._-]+ This issue can be mitigated by Markdown to format user content instead of the urlize filter, or by implementing request timeouts and limiting process memory.",
                                "text": "This affects the package jinja2 from 0.0.0 and before 2.11.3. The ReDOS vulnerability of the regex is mainly due to the sub-pattern [a-zA-Z0-9._-]+.[a-zA-Z0-9._-]+ This issue can be mitigated by Markdown to format user content instead of the urlize filter, or by implementing request timeouts and limiting process memory."
                            },
                            "helpUri": "https://cwe.mitre.org/data/definitions/400.html",
                            "id": "oss_vuln/01f90019862213dbbe74c6eb911b508f",
                            "name": "Pkg:pypi/Jinja2@2.8",
                            "properties": {
                                "precision": "very-high",
                                "security-severity": "5.3",
                                "tags": [
                                    "ng-sast",
                                    "CVE-2020-28493",
                                    "CVSS 5.3",
                                    "CWE 400",
                                    "Exploitable",
                                    "Unreachable"
                                ]
                            },
                            "shortDescription": {
                                "text": "pkg:pypi/jinja2@2.8"
                            }
                        },
                        {
                            "defaultConfiguration": {
                                "enabled": true,
                                "level": "warning",
                                "rank": -1
                            },
                            "fullDescription": {
                                "text": "The target URL where a HTTP client is redirected to is not a string literal. When unescaped attacker-controlled inputs are used as part of the URL this indicates an open redirect vulnerability."
                            },
                            "help": {
                                "markdown": "The target URL where a HTTP client is redirected to is not a string literal. When unescaped attacker-controlled inputs are used as part of the URL this indicates an open redirect vulnerability.\n\n# Open Redirects\n\nAn *HTTP redirect* is when a web-server returns an HTTP status code like 302 to tell the browser to make a request to a\ndifferent URL. Redirects can also be performed in client-side JavaScript code by updating the browser URL directly.\n\nRedirects are commonly used to push a user to an authentication page before viewing some protected content. In this \nscenario, the user will often be redirected again back to the original resource once they have successfully logged in. \n\nIf a redirect URL is pulled from a preceding HTTP request, you need to check the URL is safe before redirecting the\nuser. Typically, this means checking the URL is a **relative URL** to a resource hosted under your web domain. **Open \nredirects** - which allow a maliciously crafted link to redirect the user to arbitrary third-party domains - are often \nused by spammers to disguise harmful links in emails.\n\n::::tabs\n\n:::tab[Java]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Java application verifies the \nredirect URL:\n\n```java\n@Override\npublic void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String username = request.getParameter(\"username\");\n    String password = request.getParameter(\"password\");\n\n    if (!this.credentialsAreValid(username, password)) {\n        request.setAttribute(\"message\", \"Incorrect credentials\");\n        response.sendRedirect(\"/login\");\n        return;\n    }\n\n    HttpSession session = request.getSession(true);\n    session.setAttribute(\"username\", username);\n\n    String destination = request.getParameter(\"destination\");\n\n    if (destination == null || !this.isRelative(destination)) {\n        destination = \"/home\";\n    }\n\n    response.sendRedirect(destination);\n}\n\n/**\n * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\\\".\n */\nprivate boolean isRelative(String url) {\n    return url.matches(\"/[^/\\\\]?.*\");\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Angular]\n\n## Disallowing Offsite Redirects\n\nClient-side frameworks like Angular often mimic server-side redirects by using typescript logic. There are a number of \nways of doing redirects in Angular code - updating the `window.location` directly, using the browser's history API, or \nusing the `Router` module:\n\n```typescript\n/**\n * An example of how to push the user to the login page if they attempt to access a sensitive\n * route before authenticating thmeselves.\n */\nexport class AuthGuard implements CanActivate {\n  constructor(private authService: AuthService, private router: Router) {}\n\n  canActivate(next: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<true | UrlTree> {\n    \n    // Check whether the user is logged in.  \n    return this.authService.isLoggedIn().pipe(\n      map(isLoggedIn => {\n        if (!isLoggedIn) {\n            \n          // Redirect the user to the login page if they are not logged in.  \n          return this.router.parseUrl(`/login?destination=${state.url}`);\n        }\n\n        return true\n      })\n    )\n  }\n}\n```\n\nWhen performing a redirect, it is important to check that the URL you are redirecting to is a relative URL - that is, it \nstarts with a single `/` character:\n\n```typescript\nexport class LoginComponent {\n\n  // The username and password entered by the user in the login form.\n  username = '';\n  password = '';\n\n  // The destination URL to redirect the user to once they log in successfully.\n  destinationURL = '/feed'\n\n  constructor(private authService : AuthService,\n              private route       : ActivatedRoute,\n              private router      : Router) { }\n\n  ngOnInit() {\n    this.destinationURL = this.route.snapshot.queryParams['destination'] || '/feed';\n  }\n\n  onSubmit() {\n    this.authService.login(this.username, this.password)\n      .subscribe(\n        () => {\n          // After the user has lgged in, redirect them to their desired destination.\n          let url = this.destinationURL\n\n          // Confirm that the URL is a relative path - i.e. starting with a single '/' characters.\n          if (!url.match(/^\/[^\/\\\\]/)) {\n            url = '/feed'\n          }\n\n          this.router.navigate([ url ])\n        })\n  }\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[C#]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this ASP.NET login action verifies the \nredirect URL:\n\n```csharp\n[HttpPost]\n[AllowAnonymous]\n[ValidateAntiForgeryToken]\npublic async Task<ActionResult> Login(string username, string password, [FromQuery] string returnUrl)\n{\n    var result = await SignInManager.PasswordSignInAsync(username, password, true, false);\n\n    if (result.Succeeded)\n    {\n        // Make sure this a URL within our website.\n        if (Url.IsLocalUrl(returnUrl))\n        {\n            return Redirect(returnUrl);\n        }\n        \n        return RedirectToAction(\"Home\");\n    }\n    \n    return View();\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they will be \nrejected too.) \n\n:::\n\n:::tab[JavaScript]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Express application verifies the \nredirect URL:\n\n```javascript\nconst app = express()\n\napp.use(express.urlencoded())\napp.use(cookieParser('secret'))\napp.use(session({ cookie: { maxAge: 60000 }}))\napp.use(flash())\n\napp.post('/login', (request, response) => {\n  const username = request.body.username\n  const password = request.body.password\n\n  if (!usernameAndPasswordAreValid(username, password)) {\n    request.flash('message', 'Incorrect credentials')\n    response.redirect('/login')\n\n    return\n  }\n\n  // Log the user in.\n  request.session.user = username\n\n  // Check redirect URL is a relative path - otherwise just send the user to /home page.\n  const redirectURL = request.query.redirect\n\n  // Check the URL starts with a single / character.\n  if (redirectURL && redirectURL.match(/^\/[^\/\\\\]/)) {\n    response.redirect(redirectURL)\n  }\n  else {\n    response.redirect('/home')\n  }\n})\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Python]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Python application verifies the \nredirect URL:\n\n```python\n@app.route('/login', methods=['POST'])\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  user = find_user_with_password(username, password)\n\n  if not user:\n    flash('Invalid credentials', 'error')\n    return redirect('/login')\n\n  session['username'] = username\n\n  destination = request.args.get('destination')\n\n  if destination is None or not is_relative(destination):\n    destination = '/timeline'\n\n  return redirect(destination)\n\ndef is_relative(url):\n  return re.match(r\"^\/[^\/\\\\]\", url)\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[React]\n\n## Disallowing Offsite Redirects\n\nThere are a number of ways of doing redirects in React code - updating the `window.location` directly, using the \nbrowser's history API, or using the `<Redirect>` component from the `react-router` module. Whichever method you use, it \nis important to check that the URL you are redirecting to is a relative URL - that is, it starts with a single `/` \ncharacter:\n\n```jsx\n/**\n * A wrapper for <Route> that redirects to /feed if the user is authenticated.\n */\nfunction UnauthenticatedRoute(props) {\n  if (!props.loggedIn) {\n    return <Route {...props} />\n  }\n\n  // If the user has just authenticated, check the query string for their intended destination.\n  const parsed = queryString.parse(props.location.search)\n\n  let url = '/feed'\n\n  // Ensure this is a relative URL within the site (i.e. it starts with a single / character.)\n  if (parsed.destination && parsed.destination.match(/^\/[^\/\\\\]/)) {\n    url = parsed.destination\n  }\n\n  return <Redirect to={{ pathname: url }} />\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Scala]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Scala application verifies the \nredirect URL:\n\n```scala\nclass LoginController @Inject()(cc: ControllerComponents, users: UserRepository) extends AbstractController(cc) {\n\n  /**\n   * Process the response from the login page, safely checking for a redirect parameter.\n   */\n  def login = Action(parse.form(loginForm)) { request =>\n    val credentials = request.body\n\n    if (!users.credentialsAreValid(credentials.username, credentials.password)) {\n      Redirect(\"/login\").flashing(\"error\" -> \"Incorrect username or password.\")\n    }\n    else {\n      var next = request.getQueryString(\"destination\").getOrElse(\"/home\")\n\n      if (!isRelative(next)) {\n        next = \"/home\"\n      }\n\n      Redirect(next).withSession(request.session + (\"username\" -> credentials.username))\n    }\n  }\n\n  /**\n   * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\".\n   */\n  def isRelative(url : String) =  {\n    url.matches(\"/[^/\\\\]?.*\");\n  }\n\n  case class Credentials(username: String, password: String)\n\n  def loginForm = Form(\n    mapping(\n      \"username\" -> text,\n      \"password\" -> text\n    )(Credentials.apply)(Credentials.unapply)\n  )\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Go]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Go application verifies the \nredirect URL:\n\n```go\nfunc LoginHandler(response http.ResponseWriter, request *http.Request) {\n  request.ParseForm()\n\n  session, _ := session.Get(request, \"session\")\n\n  username := request.Form.Get(\"username\")\n  password := request.Form.Get(\"password\")\n\n  user := findUserWithPassword(username, password)\n\n  if user == nil {\n    http.Redirect(response, request, \"/login\", http.StatusUnauthorized)\n    return\n  }\n\n  session.Values[\"username\"] = username\n  session.Save(request, response)\n\n  destination := request.URL.Query().Get(\"destination\")\n\n  // Protect against redirect attacks by checking the destination URL starts with a single / character.\n  if destination == \"\" {\n    destination = \"/home\"\n  } else {\n    isRelative, _ := regexp.MatchString(\"^/[^/]\", destination)\n\n    if !isRelative {\n      destination = \"/home\"\n    }\n  }\n\n  http.Redirect(response, request, destination, http.StatusOK)\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[PHP]\n\n## Disallowing Offsite Redirects in PHP\n\nOpen redirects in PHP are commonly introduced when user input is improperly used in the `header` function for redirection. To securely implement redirects, always validate the user-provided URLs before using them. Here's a secure way to handle redirects:\n\n```php\n<?php\nsession_start();\n\n// Assuming some form of user authentication\n$username = $_POST['username'];\n$password = $_POST['password'];\n\nif (!credentialsAreValid($username, $password)) {\n    $_SESSION['message'] = \"Incorrect credentials\";\n    header(\"Location: /login.php\");\n    exit;\n}\n\n$_SESSION['username'] = $username;\n\n$destination = $_GET['destination'];\n\n// Check if the destination URL is a relative path\nif (!isRelativeURL($destination)) {\n    $destination = \"/home.php\";\n}\n\nheader(\"Location: \" . $destination);\nexit;\n\n/**\n * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\\\".\n */\nfunction isRelativeURL($url) {\n    return preg_match('/^\/[^\/\\\\\\\\].*/', $url);\n}\n?>\n```\n\nThe above PHP code checks if a given redirect URL is a relative path, starting with a single `/` character. URLs starting with `//` (interpreted by browsers as protocol agnostic) are also rejected to ensure safety.\n\n:::\n\n::::\n\n## Other Considerations\n\n* Redirects can happen in client-side JavaScript, too. Validate any code that updates `window.location`, to ensure the\n  URL is not taken from untrusted input.\n\n* Some sites insert *interstitial pages* when the user is leaving the site. This is a good defense against \"doppelganger\"\n  domains - websites that have a very similar domain name, that attempt to trick the user into sharing private \n  information. However, interstitial pages are a common place for open redirect vulnerabilities to occur. If you implement \n  an interstitial page that passes the URL in the query parameter, be sure to show the full URL to the user and require user\n  interaction before performing the redirect.\n\n* Social media and link-sharing sites often make use of redirects to do *click-counting*. URLs are chosen by the \n  community, then when a user clicks on the link, the click-through count is incremented, and the user is redirected to \n  their destination. In this situation, you are obligated to redirect the user to an external domains. Consider using a\n  different domain name for such a redirector that does not confer the same trust to users as your regular domain. Alternatively,\n  show a interstitial page (see previous point).\n\n* Some resources recommend checking the `Referer` or `Origin` headers in the HTTP\n  request. This is **not enough** - these may not be available for a variety of reasons:\n\n  + Links from external applications (e.g. email, messengers, PDF readers, Word\n    documents, ...) never have such headers\n\n  + External web sites can redirect through e.g. `data:` or `blob:` URLs or use\n    the `sandbox` attribute on iframes to prevent the browser from sending the\n    `Referer` or `Origin` headers.\n\n  + Various browser settings, firewalls and other privacy software can suppress\n    the submission of these headers.\n\n## Additional information\n\n**[CWE-601](https://cwe.mitre.org/data/definitions/601.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**",
                                "text": "The target URL where a HTTP client is redirected to is not a string literal. When unescaped attacker-controlled inputs are used as part of the URL this indicates an open redirect vulnerability.\n\n# Open Redirects\n\nAn *HTTP redirect* is when a web-server returns an HTTP status code like 302 to tell the browser to make a request to a\ndifferent URL. Redirects can also be performed in client-side JavaScript code by updating the browser URL directly.\n\nRedirects are commonly used to push a user to an authentication page before viewing some protected content. In this \nscenario, the user will often be redirected again back to the original resource once they have successfully logged in. \n\nIf a redirect URL is pulled from a preceding HTTP request, you need to check the URL is safe before redirecting the\nuser. Typically, this means checking the URL is a **relative URL** to a resource hosted under your web domain. **Open \nredirects** - which allow a maliciously crafted link to redirect the user to arbitrary third-party domains - are often \nused by spammers to disguise harmful links in emails.\n\n::::tabs\n\n:::tab[Java]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Java application verifies the \nredirect URL:\n\n```java\n@Override\npublic void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String username = request.getParameter(\"username\");\n    String password = request.getParameter(\"password\");\n\n    if (!this.credentialsAreValid(username, password)) {\n        request.setAttribute(\"message\", \"Incorrect credentials\");\n        response.sendRedirect(\"/login\");\n        return;\n    }\n\n    HttpSession session = request.getSession(true);\n    session.setAttribute(\"username\", username);\n\n    String destination = request.getParameter(\"destination\");\n\n    if (destination == null || !this.isRelative(destination)) {\n        destination = \"/home\";\n    }\n\n    response.sendRedirect(destination);\n}\n\n/**\n * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\\\".\n */\nprivate boolean isRelative(String url) {\n    return url.matches(\"/[^/\\\\]?.*\");\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Angular]\n\n## Disallowing Offsite Redirects\n\nClient-side frameworks like Angular often mimic server-side redirects by using typescript logic. There are a number of \nways of doing redirects in Angular code - updating the `window.location` directly, using the browser's history API, or \nusing the `Router` module:\n\n```typescript\n/**\n * An example of how to push the user to the login page if they attempt to access a sensitive\n * route before authenticating thmeselves.\n */\nexport class AuthGuard implements CanActivate {\n  constructor(private authService: AuthService, private router: Router) {}\n\n  canActivate(next: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<true | UrlTree> {\n    \n    // Check whether the user is logged in.  \n    return this.authService.isLoggedIn().pipe(\n      map(isLoggedIn => {\n        if (!isLoggedIn) {\n            \n          // Redirect the user to the login page if they are not logged in.  \n          return this.router.parseUrl(`/login?destination=${state.url}`);\n        }\n\n        return true\n      })\n    )\n  }\n}\n```\n\nWhen performing a redirect, it is important to check that the URL you are redirecting to is a relative URL - that is, it \nstarts with a single `/` character:\n\n```typescript\nexport class LoginComponent {\n\n  // The username and password entered by the user in the login form.\n  username = '';\n  password = '';\n\n  // The destination URL to redirect the user to once they log in successfully.\n  destinationURL = '/feed'\n\n  constructor(private authService : AuthService,\n              private route       : ActivatedRoute,\n              private router      : Router) { }\n\n  ngOnInit() {\n    this.destinationURL = this.route.snapshot.queryParams['destination'] || '/feed';\n  }\n\n  onSubmit() {\n    this.authService.login(this.username, this.password)\n      .subscribe(\n        () => {\n          // After the user has lgged in, redirect them to their desired destination.\n          let url = this.destinationURL\n\n          // Confirm that the URL is a relative path - i.e. starting with a single '/' characters.\n          if (!url.match(/^\/[^\/\\\\]/)) {\n            url = '/feed'\n          }\n\n          this.router.navigate([ url ])\n        })\n  }\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[C#]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this ASP.NET login action verifies the \nredirect URL:\n\n```csharp\n[HttpPost]\n[AllowAnonymous]\n[ValidateAntiForgeryToken]\npublic async Task<ActionResult> Login(string username, string password, [FromQuery] string returnUrl)\n{\n    var result = await SignInManager.PasswordSignInAsync(username, password, true, false);\n\n    if (result.Succeeded)\n    {\n        // Make sure this a URL within our website.\n        if (Url.IsLocalUrl(returnUrl))\n        {\n            return Redirect(returnUrl);\n        }\n        \n        return RedirectToAction(\"Home\");\n    }\n    \n    return View();\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they will be \nrejected too.) \n\n:::\n\n:::tab[JavaScript]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Express application verifies the \nredirect URL:\n\n```javascript\nconst app = express()\n\napp.use(express.urlencoded())\napp.use(cookieParser('secret'))\napp.use(session({ cookie: { maxAge: 60000 }}))\napp.use(flash())\n\napp.post('/login', (request, response) => {\n  const username = request.body.username\n  const password = request.body.password\n\n  if (!usernameAndPasswordAreValid(username, password)) {\n    request.flash('message', 'Incorrect credentials')\n    response.redirect('/login')\n\n    return\n  }\n\n  // Log the user in.\n  request.session.user = username\n\n  // Check redirect URL is a relative path - otherwise just send the user to /home page.\n  const redirectURL = request.query.redirect\n\n  // Check the URL starts with a single / character.\n  if (redirectURL && redirectURL.match(/^\/[^\/\\\\]/)) {\n    response.redirect(redirectURL)\n  }\n  else {\n    response.redirect('/home')\n  }\n})\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Python]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Python application verifies the \nredirect URL:\n\n```python\n@app.route('/login', methods=['POST'])\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  user = find_user_with_password(username, password)\n\n  if not user:\n    flash('Invalid credentials', 'error')\n    return redirect('/login')\n\n  session['username'] = username\n\n  destination = request.args.get('destination')\n\n  if destination is None or not is_relative(destination):\n    destination = '/timeline'\n\n  return redirect(destination)\n\ndef is_relative(url):\n  return re.match(r\"^\/[^\/\\\\]\", url)\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[React]\n\n## Disallowing Offsite Redirects\n\nThere are a number of ways of doing redirects in React code - updating the `window.location` directly, using the \nbrowser's history API, or using the `<Redirect>` component from the `react-router` module. Whichever method you use, it \nis important to check that the URL you are redirecting to is a relative URL - that is, it starts with a single `/` \ncharacter:\n\n```jsx\n/**\n * A wrapper for <Route> that redirects to /feed if the user is authenticated.\n */\nfunction UnauthenticatedRoute(props) {\n  if (!props.loggedIn) {\n    return <Route {...props} />\n  }\n\n  // If the user has just authenticated, check the query string for their intended destination.\n  const parsed = queryString.parse(props.location.search)\n\n  let url = '/feed'\n\n  // Ensure this is a relative URL within the site (i.e. it starts with a single / character.)\n  if (parsed.destination && parsed.destination.match(/^\/[^\/\\\\]/)) {\n    url = parsed.destination\n  }\n\n  return <Redirect to={{ pathname: url }} />\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Scala]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Scala application verifies the \nredirect URL:\n\n```scala\nclass LoginController @Inject()(cc: ControllerComponents, users: UserRepository) extends AbstractController(cc) {\n\n  /**\n   * Process the response from the login page, safely checking for a redirect parameter.\n   */\n  def login = Action(parse.form(loginForm)) { request =>\n    val credentials = request.body\n\n    if (!users.credentialsAreValid(credentials.username, credentials.password)) {\n      Redirect(\"/login\").flashing(\"error\" -> \"Incorrect username or password.\")\n    }\n    else {\n      var next = request.getQueryString(\"destination\").getOrElse(\"/home\")\n\n      if (!isRelative(next)) {\n        next = \"/home\"\n      }\n\n      Redirect(next).withSession(request.session + (\"username\" -> credentials.username))\n    }\n  }\n\n  /**\n   * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\".\n   */\n  def isRelative(url : String) =  {\n    url.matches(\"/[^/\\\\]?.*\");\n  }\n\n  case class Credentials(username: String, password: String)\n\n  def loginForm = Form(\n    mapping(\n      \"username\" -> text,\n      \"password\" -> text\n    )(Credentials.apply)(Credentials.unapply)\n  )\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Go]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Go application verifies the \nredirect URL:\n\n```go\nfunc LoginHandler(response http.ResponseWriter, request *http.Request) {\n  request.ParseForm()\n\n  session, _ := session.Get(request, \"session\")\n\n  username := request.Form.Get(\"username\")\n  password := request.Form.Get(\"password\")\n\n  user := findUserWithPassword(username, password)\n\n  if user == nil {\n    http.Redirect(response, request, \"/login\", http.StatusUnauthorized)\n    return\n  }\n\n  session.Values[\"username\"] = username\n  session.Save(request, response)\n\n  destination := request.URL.Query().Get(\"destination\")\n\n  // Protect against redirect attacks by checking the destination URL starts with a single / character.\n  if destination == \"\" {\n    destination = \"/home\"\n  } else {\n    isRelative, _ := regexp.MatchString(\"^/[^/]\", destination)\n\n    if !isRelative {\n      destination = \"/home\"\n    }\n  }\n\n  http.Redirect(response, request, destination, http.StatusOK)\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[PHP]\n\n## Disallowing Offsite Redirects in PHP\n\nOpen redirects in PHP are commonly introduced when user input is improperly used in the `header` function for redirection. To securely implement redirects, always validate the user-provided URLs before using them. Here's a secure way to handle redirects:\n\n```php\n<?php\nsession_start();\n\n// Assuming some form of user authentication\n$username = $_POST['username'];\n$password = $_POST['password'];\n\nif (!credentialsAreValid($username, $password)) {\n    $_SESSION['message'] = \"Incorrect credentials\";\n    header(\"Location: /login.php\");\n    exit;\n}\n\n$_SESSION['username'] = $username;\n\n$destination = $_GET['destination'];\n\n// Check if the destination URL is a relative path\nif (!isRelativeURL($destination)) {\n    $destination = \"/home.php\";\n}\n\nheader(\"Location: \" . $destination);\nexit;\n\n/**\n * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\\\".\n */\nfunction isRelativeURL($url) {\n    return preg_match('/^\/[^\/\\\\\\\\].*/', $url);\n}\n?>\n```\n\nThe above PHP code checks if a given redirect URL is a relative path, starting with a single `/` character. URLs starting with `//` (interpreted by browsers as protocol agnostic) are also rejected to ensure safety.\n\n:::\n\n::::\n\n## Other Considerations\n\n* Redirects can happen in client-side JavaScript, too. Validate any code that updates `window.location`, to ensure the\n  URL is not taken from untrusted input.\n\n* Some sites insert *interstitial pages* when the user is leaving the site. This is a good defense against \"doppelganger\"\n  domains - websites that have a very similar domain name, that attempt to trick the user into sharing private \n  information. However, interstitial pages are a common place for open redirect vulnerabilities to occur. If you implement \n  an interstitial page that passes the URL in the query parameter, be sure to show the full URL to the user and require user\n  interaction before performing the redirect.\n\n* Social media and link-sharing sites often make use of redirects to do *click-counting*. URLs are chosen by the \n  community, then when a user clicks on the link, the click-through count is incremented, and the user is redirected to \n  their destination. In this situation, you are obligated to redirect the user to an external domains. Consider using a\n  different domain name for such a redirector that does not confer the same trust to users as your regular domain. Alternatively,\n  show a interstitial page (see previous point).\n\n* Some resources recommend checking the `Referer` or `Origin` headers in the HTTP\n  request. This is **not enough** - these may not be available for a variety of reasons:\n\n  + Links from external applications (e.g. email, messengers, PDF readers, Word\n    documents, ...) never have such headers\n\n  + External web sites can redirect through e.g. `data:` or `blob:` URLs or use\n    the `sandbox` attribute on iframes to prevent the browser from sending the\n    `Referer` or `Origin` headers.\n\n  + Various browser settings, firewalls and other privacy software can suppress\n    the submission of these headers.\n\n## Additional information\n\n**[CWE-601](https://cwe.mitre.org/data/definitions/601.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**"
                            },
                            "helpUri": "https://cwe.mitre.org/data/definitions/601.html",
                            "id": "warning-sink-redirect/d8f7e3de405c9f1bc101d75cd92db669",
                            "name": "Open Redirect: Non-Constant Url Target Of Http Redirect In Login_and_redirect",
                            "properties": {
                                "precision": "very-high",
                                "security-severity": "4",
                                "tags": [
                                    "ng-sast",
                                    "CVSS 4",
                                    "CWE 601",
                                    "OWASP 2021 a01-broken-access-control",
                                    "OWASP a01-2021-broken-access-control",
                                    "OWASP a1-injection",
                                    "Open Redirect"
                                ]
                            },
                            "shortDescription": {
                                "text": "Open Redirect: Non-Constant URL Target of HTTP Redirect in login_and_redirect"
                            }
                        },
                        {
                            "defaultConfiguration": {
                                "enabled": true,
                                "level": "warning",
                                "rank": -1
                            },
                            "fullDescription": {
                                "text": "The `Content-Security-Policy` HTTP header contains the `unsafe-inline` directive."
                            },
                            "help": {
                                "markdown": "The `Content-Security-Policy` HTTP header contains the `unsafe-inline` directive.\n This renders the protection against cross-site scripting attacks offered by the header\n ineffectual.\n ## Countermeasures\n - To prevent this vulnerability, remove `unsafe-inline` from the `Content-Security-Policy` header.\n ## Additional information\n **[Content-Security-Policy header](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)**\n **[CWE-933](https://cwe.mitre.org/data/definitions/933.html)**\n **[OWASP-a6](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a6-Security_Misconfiguration)**",
                                "text": "The `Content-Security-Policy` HTTP header contains the `unsafe-inline` directive.\n This renders the protection against cross-site scripting attacks offered by the header\n ineffectual.\n ## Countermeasures\n - To prevent this vulnerability, remove `unsafe-inline` from the `Content-Security-Policy` header.\n ## Additional information\n **[Content-Security-Policy header](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)**\n **[CWE-933](https://cwe.mitre.org/data/definitions/933.html)**\n **[OWASP-a6](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a6-Security_Misconfiguration)**"
                            },
                            "helpUri": "https://cwe.mitre.org/data/definitions/933.html",
                            "id": "security-policy-misconfiguration/b0079c7ab0359820380dd9c1e684dd43",
                            "name": "Security Misconfiguration: Content-Security-Policy Misconfigured In Add_csp_headers",
                            "properties": {
                                "precision": "very-high",
                                "security-severity": "5",
                                "tags": [
                                    "ng-sast",
                                    "CVSS 5",
                                    "CWE 933",
                                    "OWASP 2021 a05-security-misconfiguration",
                                    "OWASP a05-2021-security-misconfiguration",
                                    "OWASP a6-security-misconfiguration",
                                    "Security Misconfiguration"
                                ]
                            },
                            "shortDescription": {
                                "text": "Security Misconfiguration: Content-Security-Policy Misconfigured in add_csp_headers"
                            }
                        },
                        {
                            "defaultConfiguration": {
                                "enabled": true,
                                "level": "note",
                                "rank": -1
                            },
                            "fullDescription": {
                                "text": "A library used in the application is configured to print executed queries to stdout."
                            },
                            "help": {
                                "markdown": "A library used in the application is configured to print executed queries to stdout.\n\n# Sensitive Data Leaks\n\nDisclosing system information helps an adversary learn about your web application and form a plan of attack. You should\ntry to reveal as little about your technology stack and architecture as possible, beyond what is essential for your\nusers to know. Revealing system information makes life easier for an attacker, and gives them a playbook of\nvulnerabilities they can probe for.\n\nHere are some common ways websites leak sensitive data:\n\n* Error conditions that display stack traces or database error messages to the user.\n* Open directory listings that allow exploration of the server's file system.\n* Unsanitized comments in HTML and template files the reveal system details.\n\n::::tabs\n\n:::tab[Java]\n\n## How to Prevent Data Leaks in Java\n\n### Keep Error Reporting on the Server\n\nDisable client-side error reporting in your production environment, by specifying an error page in your `web.xml` file:\n\n```xml\n<error-page>\n  <location>/error.html</location>\n</error-page>\n```\n  \nThis error page should only contain a generic error message (e.g. \"An error occurred\"). Stack traces should be written\nto server-side logs.\n\n### Sanitize Error Messages\n\nMake sure error messages returned from the database or containing system information are logged, but not shown to the\nuser. Here a generic error message is shown to the user, while the detailed error is written to the logs for investigation:\n\n```java\ntry \n{\n    user = getDatabase().findUser(email);\n}\ncatch (SQLException ex) \n{\n    log.error(\"An error occurred looking up the user profiles\", ex):\n    throw new ClientFacingException(\"An unexpected error occurred, please try again later.\");\n}\n```\n\n### Separate Dynamic and Static Resources\n\nEnsure static resources and dynamic content are stored in separate directories, so a malicious user cannot snoop \nthrough your code and configuration files. For example, this is how to tell Java to server static Javascript files\nfrom the `/js` directory:\n  \n```xml\n<servlet-mapping>\n    <servlet-name>default</servlet-name>\n    <url-pattern>/js/*.js</url-pattern>\n</servlet-mapping>\n```\n\n### Disable the \"Server\" Header \n\nConsider disabling the `Server` header and the (non-standard but common) `X-Powered-By` header, and making the session \ncookie name generic. This will give your keep an attacker guessing about what your technology stack is, which makes \nattacking it harder. Here's how to do that in the Jetty web-server:\n  \n```java\nHttpConfiguration.setSendServerVersion(false);\n```\n\n:::\n\n:::tab[C#]\n\n## How to Prevent Data Leaks in C#\n\n### Keep Error Reporting on the Server\n\nDisable client-side error reporting in your production environment. When you create a new ASP.NET application, the \ntemplate will generate a startup class with some configuration logic:\n\n```csharp\n    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n    {\n        if (env.IsDevelopment())\n        {\n            app.UseDeveloperExceptionPage();\n        }\n        else\n        {\n            app.UseExceptionHandler(\"/Home/Error\");\n        }\n    }\n```\n\nThe default error page only contain a generic error message (e.g. \"An error occurred\"), whereas the development-mode\nerror page will log full stack traces.\n\n### Sanitize Error Messages\n\nMake sure error messages returned from the database or containing system information are logged, but not shown to the \nuser. When running in non-development mode the ASP.NET web-server will show a generic error message to the user, while \nthe detailed error is written to the logs for investigation. You can configure the error page that is generated at\n`/Views/Shared/Errors.cs.html`.\n\n### Separate Dynamic and Static Resources\n\nEnsure static resources and dynamic content are stored in separate directories, so a malicious user cannot snoop \nthrough your code and configuration files. An ASP.NET web application can be configured to serve static content under\nthe `wwwroot` directory by adding the following line in the startup configuration:\n\n```csharp\napp.UseStaticFiles();\n```\n\nYou can also add additional static content directories with the following logic:\n\n```csharp\napp.UseStaticFiles(new StaticFileOptions\n{\n    FileProvider = new PhysicalFileProvider(Path.Combine(env.ContentRootPath, \"MyStaticFiles\")),\n    RequestPath = \"/StaticFiles\"\n});\n```\n\n### Disable the \"Server\" Header \n\nConsider disabling the `Server` header and the (non-standard but common) `X-Powered-By` header, and making the session \ncookie name generic. This will give your keep an attacker guessing about what your technology stack is, which makes \nattacking it harder. In ASP.NET, you can programmatically remove it in the following manner:\n\n```csharp\nHttpContext.Current.Response.Headers.Remove(\"Server\");\n```\n\nIf you are deploying to IIS, you can remove the header in your configuration settings:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration>\n    <system.webServer>\n        <security>\n            <requestFiltering removeServerHeader=\"true\" />\n        </security>\n    </system.webServer>\n</configuration>\n```\n\n:::\n\n:::tab[JavaScript]\n\n## How to Prevent Data Leaks in JavaScript\n\n### Keep Error Reporting on the Server\n\nDisable client-side error reporting in your production environment. This Express server will dump stack trace \ninformation only in the `development` environment, and disable it in `production`:\n  \n```javascript\nconst errorhandler = require('errorhandler')\nconst express      = require('express')\n\nconst app = express()\n\napp.use(errorhandler({\n  dumpExceptions : app.get('env') === 'development',\n  showStack      : app.get('env') === 'development'\n}))\n```\n\n### Sanitize Error Messages\n\nMake sure error messages returned from the database are logged, but not shown to the user. Here a generic error \nmessage is shown to the user, while the detailed error is written to the logs for investigation:\n\n```javascript\napp.get('/profile', (request, response) => {\n  db.run('SELECT * FROM USERS WHERE email = ?', [ request.session.user ], (error, user) => {\n    if (error) {\n      log.error(error)\n      response.send('An unexpected error occurred')\n      return\n    }\n\n    response.send(`<p>Your email is ${user.email}</p>`)\n  })\n})\n```\n\n### Separate Dynamic and Static Resources\n\nEnsure static resources and dynamic content are stored in separate directories, so a malicious user cannot snoop \nthrough your code and configuration files. For example, this is how to tell Expression to server static content (like \nclient-side JavaScript and CSS files) from the `/static` directory:\n  \n```javascript\napp.use(express.static(__dirname + '/static'))\n```\n\n### Disable the \"Server\" Header \n\nConsider disabling the `Server` header and the (non-standard but common) `X-Powered-By` header, and making the session \ncookie name generic. This will give your keep an attacker guessing about what your technology stack is, which makes \nattacking it harder. Here's how to do that in Express:\n  \n```javascript\n// Disable the 'X-Powered-By' header.\napp.disable('x-powered-by')\n\nconst cookieParser = require('cookie-parser')\nconst session      = require('express-session')\n\napp.use(cookieParser('secret'))\napp.use(session({\n  cookie : {\n    maxAge   : 60000,\n    httpOnly : true,\n    sameSite : 'strict',\n    secure   : app.get('env') !== 'development'\n  },\n\n  // Make the session cookie name generic.\n  name   : 'session',\n  secret : process.env.SESSION_SECRET || uid.sync(18)\n}))\n```\n\n:::\n\n:::tab[Python]\n\n## How to Prevent Data Leaks in Python\n\n### Keep Error Reporting on the Server\n\nDisable client-side error reporting in your production environment. Observe how the Flask framework uses different error\npages in development and production modes, distinguished by whether the environment variable `FLASK_ENV` is set to\n`development`:\n\n```python\n  @property\n  def debug(self) -> bool:\n     \"\"\"Whether debug mode is enabled. When using ``flask run`` to start\n     the development server, an interactive debugger will be shown for\n     unhandled exceptions, and the server will be reloaded when code\n     changes. This maps to the :data:`DEBUG` config key. This is\n     enabled when :attr:`env` is ``'development'`` and is overridden\n     by the ``FLASK_DEBUG`` environment variable. It may not behave as\n     expected if set in code.\n\n     **Do not enable debug mode when deploying in production.**\"\"\"\n     return self.config[\"DEBUG\"]\n```\n\nThe default error page only contain a generic error message (e.g. \"An error occurred\"), whereas the development-mode\nerror page will log full stack traces, and even allow interactive execution of Python code.\n\n### Sanitize Error Messages\n\nMake sure error messages returned from the database or containing system information are logged, but not shown to the \nuser. When running in non-development mode the Flask web-server will show a generic error message to the user, while \nthe detailed error is written to the logs for investigation:\n\n```python\n  def log_exception(self, exc_info) -> None:\n    \"\"\"Logs an exception.  This is called by :meth:`handle_exception`\n    if debugging is disabled and right before the handler is called.\n    The default implementation logs the exception as error on the\n    :attr:`logger`.\n    \"\"\"\n    self.logger.error(\n        f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n    )\n```\n\n### Separate Dynamic and Static Resources\n\nEnsure static resources and dynamic content are stored in separate directories, so a malicious user cannot snoop \nthrough your code and configuration files. Here's how to specify the directory containing static files (like JavaScript \ncode and images) in the Flask web-server:\n\n```python\nfrom flask import Flask\n\napp = Flask(__name__, static_folder='static')\n```\n\n### Disable the \"Server\" Header \n\nConsider disabling the `Server` header and the (non-standard but common) `X-Powered-By` header, and making the session \ncookie name generic. This will give your keep an attacker guessing about what your technology stack is, which makes \nattacking it harder. In the Gunicorn WSGI container, you can configure this header in your `gunicorn.conf.py` config \nfile:\n\n```python\nimport gunicorn\n\n# Make the server name completely generic.\ngunicorn.SERVER_SOFTWARE = 'Server'\n```\n\n:::\n\n:::tab[Scala]\n\n## How to Prevent Data Leaks in Scala\n\n### Keep Error Reporting on the Server\n\nDisable client-side error reporting in your production environment. Notice how the Play framework uses different error\npages in development and production modes:\n\n```scala\n  /**\n   * Invoked in dev mode when a server error occurs.\n   */\n  protected def onDevServerError(request: RequestHeader, exception: UsefulException): Future[Result] = {\n    Future.successful {\n      implicit val ir: RequestHeader = request\n      InternalServerError(views.html.defaultpages.devError(playEditor, exception))\n    }\n  }\n\n  /**\n   * Invoked in prod mode when a server error occurs.\n   */\n  protected def onProdServerError(request: RequestHeader, exception: UsefulException): Future[Result] =\n    Future.successful {\n      implicit val ir: RequestHeader = request\n      InternalServerError(views.html.defaultpages.error(exception))\n    }\n```\n\nThe default error page only contain a generic error message (e.g. \"An error occurred\"), whereas the development-mode\nerror page will log full stack traces.\n\n### Sanitize Error Messages\n\nMake sure error messages returned from the database or containing system information are logged, but not shown to the \nuser. Here a generic error message is shown to the user, while the detailed error is written to the logs for investigation:\n\n```scala\n  override def onServerError(request: RequestHeader, exception: Throwable): Future[Result] = {\n    try {\n      val usefulException = HttpErrorHandlerExceptions.throwableToUsefulException(sourceMapper, !config.showDevErrors, exception)\n\n      // Write the full error context and stack trace to the log file.\n      logServerError(request, usefulException)\n\n      // Sanitize the error to be displayed to the user, when in production-mode.\n      if (config.showDevErrors) onDevServerError(request, usefulException)\n      else onProdServerError(request, usefulException)\n    } catch {\n      case NonFatal(e) =>\n        logger.error(\"Error while handling error\", e)\n        Future.successful(InternalServerError(fatalErrorMessage(request, e)))\n    }\n  }\n```\n\n### Separate Dynamic and Static Resources\n\nEnsure static resources and dynamic content are stored in separate directories, so a malicious user cannot snoop \nthrough your code and configuration files. In the Play framework, static assets like JavaScript and CSS files are \ntypically kept in a separate `/public` and mapped in the routes file as follows:\n\n```scala\nGET  /assets/*file        controllers.Assets.at(path=\"/public\", file)\n```\n\n### Disable the \"Server\" Header \n\nConsider disabling the `Server` header and the (non-standard but common) `X-Powered-By` header, and making the session \ncookie name generic. This will give your keep an attacker guessing about what your technology stack is, which makes \nattacking it harder. For example, the Akka web-server allows you to disable these headers through configuration options:\n\n```\nakka.http {\n  server {\n    # The default value of the `Server` header to produce if no\n    # explicit `Server`-header was included in a response.\n    # If this value is the empty string and no header was included in\n    # the request, no `Server` header will be rendered at all.\n    server-header = \"\" # akka-http/${akka.http.version}\n  }  \n}\n```\n\n:::\n\n:::tab[Go]\n\n## How to Prevent Data Leaks in Go\n\n### Keep Error Reporting on the Server\n\nDisable client-side error reporting in your production environment. In Go web applications, you typically end up writing\nyour own error pages. Ensure that any pages that handle errors pay use flags to distinguish the environment they are \nexecuting in:\n\n```go\nimport \"flag\"\n\nvar debug = flag.Bool(\"debug\", false, \"Whether to show full error messages on the client\")\n```\n\nA default error page only contain a generic error message (e.g. \"An error occurred\"), whereas the development-mode\nerror page can show more information, like full stack traces.\n\n### Sanitize Error Messages\n\nMake sure error messages returned from the database or containing system information are logged, but not shown to the \nuser. Go functions typically return error codes when then fail, and web handlers will return early when error conditions \noccur. Ensure such code does not leak sensitive system data.\n\n```go\nsession, err := session.Get(request, \"session\")\n\nif err != nil {\n  // The second argument here is returned directly to the client, which leaks information!\n  http.Error(response, err.Error(), http.StatusInternalServerError)\n  return\n}\n```\n\n### Separate Dynamic and Static Resources\n\nEnsure static resources and dynamic content are stored in separate directories, so a malicious user cannot snoop \nthrough your code and configuration files. Here's how to specify the directory containing static files (like JavaScript \ncode and images) in the Gorilla web framework:\n\n```go\nfunc main() {\n  var dir string\n\n  flag.StringVar(&dir, \"dir\", \".\", \"the directory to serve files from. Defaults to the current dir\")\n  flag.Parse()\n  router := mux.NewRouter()\n\n  // This will serve files under http://localhost:8000/static/<filename>\n  router.PathPrefix(\"/static/\").Handler(http.StripPrefix(\"/static/\", http.FileServer(http.Dir(dir))))\n\n  server := &http.Server{\n    Handler: router,\n    Addr:    \"127.0.0.1:8000\"\n  }\n\n  log.Fatal(server.ListenAndServe())\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## How to Prevent Data Leaks in PHP\n\n### Keep Error Reporting on the Server\n\nDisable error reporting to the client in your production environment by setting the `display_errors` directive to `Off` in your `php.ini`:\n\n```ini\ndisplay_errors = Off\n```\n\nYou should instead log the errors for review. Ensure that `log_errors` directive is set to `On`:\n\n```ini\nlog_errors = On\nerror_log = /path/to/php-error.log\n```\n\n### Sanitize Error Messages\n\nAvoid directly echoing out database or system error messages to the user. Instead, present a generic message while logging the exact error for debugging:\n\n```php\ntry \n{\n    $result = $db->query(\"SELECT * FROM users WHERE email = '$email'\");\n}\ncatch (PDOException $e) \n{\n    error_log(\"Database error: \" . $e->getMessage());\n    echo \"An unexpected error occurred, please try again later.\";\n}\n```\n\n### Separate Dynamic and Static Resources\n\nFor websites or web applications using PHP, it's common to store PHP files in one directory and static resources (e.g., images, stylesheets, and JavaScript files) in separate directories. This way, you can use server configurations to ensure direct access to PHP files is restricted.\n\n### Hide PHP Version Information\n\nThe `X-Powered-By` header can give away the PHP version you're running. To hide this:\n\n1. Edit `php.ini` and update:\n\n```ini\nexpose_php = Off\n```\n\nOr, if you're using an `.htaccess` file on an Apache server:\n\n```apache\nHeader unset X-Powered-By\n```\n\n### Be Careful With Comments\n\nAvoid leaving sensitive or internal-only comments in your PHP files. Even if you think they are in a part of the code that doesn't output to the user, mistakes or changes in the codebase could expose them. Always assume that anything in a code file could potentially be exposed.\n\n:::\n\n::::\n\n## Further Considerations\n\n* Ensure any comments in template files don't contain sensitive data! It's easy to leave in notes about server names\n  and addresses that will get passed to the client-side. Attackers know this, and will scan comments in HTML for IP\n  addresses and URLs.\n  \n* Ensure server-side log messages do not contain sensitive information like passwords or credit card numbers - this \n  should mitigate the harm an attacker can do if they manage to steal your server's log files.\n  \n\n## Additional information\n\n**[CWE-200](https://cwe.mitre.org/data/definitions/200.html)**\n\n**[OWASP-A3](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A3-Sensitive_Data_Exposure)**",
                                "text": "A library used in the application is configured to print executed queries to stdout.\n\n# Sensitive Data Leaks\n\nDisclosing system information helps an adversary learn about your web application and form a plan of attack. You should\ntry to reveal as little about your technology stack and architecture as possible, beyond what is essential for your\nusers to know. Revealing system information makes life easier for an attacker, and gives them a playbook of\nvulnerabilities they can probe for.\n\nHere are some common ways websites leak sensitive data:\n\n* Error conditions that display stack traces or database error messages to the user.\n* Open directory listings that allow exploration of the server's file system.\n* Unsanitized comments in HTML and template files the reveal system details.\n\n::::tabs\n\n:::tab[Java]\n\n## How to Prevent Data Leaks in Java\n\n### Keep Error Reporting on the Server\n\nDisable client-side error reporting in your production environment, by specifying an error page in your `web.xml` file:\n\n```xml\n<error-page>\n  <location>/error.html</location>\n</error-page>\n```\n  \nThis error page should only contain a generic error message (e.g. \"An error occurred\"). Stack traces should be written\nto server-side logs.\n\n### Sanitize Error Messages\n\nMake sure error messages returned from the database or containing system information are logged, but not shown to the\nuser. Here a generic error message is shown to the user, while the detailed error is written to the logs for investigation:\n\n```java\ntry \n{\n    user = getDatabase().findUser(email);\n}\ncatch (SQLException ex) \n{\n    log.error(\"An error occurred looking up the user profiles\", ex):\n    throw new ClientFacingException(\"An unexpected error occurred, please try again later.\");\n}\n```\n\n### Separate Dynamic and Static Resources\n\nEnsure static resources and dynamic content are stored in separate directories, so a malicious user cannot snoop \nthrough your code and configuration files. For example, this is how to tell Java to server static Javascript files\nfrom the `/js` directory:\n  \n```xml\n<servlet-mapping>\n    <servlet-name>default</servlet-name>\n    <url-pattern>/js/*.js</url-pattern>\n</servlet-mapping>\n```\n\n### Disable the \"Server\" Header \n\nConsider disabling the `Server` header and the (non-standard but common) `X-Powered-By` header, and making the session \ncookie name generic. This will give your keep an attacker guessing about what your technology stack is, which makes \nattacking it harder. Here's how to do that in the Jetty web-server:\n  \n```java\nHttpConfiguration.setSendServerVersion(false);\n```\n\n:::\n\n:::tab[C#]\n\n## How to Prevent Data Leaks in C#\n\n### Keep Error Reporting on the Server\n\nDisable client-side error reporting in your production environment. When you create a new ASP.NET application, the \ntemplate will generate a startup class with some configuration logic:\n\n```csharp\n    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n    {\n        if (env.IsDevelopment())\n        {\n            app.UseDeveloperExceptionPage();\n        }\n        else\n        {\n            app.UseExceptionHandler(\"/Home/Error\");\n        }\n    }\n```\n\nThe default error page only contain a generic error message (e.g. \"An error occurred\"), whereas the development-mode\nerror page will log full stack traces.\n\n### Sanitize Error Messages\n\nMake sure error messages returned from the database or containing system information are logged, but not shown to the \nuser. When running in non-development mode the ASP.NET web-server will show a generic error message to the user, while \nthe detailed error is written to the logs for investigation. You can configure the error page that is generated at\n`/Views/Shared/Errors.cs.html`.\n\n### Separate Dynamic and Static Resources\n\nEnsure static resources and dynamic content are stored in separate directories, so a malicious user cannot snoop \nthrough your code and configuration files. An ASP.NET web application can be configured to serve static content under\nthe `wwwroot` directory by adding the following line in the startup configuration:\n\n```csharp\napp.UseStaticFiles();\n```\n\nYou can also add additional static content directories with the following logic:\n\n```csharp\napp.UseStaticFiles(new StaticFileOptions\n{\n    FileProvider = new PhysicalFileProvider(Path.Combine(env.ContentRootPath, \"MyStaticFiles\")),\n    RequestPath = \"/StaticFiles\"\n});\n```\n\n### Disable the \"Server\" Header \n\nConsider disabling the `Server` header and the (non-standard but common) `X-Powered-By` header, and making the session \ncookie name generic. This will give your keep an attacker guessing about what your technology stack is, which makes \nattacking it harder. In ASP.NET, you can programmatically remove it in the following manner:\n\n```csharp\nHttpContext.Current.Response.Headers.Remove(\"Server\");\n```\n\nIf you are deploying to IIS, you can remove the header in your configuration settings:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration>\n    <system.webServer>\n        <security>\n            <requestFiltering removeServerHeader=\"true\" />\n        </security>\n    </system.webServer>\n</configuration>\n```\n\n:::\n\n:::tab[JavaScript]\n\n## How to Prevent Data Leaks in JavaScript\n\n### Keep Error Reporting on the Server\n\nDisable client-side error reporting in your production environment. This Express server will dump stack trace \ninformation only in the `development` environment, and disable it in `production`:\n  \n```javascript\nconst errorhandler = require('errorhandler')\nconst express      = require('express')\n\nconst app = express()\n\napp.use(errorhandler({\n  dumpExceptions : app.get('env') === 'development',\n  showStack      : app.get('env') === 'development'\n}))\n```\n\n### Sanitize Error Messages\n\nMake sure error messages returned from the database are logged, but not shown to the user. Here a generic error \nmessage is shown to the user, while the detailed error is written to the logs for investigation:\n\n```javascript\napp.get('/profile', (request, response) => {\n  db.run('SELECT * FROM USERS WHERE email = ?', [ request.session.user ], (error, user) => {\n    if (error) {\n      log.error(error)\n      response.send('An unexpected error occurred')\n      return\n    }\n\n    response.send(`<p>Your email is ${user.email}</p>`)\n  })\n})\n```\n\n### Separate Dynamic and Static Resources\n\nEnsure static resources and dynamic content are stored in separate directories, so a malicious user cannot snoop \nthrough your code and configuration files. For example, this is how to tell Expression to server static content (like \nclient-side JavaScript and CSS files) from the `/static` directory:\n  \n```javascript\napp.use(express.static(__dirname + '/static'))\n```\n\n### Disable the \"Server\" Header \n\nConsider disabling the `Server` header and the (non-standard but common) `X-Powered-By` header, and making the session \ncookie name generic. This will give your keep an attacker guessing about what your technology stack is, which makes \nattacking it harder. Here's how to do that in Express:\n  \n```javascript\n// Disable the 'X-Powered-By' header.\napp.disable('x-powered-by')\n\nconst cookieParser = require('cookie-parser')\nconst session      = require('express-session')\n\napp.use(cookieParser('secret'))\napp.use(session({\n  cookie : {\n    maxAge   : 60000,\n    httpOnly : true,\n    sameSite : 'strict',\n    secure   : app.get('env') !== 'development'\n  },\n\n  // Make the session cookie name generic.\n  name   : 'session',\n  secret : process.env.SESSION_SECRET || uid.sync(18)\n}))\n```\n\n:::\n\n:::tab[Python]\n\n## How to Prevent Data Leaks in Python\n\n### Keep Error Reporting on the Server\n\nDisable client-side error reporting in your production environment. Observe how the Flask framework uses different error\npages in development and production modes, distinguished by whether the environment variable `FLASK_ENV` is set to\n`development`:\n\n```python\n  @property\n  def debug(self) -> bool:\n     \"\"\"Whether debug mode is enabled. When using ``flask run`` to start\n     the development server, an interactive debugger will be shown for\n     unhandled exceptions, and the server will be reloaded when code\n     changes. This maps to the :data:`DEBUG` config key. This is\n     enabled when :attr:`env` is ``'development'`` and is overridden\n     by the ``FLASK_DEBUG`` environment variable. It may not behave as\n     expected if set in code.\n\n     **Do not enable debug mode when deploying in production.**\"\"\"\n     return self.config[\"DEBUG\"]\n```\n\nThe default error page only contain a generic error message (e.g. \"An error occurred\"), whereas the development-mode\nerror page will log full stack traces, and even allow interactive execution of Python code.\n\n### Sanitize Error Messages\n\nMake sure error messages returned from the database or containing system information are logged, but not shown to the \nuser. When running in non-development mode the Flask web-server will show a generic error message to the user, while \nthe detailed error is written to the logs for investigation:\n\n```python\n  def log_exception(self, exc_info) -> None:\n    \"\"\"Logs an exception.  This is called by :meth:`handle_exception`\n    if debugging is disabled and right before the handler is called.\n    The default implementation logs the exception as error on the\n    :attr:`logger`.\n    \"\"\"\n    self.logger.error(\n        f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n    )\n```\n\n### Separate Dynamic and Static Resources\n\nEnsure static resources and dynamic content are stored in separate directories, so a malicious user cannot snoop \nthrough your code and configuration files. Here's how to specify the directory containing static files (like JavaScript \ncode and images) in the Flask web-server:\n\n```python\nfrom flask import Flask\n\napp = Flask(__name__, static_folder='static')\n```\n\n### Disable the \"Server\" Header \n\nConsider disabling the `Server` header and the (non-standard but common) `X-Powered-By` header, and making the session \ncookie name generic. This will give your keep an attacker guessing about what your technology stack is, which makes \nattacking it harder. In the Gunicorn WSGI container, you can configure this header in your `gunicorn.conf.py` config \nfile:\n\n```python\nimport gunicorn\n\n# Make the server name completely generic.\ngunicorn.SERVER_SOFTWARE = 'Server'\n```\n\n:::\n\n:::tab[Scala]\n\n## How to Prevent Data Leaks in Scala\n\n### Keep Error Reporting on the Server\n\nDisable client-side error reporting in your production environment. Notice how the Play framework uses different error\npages in development and production modes:\n\n```scala\n  /**\n   * Invoked in dev mode when a server error occurs.\n   */\n  protected def onDevServerError(request: RequestHeader, exception: UsefulException): Future[Result] = {\n    Future.successful {\n      implicit val ir: RequestHeader = request\n      InternalServerError(views.html.defaultpages.devError(playEditor, exception))\n    }\n  }\n\n  /**\n   * Invoked in prod mode when a server error occurs.\n   */\n  protected def onProdServerError(request: RequestHeader, exception: UsefulException): Future[Result] =\n    Future.successful {\n      implicit val ir: RequestHeader = request\n      InternalServerError(views.html.defaultpages.error(exception))\n    }\n```\n\nThe default error page only contain a generic error message (e.g. \"An error occurred\"), whereas the development-mode\nerror page will log full stack traces.\n\n### Sanitize Error Messages\n\nMake sure error messages returned from the database or containing system information are logged, but not shown to the \nuser. Here a generic error message is shown to the user, while the detailed error is written to the logs for investigation:\n\n```scala\n  override def onServerError(request: RequestHeader, exception: Throwable): Future[Result] = {\n    try {\n      val usefulException = HttpErrorHandlerExceptions.throwableToUsefulException(sourceMapper, !config.showDevErrors, exception)\n\n      // Write the full error context and stack trace to the log file.\n      logServerError(request, usefulException)\n\n      // Sanitize the error to be displayed to the user, when in production-mode.\n      if (config.showDevErrors) onDevServerError(request, usefulException)\n      else onProdServerError(request, usefulException)\n    } catch {\n      case NonFatal(e) =>\n        logger.error(\"Error while handling error\", e)\n        Future.successful(InternalServerError(fatalErrorMessage(request, e)))\n    }\n  }\n```\n\n### Separate Dynamic and Static Resources\n\nEnsure static resources and dynamic content are stored in separate directories, so a malicious user cannot snoop \nthrough your code and configuration files. In the Play framework, static assets like JavaScript and CSS files are \ntypically kept in a separate `/public` and mapped in the routes file as follows:\n\n```scala\nGET  /assets/*file        controllers.Assets.at(path=\"/public\", file)\n```\n\n### Disable the \"Server\" Header \n\nConsider disabling the `Server` header and the (non-standard but common) `X-Powered-By` header, and making the session \ncookie name generic. This will give your keep an attacker guessing about what your technology stack is, which makes \nattacking it harder. For example, the Akka web-server allows you to disable these headers through configuration options:\n\n```\nakka.http {\n  server {\n    # The default value of the `Server` header to produce if no\n    # explicit `Server`-header was included in a response.\n    # If this value is the empty string and no header was included in\n    # the request, no `Server` header will be rendered at all.\n    server-header = \"\" # akka-http/${akka.http.version}\n  }  \n}\n```\n\n:::\n\n:::tab[Go]\n\n## How to Prevent Data Leaks in Go\n\n### Keep Error Reporting on the Server\n\nDisable client-side error reporting in your production environment. In Go web applications, you typically end up writing\nyour own error pages. Ensure that any pages that handle errors pay use flags to distinguish the environment they are \nexecuting in:\n\n```go\nimport \"flag\"\n\nvar debug = flag.Bool(\"debug\", false, \"Whether to show full error messages on the client\")\n```\n\nA default error page only contain a generic error message (e.g. \"An error occurred\"), whereas the development-mode\nerror page can show more information, like full stack traces.\n\n### Sanitize Error Messages\n\nMake sure error messages returned from the database or containing system information are logged, but not shown to the \nuser. Go functions typically return error codes when then fail, and web handlers will return early when error conditions \noccur. Ensure such code does not leak sensitive system data.\n\n```go\nsession, err := session.Get(request, \"session\")\n\nif err != nil {\n  // The second argument here is returned directly to the client, which leaks information!\n  http.Error(response, err.Error(), http.StatusInternalServerError)\n  return\n}\n```\n\n### Separate Dynamic and Static Resources\n\nEnsure static resources and dynamic content are stored in separate directories, so a malicious user cannot snoop \nthrough your code and configuration files. Here's how to specify the directory containing static files (like JavaScript \ncode and images) in the Gorilla web framework:\n\n```go\nfunc main() {\n  var dir string\n\n  flag.StringVar(&dir, \"dir\", \".\", \"the directory to serve files from. Defaults to the current dir\")\n  flag.Parse()\n  router := mux.NewRouter()\n\n  // This will serve files under http://localhost:8000/static/<filename>\n  router.PathPrefix(\"/static/\").Handler(http.StripPrefix(\"/static/\", http.FileServer(http.Dir(dir))))\n\n  server := &http.Server{\n    Handler: router,\n    Addr:    \"127.0.0.1:8000\"\n  }\n\n  log.Fatal(server.ListenAndServe())\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## How to Prevent Data Leaks in PHP\n\n### Keep Error Reporting on the Server\n\nDisable error reporting to the client in your production environment by setting the `display_errors` directive to `Off` in your `php.ini`:\n\n```ini\ndisplay_errors = Off\n```\n\nYou should instead log the errors for review. Ensure that `log_errors` directive is set to `On`:\n\n```ini\nlog_errors = On\nerror_log = /path/to/php-error.log\n```\n\n### Sanitize Error Messages\n\nAvoid directly echoing out database or system error messages to the user. Instead, present a generic message while logging the exact error for debugging:\n\n```php\ntry \n{\n    $result = $db->query(\"SELECT * FROM users WHERE email = '$email'\");\n}\ncatch (PDOException $e) \n{\n    error_log(\"Database error: \" . $e->getMessage());\n    echo \"An unexpected error occurred, please try again later.\";\n}\n```\n\n### Separate Dynamic and Static Resources\n\nFor websites or web applications using PHP, it's common to store PHP files in one directory and static resources (e.g., images, stylesheets, and JavaScript files) in separate directories. This way, you can use server configurations to ensure direct access to PHP files is restricted.\n\n### Hide PHP Version Information\n\nThe `X-Powered-By` header can give away the PHP version you're running. To hide this:\n\n1. Edit `php.ini` and update:\n\n```ini\nexpose_php = Off\n```\n\nOr, if you're using an `.htaccess` file on an Apache server:\n\n```apache\nHeader unset X-Powered-By\n```\n\n### Be Careful With Comments\n\nAvoid leaving sensitive or internal-only comments in your PHP files. Even if you think they are in a part of the code that doesn't output to the user, mistakes or changes in the codebase could expose them. Always assume that anything in a code file could potentially be exposed.\n\n:::\n\n::::\n\n## Further Considerations\n\n* Ensure any comments in template files don't contain sensitive data! It's easy to leave in notes about server names\n  and addresses that will get passed to the client-side. Attackers know this, and will scan comments in HTML for IP\n  addresses and URLs.\n  \n* Ensure server-side log messages do not contain sensitive information like passwords or credit card numbers - this \n  should mitigate the harm an attacker can do if they manage to steal your server's log files.\n  \n\n## Additional information\n\n**[CWE-200](https://cwe.mitre.org/data/definitions/200.html)**\n\n**[OWASP-A3](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A3-Sensitive_Data_Exposure)**"
                            },
                            "helpUri": "https://cwe.mitre.org/data/definitions/200.html",
                            "id": "log-sensitive-data-fuzzy/a8f021e8f4026424a70930734f4fd4a3",
                            "name": "Sensitive Data Exposure: Library Is Configured To Print Potentially Sensitive Data In Query_db",
                            "properties": {
                                "precision": "very-high",
                                "security-severity": "3",
                                "tags": [
                                    "ng-sast",
                                    "CVSS 3",
                                    "CWE 200",
                                    "CWE 550",
                                    "OWASP 2021 a01-broken-access-control",
                                    "OWASP a01-2021-broken-access-control",
                                    "OWASP a3-sensitive-data-exposure",
                                    "Sensitive Data Exposure"
                                ]
                            },
                            "shortDescription": {
                                "text": "Sensitive Data Exposure: Library is Configured to Print Potentially Sensitive Data in query_db"
                            }
                        },
                        {
                            "defaultConfiguration": {
                                "enabled": true,
                                "level": "error",
                                "rank": -1
                            },
                            "fullDescription": {
                                "text": "The Pallets Project Flask before 1.0 is affected by unexpected memory usage. The impact is denial of service. The attack vector is crafted encoded JSON data. The fixed version is 1. NOTE this may overlap CVE-2018-1000656."
                            },
                            "help": {
                                "markdown": "The Pallets Project Flask before 1.0 is affected by unexpected memory usage. The impact is denial of service. The attack vector is crafted encoded JSON data. The fixed version is 1. NOTE this may overlap CVE-2018-1000656.",
                                "text": "The Pallets Project Flask before 1.0 is affected by unexpected memory usage. The impact is denial of service. The attack vector is crafted encoded JSON data. The fixed version is 1. NOTE this may overlap CVE-2018-1000656."
                            },
                            "helpUri": "https://cwe.mitre.org/data/definitions/400.html",
                            "id": "oss_vuln/e89ac22d6250e43971413f2c7ca25e6c",
                            "name": "Pkg:pypi/Flask@0.12.5",
                            "properties": {
                                "precision": "very-high",
                                "security-severity": "7.5",
                                "tags": [
                                    "ng-sast",
                                    "CVE-2019-1010083",
                                    "CVSS 7.5",
                                    "CWE 400",
                                    "No exploits",
                                    "Unreachable"
                                ]
                            },
                            "shortDescription": {
                                "text": "pkg:pypi/flask@0.12.5"
                            }
                        }
                    ],
                    "version": "1.0.0"
                }
            }
        }
    ],
    "inlineExternalProperties": [
        {
            "guid": "f2404207-6fd9-432d-8266-4be49e37e841",
            "runGuid": "4e6f9695-47db-40da-ad67-31c9ede02bc9"
        }
    ],
    "properties": {}
}